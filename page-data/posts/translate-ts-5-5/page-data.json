{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-5/","result":{"data":{"markdownRemark":{"html":"<!-- 썸네일 -->\n<!-- 본문 -->\n<blockquote>\n<p>TypeScript 5.5에서 중요하다고 생각되는 부분을 번역했습니다. 더 자세한 글은 아래 원글 링크를 참고해주세요.\r\n<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-5-5/\">https://devblogs.microsoft.com/typescript/announcing-typescript-5-5/</a></p>\n</blockquote>\n<h2 id=\"추론된-타입-서술\">추론된 타입 서술</h2>\n<p>TypeScript의 제어 흐름 분석은 변수 타입이 코드에서 어떻게 변화하는지 추적한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span>\r\n    commonName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\r\n    scientificName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">sing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// Maps country names -> national bird.</span>\r\n<span class=\"token comment\">// Not all nations have official birds (looking at you, Canada!)</span>\r\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> nationalBirds<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> Bird<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeNationalBirdCall</span><span class=\"token punctuation\">(</span>country<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> bird <span class=\"token operator\">=</span> nationalBirds<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>country<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// bird has a declared type of Bird | undefined</span>\r\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bird<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    bird<span class=\"token punctuation\">.</span><span class=\"token function\">sing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// bird has type Bird inside the if statement</span>\r\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// bird has type undefined here.</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">undefined</code> 경우를 처리하도록 하여 TypeScript는 더 견고한 코드를 작성하도록 유도한다.</p>\n<p>과거에는 이러한 타입 정제를 배열에 적용하기 어려웠다. 이 코드는 이전 모든 버전의 TypeScript에서 오류가 발생했을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBirdCalls</span><span class=\"token punctuation\">(</span>countries<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token comment\">// birds: (Bird | undefined)[]</span>\r\n  <span class=\"token keyword\">const</span> birds <span class=\"token operator\">=</span> countries\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>country <span class=\"token operator\">=></span> nationalBirds<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>country<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>bird <span class=\"token operator\">=></span> bird <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> bird <span class=\"token keyword\">of</span> birds<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    bird<span class=\"token punctuation\">.</span><span class=\"token function\">sing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// error: 'bird' is possibly 'undefined'.</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모든 <code class=\"language-text\">undefined</code> 값을 목록에서 필터링 했기 때문에 이 코드는 완벽하게 정상이지만 TypeScript가 따라가지 못했다.</p>\n<p>TypeScript 5.5에서는 타입 체커가 이 코드를 올바르게 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBirdCalls</span><span class=\"token punctuation\">(</span>countries<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token comment\">// birds: Bird[]</span>\r\n  <span class=\"token keyword\">const</span> birds <span class=\"token operator\">=</span> countries\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>country <span class=\"token operator\">=></span> nationalBirds<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>country<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>bird <span class=\"token operator\">=></span> bird <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> bird <span class=\"token keyword\">of</span> birds<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    bird<span class=\"token punctuation\">.</span><span class=\"token function\">sing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ok!</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">birds</code>의 더 정밀한 타입을 주목하자.</p>\n<p>이는 TypeScript가 이제 <code class=\"language-text\">filter</code> 함수에 대해 타입 서술을 추론하기 때문이다. 이를 독립된 함수로 분리하여 더 명확하게 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// function isBirdReal(bird: Bird | undefined): bird is Bird</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">isBirdReal</span><span class=\"token punctuation\">(</span>bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> bird <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">bird is Bird</code>는 type predicate(타입 서술)이다. 즉 함수가 참을 반환하면 <code class=\"language-text\">Bird</code>가 되고 <code class=\"language-text\">false</code>를 반환하면 <code class=\"language-text\">undefined</code>라는 것을 의미한다. <code class=\"language-text\">Array.prototype.filter</code>는 타입 서술을 알고 있으므로 더 정밀한 타입을 얻을 수 있다.</p>\n<p>TypeScript는 다음 조건이 충족되면 함수가 타입 서술을 반환한다고 추론한다</p>\n<ol>\n<li>명시적 반환 타입 또는 타입 서술 주석이 없음</li>\n<li>단일 반환문과 암시적 반환이 없음</li>\n<li>매개변수를 변형하지 않음</li>\n<li>매개변수의 정제와 관련된 boolean 표현식을 반환함</li>\n</ol>\n<p>추론된 타입 서술의 몇 가지 예는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// const isNumber: (x: unknown) => x is number</span>\r\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isNumber</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// const isNonNullish: &lt;T>(x: T) => x is NonNullable&lt;T></span>\r\n<span class=\"token keyword\">const</span> isNonNullish <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이전에는 TypeScript가 이러한 함수가 <code class=\"language-text\">boolean</code>을 반환한다고만 추론했지만, 이제는 <code class=\"language-text\">x is number</code> 또는 <code class=\"language-text\">x is NonNullable&lt;T></code>와 같은 타입 서술을 포함한 시그니처를 추론한다.</p>\n<p>타입 서술은 \"오직 ~한 경우에만\"이라는 의미를 가진다. 함수가 <code class=\"language-text\">x is T</code>를 반환하면</p>\n<ol>\n<li>함수가 <code class=\"language-text\">true</code>를 반환하면 <code class=\"language-text\">x</code>는 타입 <code class=\"language-text\">T</code>를 가진다.</li>\n<li>함수가 <code class=\"language-text\">false</code>를 반환하면 <code class=\"language-text\">x</code>는 타입 <code class=\"language-text\">T</code>를 가지지 않는다.</li>\n</ol>\n<p>타입 서술이 추론되지 않는 경우, 두 번째 규칙을 어겼을 가능성이 크다. 이는 종종 \"truthiness\" 검사에서 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">getClassroomAverage</span><span class=\"token punctuation\">(</span>students<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> allScores<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> studentScores <span class=\"token operator\">=</span> students\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">=></span> allScores<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>score <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>score<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token keyword\">return</span> studentScores<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> studentScores<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\r\n  <span class=\"token comment\">// error: Object is possibly 'undefined'.</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeScript는 <code class=\"language-score =\"> !!score</code>에 대해 타입 서술을 추론하지 않는다. 이는 올바른 판단이다. 이 함수가 <code class=\"language-text\">true</code>를 반환하면 <code class=\"language-text\">score</code>는 <code class=\"language-text\">number</code>이지만, <code class=\"language-text\">false</code>를 반환하면 <code class=\"language-text\">score</code>는 <code class=\"language-text\">undefined</code> 또는 숫자(구체적으로 <code class=\"language-text\">0</code>)일 수 있다. 이는 실제 버그로, 시험에서 0점을 받은 학생의 점수를 필터링하면 평균이 왜곡된다.</p>\n<p>따라서, <code class=\"language-text\">undefined</code> 값을 명시적으로 필터링하는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">getClassroomAverage</span><span class=\"token punctuation\">(</span>students<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> allScores<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> studentScores <span class=\"token operator\">=</span> students\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">=></span> allScores<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>score <span class=\"token operator\">=></span> score <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token keyword\">return</span> studentScores<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> studentScores<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ok!</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>참거짓(truthiness) 검사는 모호성이 없는 객체 타입에 대해서는 타입 서술을 추론한다. 함수가 추론된 타입 서술의 후보가 되려면 boolean을 반환해야 한다: <code class=\"language-x =\"> !!x</code>는 타입 서술을 추론할 수 있지만 <code class=\"language-x =\"> x</code>는 그렇지 못한다.</p>\n<p>명시적 타입 서술은 기존과 동일하게 작동하며, TypeScript는 동일한 타입 서술을 추론할지 여부를 확인하지 않는다. 명시적 타입 서술(\"is\")은 타입 단언(\"as\")과 마찬가지로 안전하지 않다.</p>\n<p>이 기능이 더 정밀한 타입을 추론하여 기존 코드를 깨뜨릴 가능성이 있다. 예를 들어</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Previously, nums: (number | null)[]</span>\r\n<span class=\"token comment\">// Now, nums: number[]</span>\r\n<span class=\"token keyword\">const</span> nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nnums<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ok in TS 5.4, error in TS 5.5</span></code></pre></div>\n<p>해결책은 명시적으로 배열에 타입을 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> nums<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nnums<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ok in all versions</span></code></pre></div>\n<h2 id=\"상수-인덱스-접근에-대한-제어-흐름-좁히기\">상수 인덱스 접근에 대한 제어 흐름 좁히기</h2>\n<p>TypeScript는 이제 <code class=\"language-text\">obj</code>와 <code class=\"language-text\">key</code>가 모두 사실상 상수일 때 <code class=\"language-text\">obj[key]</code> 형태의 표현식을 좁힐 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> Record<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// Now okay, previously was error</span>\r\n        obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 예제에서, <code class=\"language-text\">obj</code>나 <code class=\"language-text\">key</code>는 변경되지 않으므로 TypeScript는 <code class=\"language-text\">typeof</code> 검사를 통해 <code class=\"language-text\">obj[key]</code>의 타입을 <code class=\"language-text\">string</code>으로 좁힐 수 있다.</p>\n<h2 id=\"jsdoc-import-태그\">JSDoc <code class=\"language-text\">@import</code> 태그</h2>\n<p>오늘날 JavaScript 파일에서 타입 검사만을 위해 무언가를 가져오려면 번거롭다. JavaScript 개발자는 런타임에 존재하지 않는 <code class=\"language-text\">SomeType</code>이라는 이름의 타입을 단순히 import할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ./some-module.d.ts</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">SomeType</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// ./index.js</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SomeType <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./some-module\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ❌ runtime error!</span>\r\n\r\n<span class=\"token comment\">/**\r\n * @param {SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">SomeType</code>는 런타임에 존재하지 않으므로 import가 실패한다. 대신, 개발자는 네임스페이스 import를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> someModule <span class=\"token keyword\">from</span> <span class=\"token string\">\"./some-module\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">/**\r\n * @param {someModule.SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 <code class=\"language-text\">./some-module</code>은 여전히 런타임에 import된다.</p>\n<p>이를 피하기 위해, 개발자들은 일반적으로 JSDoc 주석에서 <code class=\"language-text\">import(...)</code> 타입을 사용해야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\r\n * @param {import(\"./some-module\").SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여러 곳에서 동일한 타입을 재사용하려면, <code class=\"language-text\">typedef</code>를 사용하여 import를 반복하는 것을 피할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\r\n * @typedef {import(\"./some-module\").SomeType} SomeType\r\n */</span>\r\n\r\n<span class=\"token comment\">/**\r\n * @param {SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방식은 <code class=\"language-text\">SomeType</code>의 로컬 사용에는 도움이 되지만, 많은 import에 반복적으로 사용하면 번거로울 수 있다.</p>\n<p>그래서 TypeScript는 이제 ECMAScript import와 동일한 문법을 사용하는 새로운 <code class=\"language-text\">@import</code> 주석 태그를 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/** @import { SomeType } from \"some-module\" */</span>\r\n\r\n<span class=\"token comment\">/**\r\n * @param {SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 명시적 import를 사용했다. 네임스페이스 import로도 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/** @import * as someModule from \"some-module\" */</span>\r\n\r\n<span class=\"token comment\">/**\r\n * @param {someModule.SomeType} myValue\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>myValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 JSDoc 주석일 뿐이므로 런타임 동작에 전혀 영향을 미치지 않는다.</p>\n<h2 id=\"정규-표현식-구문-검사\">정규 표현식 구문 검사</h2>\n<p>지금까지 TypeScript는 코드에서 대부분의 정규 표현식을 건너뛰었다. 이는 정규 표현식이 확장 가능한 문법을 가지고 있으며, TypeScript가 이전 버전의 JavaScript로 컴파일하는 노력을 기울이지 않았기 때문이다. 그 결과, 정규 표현식에서 많은 일반적인 문제들이 발견되지 못하고 런타임 오류로 이어지거나 조용히 실패하곤 했다.</p>\n<p>그러나 이제 TypeScript는 정규 표현식에 대한 기본 구문 검사를 수행한다! 이를 통해 많은 일반적인 오류를 사전에 발견할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> myRegex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">@robot(\\s+(please|immediately)))? do some task</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                            ~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// Unexpected ')'. Did you mean to escape it with backslash?</span></code></pre></div>\n<p>이것은 단순한 예제이지만, 이러한 검사는 많은 일반적인 실수를 잡아낼 수 있다. 사실, TypeScript의 검사는 단순한 구문 검사를 넘어선다. 예를 들어, 존재하지 않는 역참조(backreference) 문제를 잡아낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> myRegex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">u</span></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                                        ~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// This backreference refers to a group that does not exist.</span>\r\n<span class=\"token comment\">// There are only 2 capturing groups in this regular expression.</span></code></pre></div>\n<p>같은 원칙이 명명된 캡처 그룹(named capturing groups)에도 적용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> myRegex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">@typedef \\{import\\((?&lt;importPath>.+)\\)\\.(?&lt;importedEntity>[a-zA-Z_]+)\\} \\k&lt;namedImport></span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                                                                        ~~~~~~~~~~~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// There is no capturing group named 'namedImport' in this regular expression.</span></code></pre></div>\n<p>TypeScript의 검사는 이제 특정 RegExp 기능이 ECMAScript의 대상 버전보다 최신일 때도 인식한다. 예를 들어, ES5 타겟에서 위와 같이 명명된 캡처 그룹을 사용하면 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> myRegex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">@typedef \\{import\\((?&lt;importPath>.+)\\)\\.(?&lt;importedEntity>[a-zA-Z_]+)\\} \\k&lt;importedEntity></span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// Named capturing groups are only available when targeting 'ES2018' or later.</span></code></pre></div>\n<p>특정 정규 표현식 플래그도 마찬가지이다.</p>\n<p>TypeScript의 정규 표현식 지원은 정규 표현식 리터럴로 제한된다. 문자열 리터럴을 사용하여 new RegExp를 호출하면 TypeScript는 제공된 문자열을 검사하지 않는다.</p>\n<h2 id=\"새로운-ecmascript-set-메서드-지원\">새로운 ECMAScript Set 메서드 지원</h2>\n<p>TypeScript 5.5는 ECMAScript <code class=\"language-text\">Set</code> 타입에 대한 새로운 제안된 메서드를 선언한다.</p>\n<p>이러한 메서드 중 일부는 <code class=\"language-text\">union</code>, <code class=\"language-text\">intersection</code>, <code class=\"language-text\">difference</code>, <code class=\"language-text\">symmetricDifference</code>로, 다른 <code class=\"language-text\">Set</code>을 받아 새로운 <code class=\"language-text\">Set</code>을 반환한다. 다른 메서드인 <code class=\"language-text\">isSubsetOf</code>, <code class=\"language-text\">isSupersetOf</code>, <code class=\"language-text\">isDisjointFrom</code>은 다른 <code class=\"language-text\">Set</code>을 받아 <code class=\"language-text\">boolean</code>을 반환한다. 이들 메서드는 원래의 <code class=\"language-text\">Set</code>을 변경하지 않는다.</p>\n<p>다음은 이러한 메서드를 사용하는 예제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> fruits <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"apples\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bananas\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"pears\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"oranges\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> applesAndBananas <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"apples\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bananas\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> applesAndOranges <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"apples\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"oranges\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> oranges <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"oranges\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> emptySet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// union</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// Set(4) {'apples', 'bananas', 'pears', 'oranges'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">union</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Set(3) {'apples', 'bananas', 'oranges'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">union</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// intersection</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// Set(2) {'apples', 'bananas'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">intersection</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Set(0) {}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">intersection</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Set(1) {'apples'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">intersection</span><span class=\"token punctuation\">(</span>applesAndOranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// difference</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// Set(3) {'apples', 'bananas', 'pears'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">difference</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Set(2) {'pears', 'oranges'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">difference</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Set(1) {'bananas'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">difference</span><span class=\"token punctuation\">(</span>applesAndOranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// symmetricDifference</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// Set(2) {'bananas', 'oranges'}</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">symmetricDifference</span><span class=\"token punctuation\">(</span>applesAndOranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// no apples</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// isDisjointFrom</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isDisjointFrom</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isDisjointFrom</span><span class=\"token punctuation\">(</span>applesAndOranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">isDisjointFrom</span><span class=\"token punctuation\">(</span>emptySet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>emptySet<span class=\"token punctuation\">.</span><span class=\"token function\">isDisjointFrom</span><span class=\"token punctuation\">(</span>emptySet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// isSubsetOf</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isSubsetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">isSubsetOf</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isSubsetOf</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">isSubsetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>emptySet<span class=\"token punctuation\">.</span><span class=\"token function\">isSubsetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">////</span>\r\n<span class=\"token comment\">// isSupersetOf</span>\r\n<span class=\"token comment\">////</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">isSupersetOf</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isSupersetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>applesAndBananas<span class=\"token punctuation\">.</span><span class=\"token function\">isSupersetOf</span><span class=\"token punctuation\">(</span>oranges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">.</span><span class=\"token function\">isSupersetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>emptySet<span class=\"token punctuation\">.</span><span class=\"token function\">isSupersetOf</span><span class=\"token punctuation\">(</span>fruits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"격리된-선언\">격리된 선언</h2>\n<p>선언 파일(<code class=\"language-text\">.d.ts</code> 파일)은 기존 라이브러리와 모듈의 구조를 TypeScript에 설명한다. 이 파일들은 라이브러리의 타입 시그니처를 포함하지만 함수 본문과 같은 구현 세부 사항은 제외된다. 선언 파일을 직접 작성할 수 있지만, TypeScript가 <code class=\"language-text\">--declaration</code> 옵션을 사용하여 소스 파일에서 자동으로 생성하게 하는 것이 더 안전하고 간단하다.</p>\n<p>TypeScript 컴파일러와 API는 항상 선언 파일을 생성하는 역할을 해왔지만, 다른 도구를 사용하거나 기존 빌드 프로세스가 확장되지 않는 경우도 있다.</p>\n<h3 id=\"유즈-케이스-더-빠른-선언-파일-생성-도구\">유즈 케이스: 더 빠른 선언 파일 생성 도구</h3>\n<p>더 빠른 선언 파일 생성 도구를 만들고 싶다면, 특히 출판 서비스나 새로운 번들러의 일부로서 고려할 수 있다. TypeScript를 JavaScript로 변환하는 빠른 도구들은 많지만, TypeScript를 선언 파일로 변환하는 도구는 그렇지 않다. 그 이유는 TypeScript의 추론 기능을 사용하면 명시적으로 타입을 선언하지 않고도 코드를 작성할 수 있게 하기 때문이다.</p>\n<p>예를 들어, 두 개의 가져온 변수를 더하는 간단한 함수를 고려해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// util.ts</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> one <span class=\"token operator\">=</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> two <span class=\"token operator\">=</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// add.ts</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> one<span class=\"token punctuation\">,</span> two <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./util\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> one <span class=\"token operator\">+</span> two<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리가 단지 <code class=\"language-text\">add.d.ts</code> 파일을 생성하려고 하더라도, TypeScript는 다른 가져온 파일(<code class=\"language-text\">util.ts</code>)로 들어가서 <code class=\"language-text\">one</code>과 <code class=\"language-text\">two</code>의 타입이 문자열임을 추론하고, 두 문자열에 대한 <code class=\"language-text\">+</code> 연산자가 <code class=\"language-text\">string</code> 반환 타입을 가진다는 것을 계산해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// add.d.ts</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이러한 추론은 개발자 경험에 중요하지만, 선언 파일을 생성하려는 도구는 타입 체커의 일부를 복제하고, 추론 및 모듈 지정자를 해결하여 import를 따라가야 한다.</p>\n<h3 id=\"유즈-케이스-병렬-선언-파일-생성-및-병렬-검사\">유즈 케이스: 병렬 선언 파일 생성 및 병렬 검사</h3>\n<p>여러 프로젝트가 있는 모노레포와 다중 코어 CPU가 있다면, 각 프로젝트를 다른 코어에서 동시에 검사할 수 있다면 좋을 것이다. 하지만 의존성 순서대로 프로젝트를 빌드해야 한다. 예를 들어, <code class=\"language-text\">backend와</code> <code class=\"language-text\">frontend</code>가 <code class=\"language-text\">core</code>에 의존할 경우, <code class=\"language-text\">core</code>가 빌드되어 선언 파일이 생성될 때까지 <code class=\"language-text\">frontend</code>나 <code class=\"language-text\">backend</code>를 검사할 수 없다.</p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/5f072d29-187b-4d16-b5c0-4f094cad1599\" alt=\"image\"></p>\n<p>위 그래프에서 병목 현상이 발생하는 것을 볼 수 있다. <code class=\"language-text\">frontend</code>와 <code class=\"language-text\">backend</code>를 병렬로 빌드할 수 있지만, 먼저 <code class=\"language-text\">core</code>가 빌드 완료될 때까지 기다려야 한다.</p>\n<p>이 문제를 개선하려면 어떻게 해야 할까? 빠른 도구가 <code class=\"language-text\">core</code>의 선언 파일을 병렬로 생성할 수 있다면, TypeScript는 이를 통해 <code class=\"language-text\">core</code>, <code class=\"language-text\">frontend</code>, <code class=\"language-text\">backend</code>를 병렬로 타입 검사할 수 있다.</p>\n<h3 id=\"해결책-명시적-타입\">해결책: 명시적 타입!</h3>\n<p>두 가지 사용 사례의 공통 요구 사항은 선언 파일을 생성하기 위한 파일 간 타입 검사기가 필요하다는 것이다. 도구 커뮤니티에게 많은 것을 요구하는 셈이다.</p>\n<p>복잡한 예로, 다음 코드를 위한 선언 파일이 필요하다면...</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./add\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n</code></pre></div>\n<p><code class=\"language-text\">foo</code>의 시그니처를 생성해야 한다. 이를 위해 <code class=\"language-text\">foo</code>의 구현을 봐야 하고, <code class=\"language-text\">foo</code>는 <code class=\"language-text\">x</code>를 반환하므로 <code class=\"language-text\">x</code>의 타입을 얻기 위해 <code class=\"language-text\">add</code>의 구현을 살펴봐야 한다. 이는 <code class=\"language-text\">add</code>의 의존성까지 살펴봐야 할 수 있다. 이는 선언 파일을 생성하려면 다양한 위치의 타입을 알아내기 위한 많은 논리가 필요하다는 것을 의미한다.</p>\n<p>그러나 빠른 반복 시간과 완전한 병렬 빌드를 원하는 개발자들에게는 다른 접근 방식이 있다. 선언 파일은 모듈의 공개 API 타입만 필요하다. 개발자가 내보내는 항목의 타입을 명시적으로 작성하면, 도구는 모듈의 구현을 보지 않고 선언 파일을 생성할 수 있다. 이는 전체 타입 검사기를 재구현하지 않아도 된다.</p>\n<p>이때 새로운 <code class=\"language-text\">--isolatedDeclarations</code> 옵션이 필요하다. 이 옵션은 타입 검사기 없이 모듈을 신뢰할 수 있게 변환할 수 없을 때 오류를 보고한다. 즉, 내보내는 항목이 충분히 주석 처리되지 않은 파일이 있는 경우 TypeScript가 오류를 보고한다.</p>\n<p>위 예제에서는 다음과 같은 오류가 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">//              ~~~</span>\r\n<span class=\"token comment\">// error! Function must have an explicit</span>\r\n<span class=\"token comment\">// return type annotation with --isolatedDeclarations.</span>\r\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n</code></pre></div>\n<h3 id=\"왜-오류가-바람직한가요\">왜 오류가 바람직한가요?</h3>\n<p>오류는 TypeScript가 다음을 가능하게 하기 때문이다</p>\n<ol>\n<li>다른 도구가 선언 파일을 생성하는 데 문제가 있는지 미리 알려준다.</li>\n<li>누락된 주석을 추가하는 데 도움을 주는 빠른 수정을 제공한다.</li>\n</ol>\n<p>이 모드는 모든 곳에 주석을 요구하지 않는다. 공개 API에 영향을 미치지 않는 로컬 변수에 대해서는 주석이 없어도 된다. 예를 들어, 다음 코드는 오류를 발생시키지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./add\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// no error on 'x', it's not exported.</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>계산하기에 '사소한' 유형인 특정 표현식도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// No error on 'x'.</span>\r\n<span class=\"token comment\">// It's trivial to calculate the type is 'number'</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// No error on 'y'.</span>\r\n<span class=\"token comment\">// We can get the type from the return expression.</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// No error on 'z'.</span>\r\n<span class=\"token comment\">// The type assertion makes it clear what the type is.</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">z</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"격리된-선언-사용\">격리된 선언 사용</h3>\n<p><code class=\"language-text\">isolatedDeclarations</code>는 <code class=\"language-text\">declaration</code> 또는 <code class=\"language-text\">composite</code> 플래그가 설정되어 있어야 한다.</p>\n<p><code class=\"language-text\">isolatedDeclarations</code>는 TypeScript의 emit 방식을 변경하지 않고, 오류 보고 방식만 변경한다. 이 기능은 아직 초기 단계에 있으며, 클래스와 객체 리터럴의 계산된 속성 선언과 같은 일부 시나리오는 지원되지 않는다.</p>\n<p>이 기능을 도입할 때는 각 경우를 신중하게 고려해야 한다. 일부 개발자 경험이 손실될 수 있지만, 병렬 빌드 전략의 최적화 기회를 제공한다.</p>\n<h2 id=\"configdir-템플릿-변수-for-설정-파일\"><code class=\"language-text\">${configDir}</code> 템플릿 변수 for 설정 파일</h2>\n<p>많은 코드베이스에서 다른 구성 파일의 \"베이스\" 역할을 하는 공유 <code class=\"language-text\">tsconfig.json</code> 파일을 재사용하는 것이 일반적이다. 이 작업은 <code class=\"language-text\">tsconfig.json</code> 파일의 <code class=\"language-text\">extends</code> 필드를 사용하여 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../../tsconfig.base.json\"</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 문제 중 하나는 <code class=\"language-text\">tsconfig.json</code> 파일의 모든 경로가 파일 자체의 위치에 상대적이라는 것이다. 즉, 여러 프로젝트에서 사용하는 공유 <code class=\"language-text\">tsconfig.base.json</code> 파일이 있는 경우 파생된 프로젝트에서 상대 경로가 유용하지 않은 경우가 많다. 예를 들어 다음 <code class=\"language-text\">tsconfig.base.json</code>을 상상해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"typeRoots\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n            <span class=\"token string\">\"./node_modules/@types\"</span>\r\n            <span class=\"token string\">\"./custom-types\"</span>\r\n        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dist\"</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 작성자가 모든 <code class=\"language-text\">tsconfig.json</code> 파일이 이 파일을 확장하여 다음과 같은 설정을 의도했다면</p>\n<ol>\n<li>파생된 <code class=\"language-text\">tsconfig.json</code>에 상대적인 <code class=\"language-text\">dist</code> 디렉토리에 출력.</li>\n<li>파생된 <code class=\"language-text\">tsconfig.json</code>에 상대적인 <code class=\"language-text\">custom-types</code> 디렉토리 사용.</li>\n</ol>\n<p>위의 방법은 작동하지 않을 것이다. <code class=\"language-text\">typeRoots</code> 경로는 공유된 <code class=\"language-text\">tsconfig.base.json</code> 파일의 위치를 기준으로 하기 때문에, 각 프로젝트는 동일한 <code class=\"language-text\">outDir</code>과 <code class=\"language-text\">typeRoots</code>를 선언해야 한다.</p>\n<p>이를 해결하기 위해 TypeScript 5.5는 새로운 템플릿 변수 <code class=\"language-text\">${configDir}</code>을 도입했다. <code class=\"language-text\">tsconfig.json</code> 또는 <code class=\"language-text\">jsconfig.json</code> 파일의 특정 경로 필드에 <code class=\"language-text\">${configDir}</code>을 작성하면 이 변수는 지정된 컴파일에서 구성 파일의 포함 디렉터리로 대체된다. 즉, 위의 <code class=\"language-text\">tsconfig.base.json</code>을 다음과 같이 다시 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"typeRoots\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n            <span class=\"token string\">\"${configDir}/node_modules/@types\"</span>\r\n            <span class=\"token string\">\"${configDir}/custom-types\"</span>\r\n        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${configDir}/dist\"</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 프로젝트에서 이 파일을 확장할 때 경로는 공유된 <code class=\"language-text\">tsconfig.base.json</code> 파일이 아니라 파생된 <code class=\"language-text\">tsconfig.json</code>에 상대적인 경로가 된다. 이렇게 하면 프로젝트 간에 구성 파일을 공유하기가 더 쉬워지고 구성 파일의 이식성이 향상된다.</p>\n<p><code class=\"language-text\">tsconfig.json</code> 파일을 확장할 수 있게 만들려면 <code class=\"language-text\">./</code> 대신 <code class=\"language-text\">${configDir}</code>로 작성해야 하는지 고려하자.</p>","frontmatter":{"date":"24.06.21","description":"TypeScript 5.5 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42mOwD9z6n5qYga4GOgRBsGPwNggO2gbmk22gjd+W/9a+m/9b+Wz6bwWmN/+38d1CnoG2/lv+R2cd+B+fd/B/WsmR/ynFh/+nAumY7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg/+j825wDY5bi8TtDLlkBvmntt+m/hDcEgr1MUy7BIgUUQRZEyKNIhABp8yGCqIO1VAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["Typescript","번역"],"title":"TypeScript 5.5 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%B6%94%EB%A1%A0%EB%90%9C-%ED%83%80%EC%9E%85-%EC%84%9C%EC%88%A0\">추론된 타입 서술</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%83%81%EC%88%98-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A0%91%EA%B7%BC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84-%EC%A2%81%ED%9E%88%EA%B8%B0\">상수 인덱스 접근에 대한 제어 흐름 좁히기</a></p>\n</li>\n<li>\n<p><a href=\"#jsdoc-import-%ED%83%9C%EA%B7%B8\">JSDoc <code class=\"language-text\">@import</code> 태그</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D-%EA%B5%AC%EB%AC%B8-%EA%B2%80%EC%82%AC\">정규 표현식 구문 검사</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-ecmascript-set-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A7%80%EC%9B%90\">새로운 ECMAScript Set 메서드 지원</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%A9%EB%A6%AC%EB%90%9C-%EC%84%A0%EC%96%B8\">격리된 선언</a></p>\n<ul>\n<li><a href=\"#%EC%9C%A0%EC%A6%88-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EB%8D%94-%EB%B9%A0%EB%A5%B8-%EC%84%A0%EC%96%B8-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%8F%84%EA%B5%AC\">유즈 케이스: 더 빠른 선언 파일 생성 도구</a></li>\n<li><a href=\"#%EC%9C%A0%EC%A6%88-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EB%B3%91%EB%A0%AC-%EC%84%A0%EC%96%B8-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EB%B3%91%EB%A0%AC-%EA%B2%80%EC%82%AC\">유즈 케이스: 병렬 선언 파일 생성 및 병렬 검사</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85-%EB%AA%85%EC%8B%9C%EC%A0%81-%ED%83%80%EC%9E%85\">해결책: 명시적 타입!</a></li>\n<li><a href=\"#%EC%99%9C-%EC%98%A4%EB%A5%98%EA%B0%80-%EB%B0%94%EB%9E%8C%EC%A7%81%ED%95%9C%EA%B0%80%EC%9A%94\">왜 오류가 바람직한가요?</a></li>\n<li><a href=\"#%EA%B2%A9%EB%A6%AC%EB%90%9C-%EC%84%A0%EC%96%B8-%EC%82%AC%EC%9A%A9\">격리된 선언 사용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#configdir-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%B3%80%EC%88%98-for-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC\"><code class=\"language-text\">${configDir}</code> 템플릿 변수 for 설정 파일</a></p>\n</li>\n</ul>"}},"pageContext":{"id":"1eaa2fab-9b40-51af-b373-ec37e3fd05f1","frontmatter__slug":"/translate-ts-5-5","previous":"/translate-ts-5-6","previousTitle":"TypeScript 5.6 번역","next":"/translate-ts-5-4","nextTitle":"TypeScript 5.4 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}