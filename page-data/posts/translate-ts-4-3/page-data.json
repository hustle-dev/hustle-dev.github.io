{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-4-3/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html</a></p>\n</blockquote>\n<h2 id=\"프로퍼티의-쓰기-타입-분리\">프로퍼티의 쓰기 타입 분리</h2>\n<p>JS에서 API는 값을 저장하기 전에 값을 변환하는 것이 일반적이다. 이는 getter와 setter에서도 자주 발생한다. 예를 들어, 항상 값을 숫자로 변환한 후에 비공개 필드에 저장하는 setter를 갖는 클래스가 있다고 상상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  #size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Don't allow NaN and stuff.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isFinite</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 JS 코드를 TS로 어떻게 입력할까? 기술적으로는 여기서 특별한 조치를 취할 필요가 없다. TS는 명시적인 타입이 없어도 이를 살펴보고 <code class=\"language-text\">size</code>가 숫자임을 알아낼 수 있다.</p>\n<p>문제는 <code class=\"language-text\">size</code>가 숫자뿐만 아니라 다른 타입의 값을 할당할 수 있다는 점이다. 따라서 우리는 이 스니펫에서와 같이 <code class=\"language-text\">size</code>가 <code class=\"language-text\">unknown</code> 또는 <code class=\"language-text\">any</code>와 같은 타입을 갖는다고 명시하여 이 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 이 방법은 좋은 방법은 아니다. <code class=\"language-text\">unknown</code>은 <code class=\"language-text\">size</code>를 읽는 사람들이 타입 단언을 해야 한다는 불편함을 가져오며, <code class=\"language-text\">any</code>는 어떤 오류도 잡아내지 못한다. 값을 변환하는 API를 모델링하려면 이전 버전의 TypeScript에서는 정확성(값 읽기는 더 쉽고 쓰기는 더 어렵게)과 관대함(값 쓰기는 더 쉽고 읽기는 더 어렵게) 중 하나를 선택해야 했다.</p>\n<p>그래서 TypeScript 4.3에서는 속성에 대한 읽기 및 쓰기 타입을 지정할 수 있도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  #size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">set</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Don't allow NaN and stuff.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isFinite</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#size <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 예제에서, <code class=\"language-text\">set</code> 접근자는 더 넓은 타입 집합 (문자열, 불리언 및 숫자)을 사용하지만 <code class=\"language-text\">get</code> 접근자는 항상 숫자임을 보장한다. 이제 우리는 다른 타입의 값을 오류없이 이러한 속성에 할당할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> thing <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Assigning other types to `thing.size` works!</span>\nthing<span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\nthing<span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\nthing<span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Reading `thing.size` always produces a number!</span>\n<span class=\"token keyword\">let</span> mySize<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> thing<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">;</span></code></pre></div>\n<p>동일한 이름을 갖는 두 속성이 어떻게 관련되는지 고려할 때, TypeScript는 \"읽기\" 타입 (위의 get 접근자의 타입)만 사용한다. \"쓰기\" 타입은 직접 속성에 쓸 때만 고려된다.</p>\n<p>이는 클래스에만 제한된 패턴이 아니다. 객체 리터럴에서도 다른 타입의 getter와 setter를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Thing <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// Don't allow NaN and stuff.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isFinite</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      size <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>사실, 인터페이스/객체 타입에는 속성에 대한 다양한 읽기/쓰기 타입을 지원하기 위한 문법이 추가되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Now valid!</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>속성의 읽기와 쓰기에 대해 사로 다른 타입을 사용하는 것의 제한 사항 중 하나는 속성을 읽는 데 사용되는 타입이 쓰는 타입에 할당 가능해야 한다는 것이다. 다시 말해, getter 타입은 setter에 할당 가능해야 한다. 이렇게 함으로써 일관성 수준이 보장되어 속성이 항상 자신에게 할당 가능하도록 유지된다.</p>\n<h2 id=\"override-and-the---noimplicitoverride-flag\"><code class=\"language-text\">override</code> and the <code class=\"language-text\">--noImplicitOverride</code> Flag</h2>\n<p>JavaScript에서 클래스를 확장할 때, 언어 자체에서 메서드를 오버라이드하기가 매우 쉽지만, 불행하게도 발생할 수 있는 몇 가지 오류가 있다.</p>\n<p>가장 큰 문제 중 하나는 이름 변경을 빼먹는 것이다. 예를 들어, 다음 클래스를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">hide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SpecializedComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">hide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">SpecializedComponent</code>는 <code class=\"language-text\">SomeComponent</code>를 상속하며 <code class=\"language-text\">show</code> 및 <code class=\"language-text\">hide</code> 메서드를 오버라이드한다. 그러나 누군가 <code class=\"language-text\">show</code>와 <code class=\"language-text\">hide</code>를 제거하고 단일 메서드로 대체하면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n<span class=\"token operator\">-</span>    <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token operator\">-</span>        <span class=\"token comment\">// ...</span>\n<span class=\"token operator\">-</span>    <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span>    <span class=\"token function\">hide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token operator\">-</span>        <span class=\"token comment\">// ...</span>\n<span class=\"token operator\">-</span>    <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">+</span>    <span class=\"token function\">setVisible</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token operator\">+</span>        <span class=\"token comment\">// ...</span>\n<span class=\"token operator\">+</span>    <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpecializedComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\">// ...</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token function\">hide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\">// ...</span>\n     <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런! <code class=\"language-text\">SpecializedComponent</code>가 업데이트되지 않았다. 이제 이것은 호출되지 않을 불필요한 <code class=\"language-text\">show</code> 및 <code class=\"language-text\">hide</code> 메서드를 추가하고 있다.</p>\n<p>이 문제의 일부는 사용자가 새로운 메서드를 추가할 것인지 기존 메서드를 오버라이드할 것인지 명확하게 할 수 없다는 것이다. 이것이 TypeScript 4.3에서 <code class=\"language-text\">override</code> 키워드가 추가된 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SpecializedComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n  override <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  override <span class=\"token function\">hide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">override</code>가 지정된 메서드는 TypeScript가 항상 기본 클래스에 동일한 이름의 메서드가 존재하는지 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setVisible</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SpecializedComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n    override <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\nThis member cannot have an <span class=\"token string\">'override'</span> modifier because it <span class=\"token keyword\">is</span> not declared <span class=\"token keyword\">in</span> the base <span class=\"token keyword\">class</span> <span class=\"token string\">'SomeComponent'</span><span class=\"token punctuation\">.</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것은 큰 개선이지만, 메서드에 <code class=\"language-text\">override</code>를 작성하는 것을 잊어버리면 도움이 되지 않는다. 이것도 사용자가 발생할 수 있는 큰 실수이다.</p>\n<p>예를 들어, 기본 클래스에 있는 메서드가 존재하는데도 불구하고 그것을 모르고 덮어쓸 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">someHelperMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Oops! We weren't trying to override here,</span>\n  <span class=\"token comment\">// we just needed to write a local helper method.</span>\n  <span class=\"token function\">someHelperMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그래서 TypeScript 4.3에서는 <code class=\"language-text\">noImplicitOverride</code> 플래그도 제공한다. 이 옵션을 켜면 <code class=\"language-text\">override</code> 키워드를 명시적으로 사용하지 않는 한 수퍼클래스의 메서드를 오버라이드하는 것이 오류가 된다. 마지막 예제에서 TypeScript는 <code class=\"language-text\">noImplicitOverride</code> 하에서 오류가 되며, <code class=\"language-text\">Derived</code> 내부의 메서드 이름을 변경해야 할 필요가 있다는 단서를 제공한다.</p>\n<h2 id=\"템플릿-문자열-타입-개선사항\">템플릿 문자열 타입 개선사항</h2>\n<p>TypeScript의 최근 버전에서 새로운 타입 구조인 \"템플릿 문자열 타입(template string types)\"이 추가되었다. 이 타입은 문자열과 유사한 타입을 연결(concatenate)해서 새로운 타입을 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Color</span> <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Quantity</span> <span class=\"token operator\">=</span> <span class=\"token string\">'one'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">SeussFish</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>Quantity <span class=\"token operator\">|</span> Color<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> fish</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// same as</span>\n<span class=\"token comment\">//   type SeussFish = \"one fish\" | \"two fish\"</span>\n<span class=\"token comment\">//                  | \"red fish\" | \"blue fish\";</span></code></pre></div>\n<p>그리고 이 타입은 다른 문자열 유사 타입의 패턴(match patterns)을 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s1<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s2<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">1-2-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Works!</span>\ns1 <span class=\"token operator\">=</span> s2<span class=\"token punctuation\">;</span></code></pre></div>\n<p>첫 번째 변경 사항은 TypeScript가 템플릿 문자열 타입을 추론하는 시기이다. TypeScript가 우리가 리터럴 타입을 사용해야 하는 것을 인식할 때 (즉, 우리가 리터럴 타입을 사용해야 하는 것을 받아들일 때) 템플릿 문자열이 문맥적으로 문자열 리터럴 타입으로 타입화될 때, TypeScript는 그 식에 대해 템플릿 타입을 할당하려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">string</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Previously an error, now works!</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>s<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 또한 타입 추론시에도 적용된다. 그리고 타입 파라미터가 string을 확장(extends)하는 경우에도 적용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Previously: string</span>\n<span class=\"token comment\">// Now       : `hello ${string}`</span>\n<span class=\"token keyword\">let</span> x2 <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>s<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>두 번째 주요 변경 사항은 TypeScript가 이제 서로 다른 템플릿 문자열 타입 간의 관계를 더 잘 파악하고 추론할 수 있다는 것이다.</p>\n<p>이를 확인하기 위해 다음 예제 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s1<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s2<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">1-2-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s3<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-2-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s2<span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s3<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">s2</code>와 같은 문자열 리터럴 타입을 검사할 때, TypeScript는 문자열 내용을 매치하여 <code class=\"language-text\">s2</code>가 첫 번째 할당에서 <code class=\"language-text\">s1</code>과 호환됨을 알아낼 수 있었지만, 다른 템플릿 문자열을 보자마자 포기해 버렸다. 결과적으로 <code class=\"language-text\">s3</code>를 <code class=\"language-text\">s1</code>에 할당하는 것과 같은 할당은 작동하지 않았다.</p>\n<p>이제 TypeScript는 각 템플릿 문자열의 각 부분이 성공적으로 일치하는지 여부를 증명하기 위해 작업을 수행한다. 이제 서로 다른 치환과 함께 템플릿 문자열을 혼합하여 사용할 수 있으며, TypeScript가 실제로 호환되는지 여부를 잘 알아낼 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s1<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s2<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">1-2-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s3<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-2-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s4<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">1-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-3</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s5<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">1-2-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> s6<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-2-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">number</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Now *all of these* work!</span>\ns1 <span class=\"token operator\">=</span> s2<span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s3<span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s4<span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s5<span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s6<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 작업을 수행함에 따라, 우리는 더 나은 추론 능력도 추가했다. 이러한 기능이 어떻게 작동하는지 예제를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">foo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arg<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">*</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token constant\">V</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">*</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">test</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span> t<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x1 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*hello*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"hello\"</span>\n  <span class=\"token keyword\">let</span> x2 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token string\">'**hello**'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"*hello*\"</span>\n  <span class=\"token keyword\">let</span> x3 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">*</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>s<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">*</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n  <span class=\"token keyword\">let</span> x4 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">*</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">*</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `${number}`</span>\n  <span class=\"token keyword\">let</span> x5 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">*</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>b<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">*</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"true\" | \"false\"</span>\n  <span class=\"token keyword\">let</span> x6 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">*</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>t<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">*</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `${T}`</span>\n  <span class=\"token keyword\">let</span> x7 <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">**</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>s<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">**</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `*${string}*`</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"ecmascript-private-클래스-멤버\">ECMAScript <code class=\"language-text\">#private</code> 클래스 멤버</h2>\n<p>TypeScript 4.3에서는 클래스의 어떤 멤버가 <code class=\"language-text\">#private</code> <code class=\"language-text\">#names</code>으로 지정될 수 있는지가 확장되어 런타임에서 진정한 비공개로 만들 수 있다. 이제 속성(property)뿐만 아니라 메서드(method)와 접근자(accessor)도 비공개 이름을 가질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">#someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">#someValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">publicMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// These work.</span>\n    <span class=\"token comment\">// We can access private-named members inside this class.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">#someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#someValue<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">#someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//        ~~~~~~~~~~~</span>\n<span class=\"token comment\">// error!</span>\n<span class=\"token comment\">// Property '#someMethod' is not accessible</span>\n<span class=\"token comment\">// outside class 'Foo' because it has a private identifier.</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>#someValue<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//        ~~~~~~~~~~</span>\n<span class=\"token comment\">// error!</span>\n<span class=\"token comment\">// Property '#someValue' is not accessible</span>\n<span class=\"token comment\">// outside class 'Foo' because it has a private identifier.</span></code></pre></div>\n<p>더 넓게는, 이제 정적 멤버(static members)도 비공개 이름을 가질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">#someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nFoo<span class=\"token punctuation\">.</span><span class=\"token function\">#someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//  ~~~~~~~~~~~</span>\n<span class=\"token comment\">// error!</span>\n<span class=\"token comment\">// Property '#someMethod' is not accessible</span>\n<span class=\"token comment\">// outside class 'Foo' because it has a private identifier.</span></code></pre></div>\n<h2 id=\"constructorparameters가-추상-클래스에서도-동작\"><code class=\"language-text\">ConstructorParameters</code>가 추상 클래스에서도 동작</h2>\n<p>TypeScript 4.3에서 <code class=\"language-text\">ConstructorParameters</code> 타입 헬퍼는 이제 추상 클래스에서도 작동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Has the type '[a: string, b: number]'.</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">CParams</span> <span class=\"token operator\">=</span> ConstructorParameters<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이것은 TypeScript 4.2에서 수행된 작업 덕분이다. 해당 작업에서 구성 시그니처(construct signatures)를 추상으로 표시할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">MyConstructorOf<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// or using the shorthand syntax:</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">MyConstructorOf<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"제네릭에-대한-문맥적-좁힘contextual-narrowing\">제네릭에 대한 문맥적 좁힘(Contextual Narrowing)</h2>\n<p>TypeScript 4.3에는 이제 제네릭 값에 대한 약간 더 똑똑한 타입 좁힘 로직이 포함된다. 이를 통해 TypeScript는 더 많은 패턴을 허용하고 때로는 실수를 잡을 수도 있다.</p>\n<p>이해를 돕기 위해 <code class=\"language-text\">Set</code> 또는 <code class=\"language-text\">Array</code> 의 원소를 받아서 중복을 제거하는 비교 함수에 따라 해당 <code class=\"language-text\">Array</code>를 정렬하는 함수인 <code class=\"language-text\">makeUnique</code>를 작성하려고 한다고 가정해 보자. 그 후에는 원래의 컬렉션을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeUnique</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>collection<span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">comparer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Early bail-out if we have a Set.</span>\n  <span class=\"token comment\">// We assume the elements are already unique.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>collection <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Sort the array, then remove consecutive duplicates.</span>\n  collection<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>comparer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> collection<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;</span> collection<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">comparer</span><span class=\"token punctuation\">(</span>collection<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> collection<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    collection<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수의 구현과 관련된 질문들은 일단 뒤로 두고, 이 함수가 더 넓은 응용프로그램의 요구사항에서 유래되었다고 가정해보자. 여기서 주목할 점 중 하나는 해당 시그니처가 원래 컬렉션의 타입을 포착하지 않는다는 것이다. <code class=\"language-set<t\"> | T[]</code>가 쓰인 자리에 <code class=\"language-text\">C</code>라는 타입 파라미터를 추가하여 이를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token operator\">-</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeUnique</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>collection<span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">comparer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">+</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeUnique</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span> <span class=\"token keyword\">extends</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>collection<span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">comparer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">C</span></code></pre></div>\n<p>TypeScript 4.2 이전 버전에서는 이렇게 하면 곧바로 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeUnique</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span> <span class=\"token keyword\">extends</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  collection<span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">comparer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">C</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Early bail-out if we have a Set.</span>\n  <span class=\"token comment\">// We assume the elements are already unique.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>collection <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Sort the array, then remove consecutive duplicates.</span>\n  collection<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>comparer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//         ~~~~</span>\n  <span class=\"token comment\">// error: Property 'sort' does not exist on type 'C'.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> collection<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//                             ~~~~~~</span>\n    <span class=\"token comment\">// error: Property 'length' does not exist on type 'C'.</span>\n    <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>\n      j <span class=\"token operator\">&lt;</span> collection<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token function\">comparer</span><span class=\"token punctuation\">(</span>collection<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> collection<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//                    ~~~~~~</span>\n      <span class=\"token comment\">// error: Property 'length' does not exist on type 'C'.</span>\n      <span class=\"token comment\">//                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~</span>\n      <span class=\"token comment\">// error: Element implicitly has an 'any' type because expression of type 'number'</span>\n      <span class=\"token comment\">//        can't be used to index type 'Set&lt;T> | T[]'.</span>\n      j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    collection<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//         ~~~~~~</span>\n    <span class=\"token comment\">// error: Property 'splice' does not exist on type 'C'.</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span></code></pre></div>\n<p>오류가 발생하는 이유는, 우리가 <code class=\"language-text\">컬렉션의 instanceof Set</code>을 체크할 때, 우리는 이를 타입 가드(Type Guard)로 작동하여 <code class=\"language-set<t\"> | T[]</code> 타입을 해당 브랜치에 따라 <code class=\"language-text\">Set&lt;T></code> 또는 <code class=\"language-text\">T[]</code>로 좁히기를 기대하기 때문이다. 그러나 <code class=\"language-set<t\"> | T[]</code>가 아니라 <code class=\"language-text\">C</code>라는 제네릭 값을 좁히려고 하는 것이다.</p>\n<p>이것은 매우 미묘한 차이이지만, 차이가 있다. TypeScript는 <code class=\"language-text\">C</code>의 제약 조건(<code class=\"language-set<t\"> | T[]</code>)을 가져와서 좁히는 것이 아니다. TypeScript가 <code class=\"language-set<t\"> | T[]</code>에서 좁히려고 한다면, TypeScript는 해당 정보를 보존할 수 있는 쉬운 방법이 없기 때문에 각 브랜치에서 컬렉션도 C라는 사실을 잊어버릴 것이다. 가상으로 TypeScript가 이러한 접근 방식을 시도한다면 위의 예제는 다른 방식으로 중단될 것이다. 함수가 <code class=\"language-text\">C</code> 타입의 값을 반환하는 위치에서, TypeScript는 각 브랜치에서 <code class=\"language-text\">Set&lt;T></code>와 <code class=\"language-text\">T[]</code>를 얻을 것이며, TypeScript는 이를 거부할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeUnique</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>collection<span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">comparer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Set<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Early bail-out if we have a Set.</span>\n  <span class=\"token comment\">// We assume the elements are already unique.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>collection <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//     ~~~~~~~~~~</span>\n    <span class=\"token comment\">// error: Type 'Set&lt;T>' is not assignable to type 'C'.</span>\n    <span class=\"token comment\">//          'Set&lt;T>' is assignable to the constraint of type 'C', but</span>\n    <span class=\"token comment\">//          'C' could be instantiated with a different subtype of constraint 'Set&lt;T> | T[]'.</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> collection<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//     ~~~~~~~~~~</span>\n  <span class=\"token comment\">// error: Type 'T[]' is not assignable to type 'C'.</span>\n  <span class=\"token comment\">//          'T[]' is assignable to the constraint of type 'C', but</span>\n  <span class=\"token comment\">//          'C' could be instantiated with a different subtype of constraint 'Set&lt;T> | T[]'.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그렇다면 TypeScript 4.3에서는 어떤 변화가 있을까? 크게 몇 가지 핵심적인 부분에서, 코드 작성 시 타입 시스템이 실제로 관심을 가지는 것은 타입의 제약 조건뿐이다. 예를 들어, <code class=\"language-text\">collection.length</code>를 작성할 때 TypeScript는 <code class=\"language-text\">collection</code>이 <code class=\"language-text\">C</code>라는 사실에 관심이 없으며, 제약 조건 <code class=\"language-text\">T[] | Set&lt;T></code>에 의해 결정된 속성에만 관심이 있다.</p>\n<p>이러한 경우, TypeScript는 제약 조건의 좁힌 타입을 가져온다. 왜냐하면 이것이 실제로 필요한 데이터이기 때문이다. 그러나 다른 경우에는 원래 제네릭 타입을 좁히려고 시도할 것이다(그리고 종종 원래 제네릭 타입으로 끝날 것이다).</p>\n<p>즉, 제네릭 값을 사용하는 방식에 따라 TypeScript가 약간 다르게 좁힐 수 있다. 결과적으로 위의 예제 전체가 타입 체크 오류 없이 컴파일된다.</p>\n<h2 id=\"always-truthy-promise-확인\">Always-Truthy Promise 확인</h2>\n<p><code class=\"language-text\">strictNullChecks</code> 모드에서, 조건부에서 Promise가 \"truthy\"한지 확인하면 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">boolean</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//  ~~~~~</span>\n    <span class=\"token comment\">// Error!</span>\n    <span class=\"token comment\">// This condition will always return true since</span>\n    <span class=\"token comment\">// this 'Promise&lt;boolean>' appears to always be defined.</span>\n    <span class=\"token comment\">// Did you forget to use 'await'?</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'false'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"static-인덱스-시그니처\"><code class=\"language-text\">static</code> 인덱스 시그니처</h2>\n<p>인덱스 시그니처는 타입에서 명시적으로 선언한 속성보다 더 많은 속성을 값에 설정할 수 있게 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  hello <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n  world <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// This is an index signature:</span>\n  <span class=\"token punctuation\">[</span>propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Valid assigment</span>\ninstance<span class=\"token punctuation\">[</span><span class=\"token string\">'whatever'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Has type 'string | number | undefined'.</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">[</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>지금까지 인덱스 시그니처는 클래스의 인스턴스 측면에서만 선언할 수 있었다. 그러나 Wenlu Wang 님의 기여로 인해 인덱스 시그니처를 <code class=\"language-text\">static</code>으로 선언할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> hello <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> world <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token punctuation\">[</span>propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Valid.</span>\nFoo<span class=\"token punctuation\">[</span><span class=\"token string\">'whatever'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Has type 'string | number | undefined'</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">[</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>인스턴스 측에서와 마찬가지로 클래스의 정적 측에 있는 인덱스 시그니처에도 동일한 종류의 규칙이 적용된다. 즉, 다른 모든 정적 속성이 인덱스 서명과 호환되어야 한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> prop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//     ~~~~</span>\n  <span class=\"token comment\">// Error! Property 'prop' of type 'boolean'</span>\n  <span class=\"token comment\">// is not assignable to string index type</span>\n  <span class=\"token comment\">// 'string | number | undefined'.</span>\n  <span class=\"token keyword\">static</span> <span class=\"token punctuation\">[</span>propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"tsbuildinfo-사이즈-개선\"><code class=\"language-text\">.tsbuildinfo</code> 사이즈 개선</h2>\n<p>TypeScript 4.3에서, 증분 빌드의 일부로 생성되는 <code class=\"language-text\">.tsbuildinfo</code> 파일의 크기가 크게 줄어든다. 내부 형식에서 몇 가지 최적화를 수행하여 전체 경로와 유사한 정보를 반복하지 않고 파일 전체에서 사용할 수 있는 숫자 식별자로 테이블을 만들었다.</p>\n<p>우리는 다음과 같은 <code class=\"language-text\">.tsbuildinfo</code> 파일 크기의 큰 감소를 보았다.</p>\n<ul>\n<li>1MB에서 411 KB로</li>\n<li>14.9MB에서 1MB로</li>\n<li>1345MB에서 467MB로</li>\n</ul>\n<p>말할 필요 없이, 이렇게 크기를 줄이면 빌드 시간도 약간 더 빨라진다.</p>\n<h2 id=\"--incremental-와---watch-편집에서-지연-계산\"><code class=\"language-text\">--incremental</code> 와 <code class=\"language-text\">--watch</code> 편집에서 지연 계산</h2>\n<p>증분 및 --watch 모드의 문제 중 하나는 나중에 컴파일하는 속도가 빨라지지만 초기 컴파일 속도가 약간 느려질 수 있으며 경우에 따라서는 상당히 느려질 수 있다는 것이다. 이 모드는 현재 프로젝트에 대한 정보를 계산하고, 때로는 나중에 빌드할 수 있도록 해당 데이터를 <code class=\"language-text\">.tsbuildinfo</code> 파일에 저장하는 등 많은 장부 작업을 수행해야 하기 때문이다.</p>\n<p>그렇기 때문에 TypeScript 4.3에서는 <code class=\"language-text\">.tsbuildinfo</code> 크기 개선 외에도 이러한 플래그가 있는 프로젝트의 첫 번째 빌드를 일반 빌드만큼 빠르게 만드는 증분 및 <code class=\"language-text\">--watch</code> 모드에 대한 몇 가지 변경 사항이 제공된다! 이를 위해 일반적으로 미리 계산해야 하는 많은 정보를 나중에 빌드할 때 온디맨드 방식으로 계산한다. 이렇게 하면 후속 빌드에 약간의 오버헤드가 추가될 수 있지만 TypeScript의 증분 및 --watch 기능은 일반적으로 훨씬 작은 파일 집합에서 작동하며 필요한 정보는 나중에 저장된다. 어떤 의미에서 증분 및 --watch 빌드는 파일을 몇 번 업데이트하면 \"워밍업\"을 거쳐 컴파일 속도가 빨라진다.</p>\n<p>3000개의 파일이 있는 리포지토리에서 초기 빌드 시간이 거의 1/3로 단축되었다!</p>\n<h2 id=\"import-문-완료\">Import 문 완료</h2>\n<p>자바스크립트에서 import 및 export 문에서 사용자가 가장 많이 겪는 문제 중 하나는 순서이다. 특히 import는 다른 구문보다 먼저 작성되어야 한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">from</span> <span class=\"token string\">\"./module.js\"</span> <span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> func <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* 대신에 아래 처럼 작성해야함 */</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> func <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./module.js\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이로 인해 자동 완성 기능이 제대로 작동하지 않아 전체 가져오기 문을 처음부터 작성할 때 약간의 어려움이 있다. 예를 들어 <code class=\"language-text\">import {</code> 와 같은 문장을 작성하기 시작하면 TypeScript는 어떤 모듈에서 가져올 계획인지 알지 못하기 때문에 범위가 지정된 완성을 제공할 수 없다.</p>\n<p>이 문제를 완화하기 위해 자동 가져오기 기능을 활용했다! 자동 가져오기는 특정 모듈에서 완성된 내용을 좁힐 수 없는 문제를 이미 해결한 기능으로, 가능한 모든 내보내기를 제공하고 파일 상단에 가져오기 문을 자동으로 삽입하는 것이 핵심이다.</p>\n<p>따라서 이제 경로가 없는 가져오기 문을 작성하기 시작하면 가능한 가져오기 목록이 제공된다. 완료를 커밋하면 작성하려고 했던 경로를 포함하여 전체 가져오기 명령문이 완성된다.</p>\n<h2 id=\"link-태그를-에디터에서-지원\"><code class=\"language-text\">@link</code> 태그를 에디터에서 지원</h2>\n<p>TypeScript가 이제 <code class=\"language-text\">@link</code> 태그를 이해하고, 해당 태그에서 참조한 선언을 해결할 수 있게 되었다. 즉, <code class=\"language-text\">@link</code> 태그 내에서 이름 위에 마우스를 가져가면 빠른 정보를 얻거나, go-to-definition이나 find-all-references와 같은 명령을 사용할 수 있다.</p>\n<p>예를 들어, 아래 예제의 <code class=\"language-text\">@link bar</code>에서 <code class=\"language-text\">bar</code>에 대한 go-to-definition을 할 수 있고, TypeScript가 지원하는 편집기에서는 <code class=\"language-text\">bar</code>의 함수 선언으로 이동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * To be called 70 to 80 days after {@link plantCarrot}.\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">harvestCarrot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">carrot</span><span class=\"token operator\">:</span> Carrot</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">/**\n * Call early in spring for best results. Added in v2.1.0.\n * @param seed Make sure it's a carrot seed!\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">plantCarrot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">seed</span><span class=\"token operator\">:</span> Seed</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// TODO: some gardening</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"자바스크립트가-아닌-파일-경로에서-정의-바로가기\">자바스크립트가 아닌 파일 경로에서 정의 바로가기</h2>\n<p>이제 많은 로더들은 자바스크립트를 사용하여 애플리케이션에 에셋을 포함시킬 수 있도록 해준다. 일반적으로 <code class=\"language-text\">import \"./styles.css\"</code>와 같이 작성된다.</p>\n<p>지금까지 TypeScript의 편집기 기능은 이 파일을 읽어들이지 못하기 때문에 go-to-definition이 실패했다. 최선의 경우에도 go-to-definition은 <code class=\"language-text\">declare module \"*.css\"</code>와 같은 선언으로 점프할 수 있었다.</p>\n<p>이제 TypeScript의 언어 서비스는 상대 파일 경로에 대한 go-to-definition을 수행할 때 올바른 파일로 점프하려고 시도한다. 자바스크립트 또는 TypeScript 파일이 아닌 경우에도 CSS, SVG, PNG, 폰트 파일, Vue 파일 등의 가져온 파일에 대해서도 시도할 수 있다.</p>\n<h2 id=\"주요-변경사항\">주요 변경사항</h2>\n<h3 id=\"libdts-변화\"><code class=\"language-text\">lib.d.ts</code> 변화</h3>\n<p>모든 TypeScript 버전과 마찬가지로, <code class=\"language-text\">lib.d.ts</code>에 대한 선언(특히 웹 컨텍스트에 대한 생성된 선언)이 변경되었다. 이번 릴리스에서는 Mozilla의 browser-compat-data를 활용하여 브라우저에서 구현되지 않은 API를 제거했다. 대부분의 경우에는 사용하지 않겠지만, <code class=\"language-text\">Account, AssertionOptions, RTCStatsEventInit, MSGestureEvent, DeviceLightEvent, MSPointerEvent, ServiceWorkerMessageEvent 및 WebAuthentication</code>과 같은 API가 <code class=\"language-text\">lib.d.ts</code>에서 제거되었다.</p>\n<h3 id=\"esnext와-es2022-에서-usedefineforclassfields-기본-값의-참\"><code class=\"language-text\">esnext</code>와 <code class=\"language-text\">es2022</code> 에서 <code class=\"language-text\">useDefineForClassFields</code> 기본 값의 참</h3>\n<p>2021년에는 클래스 필드 기능이 JavaScript 사양에 추가되었으며 TypeScript에서 구현 방법과 다른 동작을 하였다. 이에 대비하여 TypeScript 3.7에서는 useDefineForClassFields 플래그가 추가되어 JavaScript 표준 동작과 일치하도록 마이그레이션되는 것이 가능해졌다.</p>\n<p>이제 이 기능이 JavaScript에 포함되었으므로 ES2022 및 ESNext를 포함한 기본값을 true로 변경한다.</p>\n<h3 id=\"always-truthy-promise-확인에서-에러\">Always-Truthy Promise 확인에서 에러</h3>\n<p><code class=\"language-text\">strictNullChecks</code> 옵션을 사용할 때, 조건 체크 내에서 항상 정의된 것처럼 보이는 <code class=\"language-text\">Promise</code>를 사용하는 것은 이제 오류로 간주된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">var</span> p<span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//  ~</span>\n  <span class=\"token comment\">// Error!</span>\n  <span class=\"token comment\">// This condition will always return true since</span>\n  <span class=\"token comment\">// this 'Promise&lt;number>' appears to always be defined.</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token comment\">// Did you forget to use 'await'?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"union-enums은-임의의-숫자와-비교할-수-없음\">Union Enums은 임의의 숫자와 비교할 수 없음</h3>\n<p>TypeScript 4.3에서는 멤버가 자동으로 채워지거나 간단하게 작성될 때 일부 열거형은 유니온 열거형으로 간주된다. 이 경우, 열거형은 나타낼 수 있는 각 값에 대해 기억할 수 있다.</p>\n<p>유니온 열거형 타입을 가진 값이 그 값과 동일할 수 없는 숫자 리터럴과 비교되면 타입 체커가 오류를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> <span class=\"token constant\">E</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">E</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>해결 방법으로, 적절한 리터럴 타입을 포함하는 주석을 다시 작성할 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> <span class=\"token constant\">E</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Include -1 in the type, if we're really certain that -1 can come through.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">E</span> <span class=\"token operator\">|</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>값에 타입 단언을 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> <span class=\"token constant\">E</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">E</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Use a type asertion on 'x' because we know we're not actually just dealing with values from 'E'.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또는 열거형에 일반적이지 않은 초기화 값을 사용하도록 열거형을 다시 선언하여 모든 숫자를 할당할 수 있고 해당 열거형과 비교할 수 있도록 할 수 있다. 이 방법은 열거형에 잘 알려진 몇 가지 값을 지정하려는 의도가 있는 경우 유용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> <span class=\"token constant\">E</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// the leading + on 0 opts TypeScript out of inferring a union enum.</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token operator\">+</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"23.03.18","description":"TypeScript 4.3 Release를 번역하면서 어떤 기능들이 전에 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAh0lEQVR42mOwD9z6n5qYga4GOgRhx2QbaOO35b+Vz+b/Ft6b/1v6bPpv6b3pv5XvZvIMtPXf8j8q68D/+LyD/1NLjvxPKTr8P7X4yP/o7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg7+j825wDY5bi8TpyXvSDepcjLyBHjGLSNOpEyKNIhAOZkyEi64JPsAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 4.3 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%9D%98-%EC%93%B0%EA%B8%B0-%ED%83%80%EC%9E%85-%EB%B6%84%EB%A6%AC\">프로퍼티의 쓰기 타입 분리</a></p>\n</li>\n<li>\n<p><a href=\"#override-and-the---noimplicitoverride-flag\"><code class=\"language-text\">override</code> and the <code class=\"language-text\">--noImplicitOverride</code> Flag</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%83%80%EC%9E%85-%EA%B0%9C%EC%84%A0%EC%82%AC%ED%95%AD\">템플릿 문자열 타입 개선사항</a></p>\n</li>\n<li>\n<p><a href=\"#ecmascript-private-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%A4%EB%B2%84\">ECMAScript <code class=\"language-text\">#private</code> 클래스 멤버</a></p>\n</li>\n<li>\n<p><a href=\"#constructorparameters%EA%B0%80-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C%EB%8F%84-%EB%8F%99%EC%9E%91\"><code class=\"language-text\">ConstructorParameters</code>가 추상 클래스에서도 동작</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90-%EB%8C%80%ED%95%9C-%EB%AC%B8%EB%A7%A5%EC%A0%81-%EC%A2%81%ED%9E%98contextual-narrowing\">제네릭에 대한 문맥적 좁힘(Contextual Narrowing)</a></p>\n</li>\n<li>\n<p><a href=\"#always-truthy-promise-%ED%99%95%EC%9D%B8\">Always-Truthy Promise 확인</a></p>\n</li>\n<li>\n<p><a href=\"#static-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98\"><code class=\"language-text\">static</code> 인덱스 시그니처</a></p>\n</li>\n<li>\n<p><a href=\"#tsbuildinfo-%EC%82%AC%EC%9D%B4%EC%A6%88-%EA%B0%9C%EC%84%A0\"><code class=\"language-text\">.tsbuildinfo</code> 사이즈 개선</a></p>\n</li>\n<li>\n<p><a href=\"#--incremental-%EC%99%80---watch-%ED%8E%B8%EC%A7%91%EC%97%90%EC%84%9C-%EC%A7%80%EC%97%B0-%EA%B3%84%EC%82%B0\"><code class=\"language-text\">--incremental</code> 와 <code class=\"language-text\">--watch</code> 편집에서 지연 계산</a></p>\n</li>\n<li>\n<p><a href=\"#import-%EB%AC%B8-%EC%99%84%EB%A3%8C\">Import 문 완료</a></p>\n</li>\n<li>\n<p><a href=\"#link-%ED%83%9C%EA%B7%B8%EB%A5%BC-%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90\"><code class=\"language-text\">@link</code> 태그를 에디터에서 지원</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EA%B0%80-%EC%95%84%EB%8B%8C-%ED%8C%8C%EC%9D%BC-%EA%B2%BD%EB%A1%9C%EC%97%90%EC%84%9C-%EC%A0%95%EC%9D%98-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0\">자바스크립트가 아닌 파일 경로에서 정의 바로가기</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9A%94-%EB%B3%80%EA%B2%BD%EC%82%AC%ED%95%AD\">주요 변경사항</a></p>\n<ul>\n<li><a href=\"#libdts-%EB%B3%80%ED%99%94\"><code class=\"language-text\">lib.d.ts</code> 변화</a></li>\n<li><a href=\"#esnext%EC%99%80-es2022-%EC%97%90%EC%84%9C-usedefineforclassfields-%EA%B8%B0%EB%B3%B8-%EA%B0%92%EC%9D%98-%EC%B0%B8\"><code class=\"language-text\">esnext</code>와 <code class=\"language-text\">es2022</code> 에서 <code class=\"language-text\">useDefineForClassFields</code> 기본 값의 참</a></li>\n<li><a href=\"#always-truthy-promise-%ED%99%95%EC%9D%B8%EC%97%90%EC%84%9C-%EC%97%90%EB%9F%AC\">Always-Truthy Promise 확인에서 에러</a></li>\n<li><a href=\"#union-enums%EC%9D%80-%EC%9E%84%EC%9D%98%EC%9D%98-%EC%88%AB%EC%9E%90%EC%99%80-%EB%B9%84%EA%B5%90%ED%95%A0-%EC%88%98-%EC%97%86%EC%9D%8C\">Union Enums은 임의의 숫자와 비교할 수 없음</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"69bd6012-96fa-5237-b76c-daff57f63a53","frontmatter__slug":"/translate-ts-4-3","previous":"/translate-ts-5-0","previousTitle":"TypeScript 5.0 번역","next":"/translate-ts-4-2","nextTitle":"TypeScript 4.2 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}