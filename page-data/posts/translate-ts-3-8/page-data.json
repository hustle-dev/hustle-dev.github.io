{"componentChunkName":"component---src-templates-post-post-tsx","path":"/posts/translate-ts-3-8/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html</a></p>\n</blockquote>\n<h2 id=\"type-only-imports와-export\">Type-Only Imports와 Export</h2>\n<p>이 기능은 대부분의 사용자에겐 생각할 필요가 없는 기능이지만, <a href=\"https://www.typescriptlang.org/tsconfig#isolatedModules\">isolatedModules</a>, TS의 <code class=\"language-text\">transpileModule</code> API 또는 Babel에서 문제가 발생하면 이 기능과 관련이 있을 수 있다.</p>\n<p>TS 3.8은 type-only imports, exports를 위한 새로운 구문이 추가되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> SomeThing <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./some-module.js'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> SomeThing <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">impmort type</code>은 타입 표기와 선언에 사용될 선언만 import 한다. 이는 항상 완전히 제거되므로, 런타임에 남아있는 것은 없다. 마찬가지로 <code class=\"language-text\">export type</code>은 타입 문맥에 사용할 export만 제공하며, 이 또한 TS의 output에서 제거된다.</p>\n<p>클래스는 런타임에 값을 가지고 있고, design-time(프로그래머가 코딩하는중)에 타입이 있으며 상황에 따라 사용이 다르다는 것에 유의해야 한다. 클래스를 import 하기 위해 <code class=\"language-text\">import type</code>을 사용하면, 확장 같은 것은 할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ButtonProps</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component<span class=\"token operator\">&lt;</span>ButtonProps<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//               ~~~~~~~~~</span>\n  <span class=\"token comment\">// error! 'Component' only refers to a type, but is being used as a value here.</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이전에 Flow를 사용해본 적이 있다면, 이 구문은 상당하게 유사하다. 한 가지 차이점은 코드가 모호해 보이지 않도록 몇 가지 제한을 두었다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Is only 'Foo' a type? Or every declaration in the import?</span>\n<span class=\"token comment\">// We just give an error because it's not clear.</span>\n<span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Bar<span class=\"token punctuation\">,</span> Baz <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'some-module'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//     ~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"token comment\">// error! A type-only import can specify a default import or</span></code></pre></div>\n<p><code class=\"language-text\">import type</code>과 함께, TS 3.8은 런타임 시 사용되지 않는 import에서 발생하는 작업을 제어하기 위해 새로운 컴파일 플래그를 추가한다: <a href=\"https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues\">importsNotUsedAsValues</a> 이 플래그는 3 가지 다른 값을 가진다.</p>\n<ul>\n<li><code class=\"language-text\">remove</code>: 이는 기본값으로, imports를 제거하는 동작이며, 기존 동작을 바꾸는 플래그는 아니다.</li>\n<li><code class=\"language-text\">preserve</code>: 이는 사용되지 않는 값들을 모두 보존한다. 이로 인해 imports/사이드 이펙트가 보존될 수 있다.</li>\n<li><code class=\"language-text\">error</code>: 이는 모든(<code class=\"language-text\">preserve</code> 옵션처럼) 모든 imports를 보존하지만, import 값이 타입으로만 사용될 경우 오류를 발생시킨다. 이는 실수로 값을 import하지 않지만 사이드 이펙트 import를 명시적으로 만들고 싶을 때 유용하다.</li>\n</ul>\n<p>이 기능에 대한 자세한 정보는 <code class=\"language-text\">import type</code>이 선언될 수 있는 범위를 확대하는 <a href=\"https://github.com/microsoft/TypeScript/pull/35200\">PR</a>과 <a href=\"https://github.com/microsoft/TypeScript/pull/36092/\">관련된 변경 사항</a>에서 확인할 수 있다.</p>\n<h2 id=\"ecmascript-비공개-필드\">ECMAScript 비공개 필드</h2>\n<p>TS 3.8은 ECMAScript의 <a href=\"https://github.com/tc39/proposal-class-fields/\">stage-3 클래스 필드 제안</a>의 비공개 필드를 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  #name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> jeremy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Jeremy Bearimy'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njeremy<span class=\"token punctuation\">.</span>#name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//     ~~~~~</span>\n<span class=\"token comment\">// Property '#name' is not accessible outside class 'Person'</span>\n<span class=\"token comment\">// because it has a private identifier.</span></code></pre></div>\n<p>일반적인 프로퍼티들과 달리, 비공개 필드는 몇 가지 주의해야할 규칙이 있다.</p>\n<ul>\n<li>비공개 필드는 <code class=\"language-text\">#</code>문자로 시작한다. 때때로 이를 비공개 이름이라고 부른다.</li>\n<li>모든 비공개 필드 이름은 이를 포함한 클래스 범위에서 유일하다.</li>\n<li><code class=\"language-text\">public</code> 또는 <code class=\"language-text\">private</code> 같은 TS 접근 지정자는 비공개 필드로 사용될 수 없다.</li>\n<li>JS 사용자로부터도 비공개 필드는 이를 포함한 클래스 밖에서 접근하거나 탐지할 수 없다. 때때로 이를 강한 비공개(hard privacy)라고 부른다.</li>\n</ul>\n<p>hard privacy와 별개로, 비공개 필드의 또 다른 장점은 유일하다는 것이다. 예를 들어, 일반적인 프로퍼티 선언은 하위클래스에서 덮어쓰기 쉽다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  foo <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">cHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  foo <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">dHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'this.foo' refers to the same property on each instance.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span><span class=\"token function\">cHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '20'</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span><span class=\"token function\">dHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '20'</span></code></pre></div>\n<p>비공개 필드에서는, 포함하고 있는 클래스에서 각각의 필드 이름이 유일하기 때문에 이에 대해 걱정하지 않아도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  #foo <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">cHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  #foo <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">dHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'this.#foo' refers to a different field within each class.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span><span class=\"token function\">cHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '10'</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span><span class=\"token function\">dHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '20'</span></code></pre></div>\n<p>알아두면 좋은 또 다른 점은 다른 타입으로 비공개 필드에 접근하면 <code class=\"language-text\">TypeError</code>를 발생한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  #sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#sideLength <span class=\"token operator\">=</span> sideLength<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>other<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#sideLength <span class=\"token operator\">===</span> other<span class=\"token punctuation\">.</span>#sideLength<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Square</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> sideLength<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Boom!</span>\n<span class=\"token comment\">// TypeError: attempted to get private field on non-instance</span>\n<span class=\"token comment\">// This fails because 'b' is not an instance of 'Square'.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>마지막으로, 모든 일반 <code class=\"language-text\">.js</code> 파일 사용자들의 경우, 비공개 필드는 항상 할당되기 전에 선언되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// No declaration for '#foo'</span>\n  <span class=\"token comment\">// :(</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// SyntaxError!</span>\n    <span class=\"token comment\">// '#foo' needs to be declared before writing to it.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#foo <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JS는 항상 사용자들에게 선언되지 않은 프로퍼티에 접근을 허용했지만, TS는 항상 클래스 프로퍼티 선언을 요구했다. 비공개 필드는 <code class=\"language-text\">.js</code> 또는 <code class=\"language-text\">.ts</code>파일에서 동작하는지 상관없이 항상 선언이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** @type {number} */</span>\n  #foo<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This works.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#foo <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>구현과 관련한 더 많은 정보는 <a href=\"https://github.com/Microsoft/TypeScript/pull/30829\">원본 PR</a>을 참고</p>\n<h2 id=\"which-should-i-use\">Which should I use?</h2>\n<p>이미 TS 유저로서 어떤 종류의 private를 사용해야 하는지에 대한 많은 질문을 받았다. 주로 <code class=\"language-text\">private</code> 키워드를 사용해야 하나요? 아니면 ECMAScript의 <code class=\"language-text\">#</code> private fields를 사용해야 하나요? 이는 상황마다 다르다.</p>\n<p>프로퍼티에서 TS의 <code class=\"language-text\">private</code> 지정자는 완전히 지워진다. 이는 런타임에서는 완전히 일반 프로퍼티처럼 동작하며 이것이 <code class=\"language-text\">private</code> 지정자로 선언되었다고 알릴 방법이 없다. <code class=\"language-text\">prviate</code> 키워드를 사용할 때, 비공개는 오직 컴파일-타임/디자인-타임에만 시행되며, JS 사용자에게는 전적으로 의도기반이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// This is an error at compile time,</span>\n<span class=\"token comment\">// but when TypeScript outputs .js files,</span>\n<span class=\"token comment\">// it'll run fine and print '10'.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '10'</span>\n<span class=\"token comment\">//                  ~~~</span>\n<span class=\"token comment\">// error! Property 'foo' is private and only accessible within class 'C'.</span>\n<span class=\"token comment\">// TypeScript allows this at compile-time</span>\n<span class=\"token comment\">// as a \"work-around\" to avoid the error.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '10'</span></code></pre></div>\n<p>이 같은 종류의 약한 비공개(soft privacy)는 사용자가 API에 접근할 수 없는 상태에서 일시적으로 작업을 하는 데 도움이 되며, 어떤 런타임에서도 동작한다.</p>\n<p>반면에, ECMAScript의 <code class=\"language-text\">#</code> 비공개는 완벽하게 클래스 밖에서 접근 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  #foo <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>#foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// SyntaxError</span>\n<span class=\"token comment\">//                  ~~~~</span>\n<span class=\"token comment\">// TypeScript reports an error *and*</span>\n<span class=\"token comment\">// this won't work at runtime!</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token string\">'#foo'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints undefined</span>\n<span class=\"token comment\">//          ~~~~~~~~~~~~~~~</span>\n<span class=\"token comment\">// TypeScript reports an error under 'noImplicitAny',</span>\n<span class=\"token comment\">// and this prints 'undefined'.</span></code></pre></div>\n<p>이런 강한 비공개(hard privacy)는 아무도 내부를 사용할 수 없도록 엄격하게 보장하는 데 유용하다. 만약 라이브러리 작성자일 경우, 비공개 필드를 제거하거나 이름을 바꾸는 것이 급격한 변화를 초래해서는 안된다.</p>\n<blockquote>\n<p>비공개 필드는 실제로 사용하는 측에서 안보이기 때문에?</p>\n</blockquote>\n<p>언급했듯이, 다른 장점은 ECMAScript의 <code class=\"language-text\">#</code> 비공개가 말그대로의 비공개이기 때문에 서브 클래싱을 쉽게할 수 있다는 것이다. ECMAScript의 <code class=\"language-text\">#</code> 비공개 필드를 사용하면, 어떤 서브 클래스도 필드 네이밍 충돌에 대해 걱정할 필요가 없다. TS의 <code class=\"language-text\">private</code> 프로퍼티 선언에서는, 사용자는 여전히 상위 클래스에 선언된 프로퍼티를 짓밟지 않도록 주의해야 한다.</p>\n<p>한 가지 더 생각해봐야할 것은 코드가 실행되기를 의도하는 곳이다. 현재 TS는 이 기능을 ECMAScript 2015(ES6) 이상 버전을 대상으로 하지 않으면 지원할 수 없다. 이는 하위 레벨 구현이 비공개를 강제하기 위해 <code class=\"language-text\">WeakMap</code>을 사용하는데, <code class=\"language-text\">WeakMap</code>은 메모리 누수를 일으키지 않도록 폴리필될 수 없기 때문이다. 반면, TS의 <code class=\"language-text\">private</code>선언 프로퍼티는 모든 대상에서 동작한다. (심지어 ECMASCript 3에서도)</p>\n<p>마지막 고려 사항은 속도 일수 있다.: <code class=\"language-text\">private</code> 프로퍼티는 다른 어떤 프로퍼티와 다르지 않기 때문에, 어떤 런타임의 대상으로 하든 다른 프로퍼티와 마찬가지로 접근 속도가 빠를 수 있다. 반면에 <code class=\"language-text\">#</code> 비공개 필드는 <code class=\"language-text\">WeakMap</code>을 이용해 다운 레벨되기 때문에 사용 속도가 느려질 수 잇다. 어떤 런타임은 <code class=\"language-text\">#</code> 비공개 필드 구현을 최적화 하고, 더 빠른 <code class=\"language-text\">WeakMap</code>을 구현을 가지고 있을 수 있지만 모든 런타임에서 그렇지 않을 수 있다.</p>\n<h2 id=\"export--as-ns-문법\">export * as ns 문법</h2>\n<p>다른 모듈의 모든 멤버를 단일 멤버로 내보내는 단일 진입점을 갖는 것은 종종 일반적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> utilities <span class=\"token keyword\">from</span> <span class=\"token string\">'./utilities.js'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> utilities <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 매우 일반적이어서 ECMAScript 2020은 최근 이 패턴을 지원하기 위해 새로운 문법을 추가했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> utilities <span class=\"token keyword\">from</span> <span class=\"token string\">'./utilities.js'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이것은 JS를 한층 더 향상시키고 TS 3.8은 이 문법을 지원한다. 모듈 대상이 <code class=\"language-text\">es2020</code>보다 이전인 경우, TS는 첫번째 코드 스니펫을 따라서 출력할 것이다.</p>\n<h2 id=\"top-level-await\">Top-Level await</h2>\n<p>TS 3.8은 'top-level <code class=\"language-text\">await</code>'라고 불리는 편리한 ECMAScript기능을 지원한다.</p>\n<p>JS 유저는 <code class=\"language-text\">await</code>를 사용하기 위해 <code class=\"language-text\">async</code> 함수를 호출하는데, 이를 정의한 후 즉시 함수를 호출한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 이전의 JS가 <code class=\"language-text\">await</code> 키워드는 오직 <code class=\"language-text\">async</code> 함수 몸체 안에서 허용되었기 때문에 그랬다. 하지만 top-level <code class=\"language-text\">await</code>과 함께, 모듈의 최상위 레벨에서 <code class=\"language-text\">await</code> 키워드를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Make sure we're a module</span>\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>최상위 레벨 <code class=\"language-text\">await</code>은 오직 모듈의 최상단에서 동작하며 타입스크립트가 <code class=\"language-text\">import</code> 혹은 <code class=\"language-text\">export</code>를 찾을 때에만 모듈로 간주된다. 일부 기본적인 경우에, <code class=\"language-text\">export {}</code>와 같은 보일러 플레이트를 작성하여 이를 확인할 필요가 있다.</p>\n<p>이러한 경우가 예상되는 모든 환경에서 Top Level <code class=\"language-text\">await</code>은 동작하지 않을 수 있다. 현재, <code class=\"language-text\">target</code> 컴파일러 옵션이 <code class=\"language-text\">es2017</code> 이상이고 <code class=\"language-text\">module</code>이 <code class=\"language-text\">esnext</code>또는 <code class=\"language-text\">system</code>인 경우에만 최상위 레벨 <code class=\"language-text\">await</code>를 사용할 수 잇다. 몇몇 환경과 번들러내에서의 지원은 제한적으로 작동하거나 실험적 지원을 활성화해야할 수 있다.</p>\n<p>구현에 관한 더 자세한 정보는 <a href=\"https://github.com/microsoft/TypeScript/pull/35813\">원본 PR</a>을 참고</p>\n<h2 id=\"es2020용-target과-module\">es2020용 target과 module</h2>\n<p>TS 3.8은 <code class=\"language-text\">es2020</code>을 <code class=\"language-text\">module</code>과 <a href=\"https://www.typescriptlang.org/tsconfig/#target\">target</a> 옵션으로 지원한다. 이를 통해 옵셔널 체이닝이나 널병합 연산, <code class=\"language-text\">export * as ns</code>, 동적 <code class=\"language-text\">import(...)</code> 문법과 같은 ECMAScript 2020 기능을 사용할 수 있다. 또한 <code class=\"language-text\">bigint</code> 리터럴이 <code class=\"language-text\">esnext</code> 아래에 안정적인 target을 갖는 것을 의미한다.</p>\n<h2 id=\"jsdoc-프로퍼티-지정자\">JSDoc 프로퍼티 지정자</h2>\n<p>TS 3.8은 <code class=\"language-text\">allowJs</code> 플래그를 사용하여 JS 파일을 지원하고, <code class=\"language-text\">checkJs</code> 옵션이나 <code class=\"language-text\">// @ts-check</code> 주석을 <code class=\"language-text\">.js</code> 파일의 최상단에 추가함으로써 JS 파일의 타입 검사를 지원한다.</p>\n<p>JS 파일에는 타입 체킹을 위한 전용 문법이 없기 때문에, TS는 JSDoc을 활용한다. TS 3.8은 프로퍼티에 대한 몇 가지 새로운 JSDoc 태그를 인식한다.</p>\n<p>먼저 접근 지정자이다. <code class=\"language-text\">@public</code>, <code class=\"language-text\">@private</code>, 그리고 <code class=\"language-text\">@protected</code>이다. 이 태그들은 <code class=\"language-text\">public</code> <code class=\"language-text\">private</code>, <code class=\"language-text\">protected</code>와 동일하게 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// @ts-check</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/** @private */</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stuff <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">printStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stuff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>stuff<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//        ~~~~~</span>\n<span class=\"token comment\">// error! Property 'stuff' is private and only accessible within class 'Foo'.</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">@public</code>은 항상 암시적이며 생략될 수 있지만, 어디서든 프로퍼티에 접근 가능함을 의미한다.</li>\n<li><code class=\"language-text\">@private</code>은 오직 프로퍼티를 포함하는 클래스 안에서만 해당 프로퍼티는 사용할 수 있음을 의미한다.</li>\n<li><code class=\"language-text\">@protected</code>는 프로퍼티를 포함하는 클래스와 파생된 모든 하위 클래스내에서 해당 프로퍼티를 사용할 수 있지만, 포함하는 클래스의 인스턴스는 해당 프로퍼티를 사용할 수 없다.</li>\n</ul>\n<p>다음으로, <code class=\"language-text\">@readonly</code> 지정자를 추가하여 프로퍼티가 초기화 과정 내에서만 값이 쓰이는 것을 보장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// @ts-check</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/** @readonly */</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stuff <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">writeToStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stuff <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//   ~~~~~</span>\n    <span class=\"token comment\">// Cannot assign to 'stuff' because it is a read-only property.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>stuff<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//        ~~~~~</span>\n<span class=\"token comment\">// Cannot assign to 'stuff' because it is a read-only property.</span></code></pre></div>\n<h2 id=\"리눅스에서-더-나은-디렉터리-감시와-watchoptions\">리눅스에서 더 나은 디렉터리 감시와 watchOptions</h2>\n<p>TS 3.8에서는 <code class=\"language-text\">node_modules</code>의 변경사항을 효율적으로 수집하는데 중요한 새로운 디렉터리 감시전략을 제공한다.</p>\n<p>리눅스와 같은 운영체제에서 TS는 <code class=\"language-text\">node_modules</code>에 디렉터리 왓쳐를 설치하고 의존성 변화를 감지하기 위해 많은 하위 디렉터리를 설치한다. 왜냐하면 사용 가능한 파일 왓쳐의 수는 <code class=\"language-text\">node_modules</code>의 파일 수에 의해 가려지기 때문이고, 추적할 디렉터리 수가 적기 때문이다.</p>\n<p>TS의 이전 버전은 즉각적으로 폴더에 디렉터리 왓쳐를 즉시 설치하며, 초기에는 괜찮을 것이다. 그러나 npm install을 할 때, <code class=\"language-text\">node_modules</code>안에서 많은 일들이 발생할 것이고, TS를 압도하여 종종 에디터 세션을 아주 느리게 만든다. 이를 방지하기 위해, TS 3.8은 디렉터리 왓쳐를 설치하기 전에 조금 기다려서 변동성이 높은 디렉터리에게 안정화될 시간을 준다.</p>\n<p>모든 프로젝트는 다른 전략에서 더 잘 작동할 수 있고, 이 새로운 방법은 당신의 작업 흐름에는 잘 맞지 않을 수 있기 때문에, TS 3.8은 파일과 디렉터리를 감시하는데 어떤 감시 전략을 사용할지 컴파일러/언어 서비스에 알려줄 수 있도록 <code class=\"language-text\">tsconfig.json</code>과 <code class=\"language-text\">jsconfig.json</code>에 <code class=\"language-text\">watchOptions</code>란 새로운 필드를 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Some typical compiler options</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"target\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"es2020\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"moduleResolution\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node\"</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// NEW: Options for file/directory watching</span>\n  <span class=\"token property\">\"watchOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Use native file system events for files and directories</span>\n    <span class=\"token property\">\"watchFile\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"useFsEvents\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"watchDirectory\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"useFsEvents\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// Poll files for updates more frequently</span>\n    <span class=\"token comment\">// when they're updated a lot.</span>\n    <span class=\"token property\">\"fallbackPolling\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dynamicPriority\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">watchOptions</code>는 구성할 수 있는 4가지의 새로운 옵션이 포함되어 있다.</p>\n<ul>\n<li>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#watchFile\">watchFile</a>: 각 파일의 감시 방법 전략. 다음과 같이 설정할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">fixedPollingInterval</code>: 고정된 간격으로 모든 파일의 변경을 1초에 여러 번 검사한다.</li>\n<li><code class=\"language-text\">priorityPollingInterval</code>: 모든 파일의 변경을 1초에 여러 번 검사한다. 하지만 휴리스틱을 사용하여 특정 타입의 파일은 다른 타입의 파일보다 덜 자주 검사한다.</li>\n<li><code class=\"language-text\">dynamicPriorityPolling</code>: 동적 큐를 사용하여 자주 수정되지 않은 파일은 적게 검사한다.</li>\n<li><code class=\"language-text\">useFsEvents</code>(디폴트): 파일 변화에 운영체제/파일 시스템의 네이티브 이벤트를 사용한다.</li>\n<li><code class=\"language-text\">useFsEventsOnParentDirectory</code>: 파일을 포함하고 있는 디렉터리를 감지할 때, 운영체제/파일 시스템의 네이티브 이벤트를 사용한다. 파일 왓쳐를 적게 사용할 수 있지만, 덜 정확할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#watchDirectory\">watchDirectory</a>: 재귀적인 파일 감시기능이 없는 시스템 안에서 전체 디렉터리 트리가 감시되는 전략. 다음과 같이 설정할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">fixedPollingInterval</code>: 고정된 간격으로 모든 디렉터리의 변경을 1초에 여러 번 검사한다.</li>\n<li><code class=\"language-text\">dynamicPriorityPolling</code>: 동적 큐를 사용하여 자주 수정되지 않은 디렉터리는 적게 검사한다.</li>\n<li><code class=\"language-text\">useFsEvents</code>(디폴트): 디렉터리 변경에 운영체제/파일 시스템의 네이티브 이벤트를 사용한다.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#fallbackPolling\">fallbackPolling</a></p>\n<ul>\n<li><code class=\"language-text\">fixedPollingInterval</code>: 위 내용 참조</li>\n<li><code class=\"language-text\">priorityPollingInterval</code>: 위 내용 참조</li>\n<li><code class=\"language-text\">dynamicPriorityPolling</code>: 위 내용 참조</li>\n<li><code class=\"language-text\">synchronousWatchDirectory</code>: 디렉터리의 연기된 감시를 비활성화 한다. 연기된 감시는 많은 파일이 한 번에 변경될 때 유용하다. (예를 들어, <code class=\"language-text\">npm install</code>을 실행하여 <code class=\"language-text\">node_modules</code>의 변경), 하지만 보편적이지 않은 설정이기 때문에 비활성화할 수 있다.</li>\n</ul>\n<p>이 변경에 대한 더 자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/35615\">Github으로 이동하여 PR 참고</a></p>\n</li>\n</ul>\n<h2 id=\"빠르고-느슨한-증분-검사\">\"빠르고 느슨한\" 증분 검사</h2>\n<p>TS 3.8은 새로운 컴파일러 옵션인 <a href=\"https://www.typescriptlang.org/tsconfig#assumeChangesOnlyAffectDirectDependencies\">assumeChangesOnlyAffectDirectDepencies</a>을 제공한다. 이 옵션이 활성화 되면, TS는 영향을 받은 파일들은 재검사/재빌드 하지않고, 변경된 파일과 직접 import한 파일만 재검사/재빌드 한다.</p>\n<p>예를들어, 다음과 같이 <code class=\"language-text\">fileA.ts</code>를 import한 <code class=\"language-text\">fileB.ts</code>를 import한 <code class=\"language-text\">fileC.ts</code>를 import한 <code class=\"language-text\">fileD.ts</code>를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">fileA<span class=\"token punctuation\">.</span>ts <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span>fileB<span class=\"token punctuation\">.</span>ts <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span>fileC<span class=\"token punctuation\">.</span>ts <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span>fileD<span class=\"token punctuation\">.</span>ts<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">--watch</code> 모드에서는, <code class=\"language-text\">fileA.ts</code>의 변경이 <code class=\"language-text\">fileB.ts</code>, <code class=\"language-text\">fileC.ts</code> 그리고 <code class=\"language-text\">fileD.ts</code>를 TS가 재검사 해야한다는 의미이다. <code class=\"language-text\">assumeChangesOnlyAffectDirectDependencies</code>에서는 <code class=\"language-text\">fileA.ts</code>의 변경은 <code class=\"language-text\">fileA.ts</code>와 <code class=\"language-text\">fileB.ts</code>만 재검사하면 된다.</p>\n<p>VSCode와 같은 코드 베이스에서는, 특정 파일의 변경에 대해 약 14초에서 약 1초로 재 빌드 시간을 줄여주었다. 이 옵션을 모든 코드 베이스에서 추천하는 것은 아니지만, 큰 코드베이스를 가지고 있고, 나중까지 전체 프로젝트 오류를 기꺼이 연기하겠다면 이 옵션이 흥미로울 것이다.</p>\n<p>더 자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/35711\">원본 PR 참고</a></p>","frontmatter":{"date":"22.12.30","description":"TypeScript 3.8 Release를 번역하면서 어떤 기능들이 전에 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42mOwD9z6n5qYgW4G2gVsgbMdgrb+dwiEYHQ5ogyEabD23fzf0nvTfwvvTXDaymczXA02g3G60NZ/y/+ozP3/43IP/k8tPvw/ufDw/5Tiw/+jsvb/t/HbQrqXQZqCk/f8z6489j+99Mj/+LyD/zPKjv6PyT7w39pvM3letvHb/N/SZ9N/cy+IdynyMkakQDFZkUJIE1kGkpsOAVDDx+dN5GA6AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 3.8 번역"},"tableOfContents":"<ul>\n<li><a href=\"#type-only-imports%EC%99%80-export\">Type-Only Imports와 Export</a></li>\n<li><a href=\"#ecmascript-%EB%B9%84%EA%B3%B5%EA%B0%9C-%ED%95%84%EB%93%9C\">ECMAScript 비공개 필드</a></li>\n<li><a href=\"#which-should-i-use\">Which should I use?</a></li>\n<li><a href=\"#export--as-ns-%EB%AC%B8%EB%B2%95\">export * as ns 문법</a></li>\n<li><a href=\"#top-level-await\">Top-Level await</a></li>\n<li><a href=\"#es2020%EC%9A%A9-target%EA%B3%BC-module\">es2020용 target과 module</a></li>\n<li><a href=\"#jsdoc-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A7%80%EC%A0%95%EC%9E%90\">JSDoc 프로퍼티 지정자</a></li>\n<li><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%8D%94-%EB%82%98%EC%9D%80-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EA%B0%90%EC%8B%9C%EC%99%80-watchoptions\">리눅스에서 더 나은 디렉터리 감시와 watchOptions</a></li>\n<li><a href=\"#%EB%B9%A0%EB%A5%B4%EA%B3%A0-%EB%8A%90%EC%8A%A8%ED%95%9C-%EC%A6%9D%EB%B6%84-%EA%B2%80%EC%82%AC\">\"빠르고 느슨한\" 증분 검사</a></li>\n</ul>"}},"pageContext":{"id":"f93cb92a-2d3f-5b20-8e5f-2747a5eea120","frontmatter__slug":"/translate-ts-3-8","previous":"/translate-react-native-ts-first","previousTitle":"First-class Support for TypeScript 번역","next":"/translate-ts-3-7","nextTitle":"TypeScript 3.7 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}