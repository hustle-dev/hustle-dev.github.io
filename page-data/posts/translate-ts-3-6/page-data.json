{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-3-6/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html</a></p>\n</blockquote>\n<h2 id=\"엄격한-제너레이터\">엄격한 제너레이터</h2>\n<p>TS 3.6은 이터레이터와 제너레이터 함수에 대해 더 엄격하게 검사를 한다. 이전 버전에서 제너레이터의 사용자들은 값이 제너레이터의 <code class=\"language-text\">yield</code>로 부터 나왔는지, <code class=\"language-text\">return</code>에 의해 반환되었는지를 구별할 방법이 없었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Finished!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> iter <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> curr <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// TypeScript 3.5 and prior thought this was a 'string | number'.</span>\n  <span class=\"token comment\">// It should know it's 'string' since 'done' was 'true'!</span>\n  curr<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>게다가 제너레이터의 <code class=\"language-text\">yield</code>의 타입이 항상 <code class=\"language-text\">any</code>라고 가정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span><span class=\"token punctuation\">;</span>\n  x<span class=\"token punctuation\">.</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> iter <span class=\"token operator\">=</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\niter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\niter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// oops! runtime error!</span></code></pre></div>\n<p>TS 3.6에서 Checker는 이제 첫 번째 예에서 <code class=\"language-text\">curr.value</code>에 대한 올바른 타입이 문자열이어야 한다는 것을 알고 있고, 마지막 예에서 <code class=\"language-text\">next()</code>로 호출할 때 올바르게 오류를 발생시킨다. 이것은 몇 가지 새로운 타입 매개변수를 포함하도록 <code class=\"language-text\">Iterator</code> 및 <code class=\"language-text\">IteratorResult</code> 타입 선언의 일부 변경과 <code class=\"language-text\">Generator</code> 타입이라고 불리는 제너레이터를 나타내기 위해 타입스크립트가 사용하는 새로운 형식 덕분에 가능해졌다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Iterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> TNext <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Takes either 0 or 1 arguments - doesn't accept 'undefined'</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">[</span>TNext<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">?</span><span class=\"token operator\">:</span> TReturn<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">throw</span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 작업을 기반으로 한 새로운 제너레이터 타입은 <code class=\"language-text\">return</code> 및 <code class=\"language-text\">throw</code> 메서드가 항상 존재하는 <code class=\"language-text\">Iterator</code>이며, 또한 반복이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Generator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">,</span> TReturn <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> TNext <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Iterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token punctuation\">,</span> TNext<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">[</span>TNext<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> TReturn<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Generator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token punctuation\">,</span> TNext<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">return</code>된 값과 <code class=\"language-text\">yield</code>된 값을 구별할 수 있도록 TS 3.6은 <code class=\"language-text\">IteratorResult</code> 유형을 식별된 유니언 타입으로 변환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> IteratorYieldResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> IteratorReturnResult<span class=\"token operator\">&lt;</span>TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IteratorYieldResult<span class=\"token operator\">&lt;</span>TYield<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  done<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> TYield<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IteratorReturnResult<span class=\"token operator\">&lt;</span>TReturn<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> TReturn<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>간단히 말해, 이것이 의미하는 바는 이터레이터를 직접 다룰 때 값을 적절하게 좁힐 수 있다는 것이다.</p>\n<p>제너레이터의 <code class=\"language-text\">next()</code> 호출로 전달되는 타입을 올바르게 표현하기 위해 TS 3.6은 또한 제너레이터 함수의 본문 내에서 특정한 <code class=\"language-text\">yield</code> 사용을 추론한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// first call to 'next' is always ignored</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error! 'number' is not assignable to 'string'</span></code></pre></div>\n<p>명시적으로 사용하기를 원하는 경우 명시적으로 반환 타입을 사용하여 <code class=\"language-text\">yield</code> 표현식에서 return, yield 및 평가할 수 있는 값 유형을 적용할 수 있다. 아래에서 <code class=\"language-text\">next()</code>는 <code class=\"language-text\">boolean</code>만 사용하여 호출할 수 있고, <code class=\"language-text\">done</code> 값에 따라 값은 <code class=\"language-text\">string</code> 또는 <code class=\"language-text\">number</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\n * - yields numbers\n * - returns strings\n * - can be passed in booleans\n */</span>\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Generator<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">yield</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'done!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> iter <span class=\"token operator\">=</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> curr <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>curr<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  curr <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>value <span class=\"token operator\">===</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// prints:</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// 0</span>\n<span class=\"token comment\">// 1</span>\n<span class=\"token comment\">// 2</span>\n<span class=\"token comment\">// 3</span>\n<span class=\"token comment\">// 4</span>\n<span class=\"token comment\">// 5</span>\n<span class=\"token comment\">// DONE!</span></code></pre></div>\n<p>자세한 사항을 확인하고 싶다면 <a href=\"https://github.com/Microsoft/TypeScript/issues/2983\">이 PR 참조</a></p>\n<h2 id=\"더-정확한-배열-스프레드\">더 정확한 배열 스프레드</h2>\n<p>ES2015 이전 타겟에서 <code class=\"language-text\">for/of</code> 반복문 및 배열 스프레드와 같은 문법에 대한 가장 신뢰있는 방출은 다소 무거울 수 있다. 이러한 이유로 TS는 기본적으로 배열 타입만 지원하는 더 단순한 방출을 사용하며 <code class=\"language-text\">downlevelIteration</code> 플래그를 사용하는 다른 유형에 대한 반복을 지원한다.</p>\n<blockquote>\n<p>다운 레벨링이란?\n자바스크립트의 이전 버전으로 전환하는 것을 가리키는 TS 용어이다. 이 플래그는 이전 JS 런타임에서 새로운 개념을 통해 현재 JS가 반복되는 방식을 보다 정확하게 구현할 수 있도록 지원하기 위한 것이다.\nECMAScript 6는 <code class=\"language-text\">for/of</code>나 <code class=\"language-text\">for (el of arr)</code>, 배열 스프레드, 인수 스프레드, <code class=\"language-text\">Symbol.iterator</code>와 같은 새로운 반복 기본 요소를 추가했다. <code class=\"language-text\">downlevelIteration</code>을 사용하면 <code class=\"language-text\">Symbol.iterator</code> 구현이 존재하는 경우 ES5 환경에서 이러한 반복 기본 요소를 보다 정확하게 사용할 수 있다.\n자세한 사항은 아래 링크참조: <a href=\"https://www.typescriptlang.org/tsconfig#downlevelIteration\">https://www.typescriptlang.org/tsconfig#downlevelIteration</a></p>\n</blockquote>\n<p><code class=\"language-text\">downlevelIteration</code>이 없는 더 느슨한 기본값 반복은 상당히 잘 동작하지만 배열 스프레드의 변환이 관찰 가능한 차이를 갖는 몇 가지 일반적인 경우가 있었다. 예를들어 아래와 같이 스프레드 배열을 포함하는 배열이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 다음 배열 리터럴로 다시 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token punctuation\">[</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그러나 TS는 대신 원본 코드를 다음과 같이 변환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>약간 다른데, <code class=\"language-text\">Array(5)</code>는 길이가 5이지만, 위는 정의된 프로퍼티가 없는 배열을 생성한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/hustle-dev/post/15ed2d54-2dbc-45bf-8885-3a15f473ef79/image.png\" alt=\"\"></p>\n<p>TS 3.6은 새로운 <code class=\"language-text\">__spreadArrays</code> 헬퍼를 도입하여 <code class=\"language-text\">downlevelIteration</code>이 아닌 이전 대상에서 ECMAScript 2015에서 발생하는 일을 정확하게 모델링한다. <code class=\"language-text\">__spreadArrays</code>는 <a href=\"https://github.com/Microsoft/tslib/\">tslib</a>에서도 사용할 수 있다.</p>\n<p>자세한 사항을 <a href=\"https://github.com/microsoft/TypeScript/pull/31166\">이 PR을 참조</a></p>\n<h2 id=\"프로미스를-둘러싼-ux-개선\">프로미스를 둘러싼 UX 개선</h2>\n<p>TS 3.6은 <code class=\"language-text\">Promise</code>가 잘못 처리될 때 몇 가지 개선 사항을 소개한다.</p>\n<p>예를들어<code class=\"language-text\">Promise</code>의 내용을 다른 함수로 전달하기 전에 <code class=\"language-text\">.then()</code> 하거나 <code class=\"language-text\">await</code>하는 것을 까먹는 경우가 매우 일반적이다. TS의 오류 메시지는 이제 전문화되어 사용자에게 <code class=\"language-text\">await</code> 키워드를 고려해야 할 것임을 알려준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  location<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">displayUser</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">displayUser</span><span class=\"token punctuation\">(</span><span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//              ~~~~~~~~~~~~~</span>\n  <span class=\"token comment\">// Argument of type 'Promise&lt;User>' is not assignable to parameter of type 'User'.</span>\n  <span class=\"token comment\">//   ...</span>\n  <span class=\"token comment\">// Did you forget to use 'await'?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 <code class=\"language-text\">Promise</code>를 <code class=\"language-text\">await</code> 하거나 <code class=\"language-text\">.then()</code> 전에 메서드에 액세스 하려고 시도하는 것이 일반적이다. 아래가 그러한 예이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getCuteAnimals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://reddit.com/r/aww.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//   ~~~~</span>\n  <span class=\"token comment\">// Property 'json' does not exist on type 'Promise&lt;Response>'.</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token comment\">// Did you forget to use 'await'?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자세한 사항은 <a href=\"https://github.com/microsoft/TypeScript/issues/30646\">이 이슈 참고</a></p>\n<h2 id=\"식별자에-대한-향상된-유니코드-지원\">식별자에 대한 향상된 유니코드 지원</h2>\n<p>TS 3.6은 ES2015 이상의 대상에 방출할 때, 식별자의 유니코드 문자를 더 잘 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> 𝓱𝓮𝓵𝓵𝓸 <span class=\"token operator\">=</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// previously disallowed, now allowed in '--target es2015'</span></code></pre></div>\n<h2 id=\"systemjs에서-importmeta-지원\">SystemJS에서 import.meta 지원</h2>\n<p>TS는 <code class=\"language-text\">module</code>의 타겟이 <code class=\"language-text\">system</code>으로 설정된 경우 <code class=\"language-text\">import.meta</code>를 <code class=\"language-text\">context.meta</code>로 변환하는 기능을 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// This module:</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// gets turned into the following:</span>\nSystem<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>exports<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    setters<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">execute</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"주변-컨텍스트에서-get-set-접근자-허용\">주변 컨텍스트에서 get, set 접근자 허용</h2>\n<p>이전 버전의 TS에서 언어는 주변 컨텍스트(<code class=\"language-text\">declare</code> -d 클래스 또는 일반적으로 <code class=\"language-text\">.d.ts</code> 파일)에서 <code class=\"language-text\">get</code> 및 <code class=\"language-text\">set</code>의 접근자를 하용하지 않았다. 그러나 <a href=\"https://github.com/tc39/proposal-class-fields/issues/248\">ECMAScript의 클래스 필드 제안이 기존 버전의 TS와 다른 동작을 할 수 있기</a> 때문에 하위 클래스에서 적절할 오류를 제공하기 위해 서로 다른 동작을 전달하는 방법이 필요하다는 것을 알았다.</p>\n<p>결과적으로 사용자는 TS 3.6에서 주변 컨텍스트에 게터와 세터를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Allowed in 3.6+.</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TS 3.7에서 컴파일러 자체는 이 기능을 이용하여 생성된 <code class=\"language-text\">.d.ts</code> 파일도 <code class=\"language-text\">get/set</code> 접근자를 내보낸다.</p>\n<h2 id=\"주변-클래스와-함수가-병합될-수-있음\">주변 클래스와 함수가 병합될 수 있음</h2>\n<p>이전 버전의 TS에서는 어떤 상황에서도 클래스와 함수를 병합하는 것이 오류였다. 이제 주변 클래스와 함수(<code class=\"language-text\">declare</code> 수식자가 있는 클래스/함수 또는 <code class=\"language-text\">.d.ts</code> 파일)가 병합될 수 있다. 이것은 이제 아래와 같이 쓸 수 있다는 것을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 이렇게 사용하는 대신에</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Point2D</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">var</span> Point2D<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Point2D<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Point2D<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이렇게 사용할 수 있다</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Point2D</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Point2D<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Point2D</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것의 한 가지 장점은 호출 가능한 생성자 패턴을 쉽게 표현할 수 있는 동시에 네임스페이스가 네임스페이스와 병합될 수 있다는 것이다.(<code class=\"language-text\">var</code> 선언은 네임스페이스와 병합 X)</p>\n<p>TS 3.7에서 컴파일러는 <code class=\"language-text\">.js</code> 파일에서 생성된 <code class=\"language-text\">.d.ts</code> 파일이 클래스 유사 함수의 호출 가능성과 생성 가능성을 모두 적절하게 캡처할 수 있도록 이 기능을 활용한다.</p>\n<p>자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/32584\">이 PR 참고</a></p>\n<h2 id=\"--build와---incremental를-지원하는-api들\">--build와 --incremental를 지원하는 API들</h2>\n<p>TS 3.0은 <code class=\"language-text\">--build</code> 플래그를 사용하여 다른 것을 참조하고 점진적으로 빌드하는 지원을 도입했다. 또한 TS 3.4는 특정 파일을 재구축하기 위해 이전 컴파일에 대한 정보를 저장하기 위한 증분 플래그를 도입했다. 이러한 플래그는 프로젝트를 보다 유연하게 구성하고 구축 속도를 높이는 데 매우 유용했다. 불행히도 이러한 도구를 사용하는 것은 Gulp 및 Webpack과 같은 제 3자 빌드 도구에서는 작동하지 않았다. TS 3.6은 이제 프로젝트 참조 및 증분 프로그램 빌드에서 작동하는 두 개의 API 집합을 제공한다.</p>\n<p>증분 빌드를 만들기 위해 사용자는 <code class=\"language-text\">createIncrementalProgram</code>와 <code class=\"language-text\">createIncrementalCompilerHost</code> API를 활용할 수 있다. 사용자는 또한 노출된 <code class=\"language-text\">readBuilderProgram</code> 함수를 사용하여 이 API에 의해 생성된 <code class=\"language-text\">.tsbuildinfo</code> 파일에서 오래된 프로그램 인스턴스를 re-hydrate를 할 수 있고, 이는 새 프로그램을 만드는 데만 사용한다.(즉 반환된 인스턴스를 수정할 수 없다. 다른 <code class=\"language-text\">create*Program</code> 함수에서 <code class=\"language-text\">oldProgram</code> 매개 변수에만 사용된다.)</p>\n<p>프로젝트 참조를 활용하기 위해 새 타입 <code class=\"language-text\">SolutionBuilder</code>의 인스턴스를 반환하는 새 <code class=\"language-text\">createSolutionBuilder</code> 함수가 노출되었다.</p>\n<p>이러한 API에 대한 자세한 설명은 <a href=\"https://github.com/microsoft/TypeScript/pull/31432\">이 PR 참조</a></p>\n<h2 id=\"세미콜론-인식-코드-편집\">세미콜론 인식 코드 편집</h2>\n<p>Visual Studio 및 VSCode와 같은 편집기는 빠른 수정, 리팩터링 및 다른 모듈에서 값을 자동으로 가져오는 등의 변환을 자동으로 적용할 수 있다. 이러한 변환은 TS에 의해 구동되며, 이전 버전의 TS는 모든 문 끝에 무조건 세미콜론을 추가했다.</p>\n<p>이제 TS는 이러한 종류의 편집을 적용할 때 파일이 세미콜론을 사용하는지 여부를 감지할 수 있을 정도로 충분히 똑똑하다. 파일에 일반적으로 세미콜론이 없는 경우 TS는 세미콜론을 추가하지 않는다.</p>\n<p>자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/31801\">이 PR 참조</a></p>\n<h2 id=\"더-스마트한-auto-import-문법\">더 스마트한 Auto-Import 문법</h2>\n<p>JS는 ECMAScript 표준의 것, 이미 지원하는 하나의 노드 (CommonJS), AMD, System.js 등 다양한 모듈 구문 또는 규약을 가지고 있다. 대부분의 경우 TS는 ECMAScript 모듈 구문을 사용하여 Auto-Import를 수행하는데, 이는 컴파일러 설정이 서로 다른 특정 TS 프로젝트나 일반 JS가 있는 노드 프로젝트에서 부적절한 경우가 많았다.</p>\n<p>TS 3.6은 이제 다른 모듈을 Auto-Import 방법을 결정하기 전에 기존 import 문을 검토하는 것이 조금 더 현명하다.</p>\n<p>자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/32684\">이 PR 참조</a></p>\n<h2 id=\"새-ts-playground\">새 TS Playground</h2>\n<p>TS Playground는 편리한 새로운 기능으로 많은 환호를 받았다. 새로운 playground는 커뮤니티 구성원들이 점점 더 많이 사용하고 있는 <a href=\"https://github.com/agentcooper\">Artem Tyurin</a>의 <a href=\"https://github.com/agentcooper/typescript-play\">TS Playground</a>이다. 우리는 Artem에게 큰 감사를 표한다.</p>\n<p>새로운 playground는 아래와 같은 많은 옵션을 지원한다.</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#target\">타겟</a> 옵션(사용자가 es5에서 es3, es2015, esnext 등으로 전환 가능)</li>\n<li>모든 엄격성 플래그(<a href=\"https://www.typescriptlang.org/tsconfig#strict\">strict</a>만 포함)</li>\n<li>일반 JS 파일 지원(<code class=\"language-text\">allowJS</code>를 사용하고 선택적으로 <a href=\"https://www.typescriptlang.org/tsconfig#checkJs\">checkJs</a>)</li>\n</ul>\n<p>이러한 옵션은 playground 샘플에 대한 링크를 공유할 때에도 유지되므로 사용자가 수신자에게 따로 옵셜 설정을 말해줄 필요없이 신뢰도높은 공유를 가능하게 한다.</p>\n<p>가까운 미래에, playground 샘플을 고치고, JSX 지원을 추가하고, 자동 타입 획득을 연마할 것이다. 이것은 여러분이 개인 편집기에서 얻을 수 있는 것과 동일한 경험을 playground에서 볼 수 있다는 것을 의미한다.</p>","frontmatter":{"date":"22.12.06","description":"TypeScript 3.6 Release를 번역하면서 전에 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42mOwD9z6n5qYgW4G2gVsgbMdgrb+dwiEYHQ5ogyEabD23fzf0nvTfwvvTXDaymczXA02g3G60NZ/y/+ozP3/43IP/k8tPvw/ufDw/5Tiw/+jsvb/t/HbQrqXQZqCk/f8z6489j+99Mj/+LyD/zPKjv6PyT7w39pvM3letvHb/N/SZ9N/cy+IdynyMkakQDFZkUJIE1kGkpsOAVDDx+dN5GA6AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 3.6 번역"},"tableOfContents":"<ul>\n<li><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0\">엄격한 제너레이터</a></li>\n<li><a href=\"#%EB%8D%94-%EC%A0%95%ED%99%95%ED%95%9C-%EB%B0%B0%EC%97%B4-%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C\">더 정확한 배열 스프레드</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4%EB%A5%BC-%EB%91%98%EB%9F%AC%EC%8B%BC-ux-%EA%B0%9C%EC%84%A0\">프로미스를 둘러싼 UX 개선</a></li>\n<li><a href=\"#%EC%8B%9D%EB%B3%84%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%ED%96%A5%EC%83%81%EB%90%9C-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90\">식별자에 대한 향상된 유니코드 지원</a></li>\n<li><a href=\"#systemjs%EC%97%90%EC%84%9C-importmeta-%EC%A7%80%EC%9B%90\">SystemJS에서 import.meta 지원</a></li>\n<li><a href=\"#%EC%A3%BC%EB%B3%80-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-get-set-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%97%88%EC%9A%A9\">주변 컨텍스트에서 get, set 접근자 허용</a></li>\n<li><a href=\"#%EC%A3%BC%EB%B3%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%95%A8%EC%88%98%EA%B0%80-%EB%B3%91%ED%95%A9%EB%90%A0-%EC%88%98-%EC%9E%88%EC%9D%8C\">주변 클래스와 함수가 병합될 수 있음</a></li>\n<li><a href=\"#--build%EC%99%80---incremental%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-api%EB%93%A4\">--build와 --incremental를 지원하는 API들</a></li>\n<li><a href=\"#%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0-%EC%9D%B8%EC%8B%9D-%EC%BD%94%EB%93%9C-%ED%8E%B8%EC%A7%91\">세미콜론 인식 코드 편집</a></li>\n<li><a href=\"#%EB%8D%94-%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%95%9C-auto-import-%EB%AC%B8%EB%B2%95\">더 스마트한 Auto-Import 문법</a></li>\n<li><a href=\"#%EC%83%88-ts-playground\">새 TS Playground</a></li>\n</ul>"}},"pageContext":{"id":"1a8e92a3-b0a9-59c7-8519-a28f46a5d3e5","frontmatter__slug":"/translate-ts-3-6","previous":"/translate-ts-3-7","previousTitle":"TypeScript 3.7 번역","next":"/translate-ts-3-5","nextTitle":"TypeScript 3.5 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}