{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-8/","result":{"data":{"markdownRemark":{"html":"<!-- 썸네일 -->\n<!-- 본문 -->\n<blockquote>\n<p>TypeScript 5.8에서 중요하다고 생각되는 부분을 번역했습니다. 더 자세한 글은 아래 원글 링크를 참고해주세요.\n<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/\">https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/</a></p>\n</blockquote>\n<h2 id=\"반환-표현식에서의-세분화된-검토\">반환 표현식에서의 세분화된 검토</h2>\n<p>TypeScript가 <code class=\"language-text\">cond ? trueBranch : falseBranch</code>와 같은 조건 표현식을 검사할 때 해당 표현식의 타입은 두 분기의 타입을 포함하는 유니온 타입으로 처리된다.</p>\n<p>따라서 아래의 예제는 <code class=\"language-text\">any | string</code>이 되는데 <code class=\"language-text\">any</code>가 다른 타입과 결합 시 전염성이 강해 <code class=\"language-text\">any</code>가 되어버린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> untypedCache<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUrlObject</span><span class=\"token punctuation\">(</span>urlString<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">URL</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> untypedCache<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span>\n        untypedCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n        urlString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>따라서 위 예제의 타입 시스템은 해당 코드에서 버그를 감지할 수 있는 정보를 이미 잃어버린 상태가 된다.</p>\n<p>TypeScript 5.8에선 <code class=\"language-text\">return</code>문 내부의 조건 표현식에 대해 타입 시스템이 조건 표현식의 각 분기를 함수의 선언된 반환 타입과 <strong>개별적으로 비교</strong>해 검사한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> untypedCache<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUrlObject</span><span class=\"token punctuation\">(</span>urlString<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">URL</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> untypedCache<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span>\n        untypedCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n        urlString<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//  ~~~~~~~~~</span>\n    <span class=\"token comment\">// error! Type 'string' is not assignable to type 'URL'.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"--module-nodenext에서-ecmascript-모듈의-require-지원\"><code class=\"language-text\">--module nodenext</code>에서 ECMAScript 모듈의 <code class=\"language-text\">require()</code> 지원</h2>\n<p>수년 동안 Node.js는 CommonJS 모듈과 함께 ECMAScript 모듈을 지원했지만 상호 운용하는데에 있어 몇 가지 문제가 있었다.</p>\n<ul>\n<li>ESM 파일은 CommonJS 파일을 <code class=\"language-text\">import</code>할 수 있음</li>\n<li>CommonJS 파일은 ESM 파일을 <code class=\"language-text\">require()</code>할 수</li>\n</ul>\n<p>이로 인해 라이브러리 개발자들은 보통 다음 중 하나를 선택해야 했다.</p>\n<ul>\n<li>CommonJS 지원을 포기하고 ESM만 제공</li>\n<li>ESM과 CommonJS를 모두 지원하기 위해 \"이중 배포(ESM과 CommonJS에 각각 별도의 진입점 제공)\"\n<ul>\n<li>복잡하고 오류가 발생하기 쉬움</li>\n<li>패키지 코드량이 거의 2배로 증가</li>\n</ul>\n</li>\n<li>그냥 CommonJS만 계속 유지</li>\n</ul>\n<p>Node.js 22에서는 이러한 제한 사항이 완화되어 CommonJS 모듈에서 <code class=\"language-text\">require(\"esm\")</code>을 통해 ESM 모듈을 가져올 수 있다. 다만 <code class=\"language-text\">top-level await</code>이 포함된 ESM 파일은 여전히 <code class=\"language-text\">require()</code>로 가져올 수 없다.</p>\n<p>TypeScript 5.8에서는 <code class=\"language-text\">--module nodenext</code> 옵션을 사용할 경우 CommonJS에서 ESM 파일을 <code class=\"language-text\">require()</code> 하는 코드에 대해 오류를 발생시키지 않는다.</p>\n<p>미래의 TypeScript 버전에서는 <code class=\"language-text\">node20</code> 버전 이하에서도 이 기능을 안정적으로 제공할 가능성이 있다. 따라서 현재의 권장사항은 다음과 같다.</p>\n<ul>\n<li>Node.js 22 이상을 사용하는 경우 -> <code class=\"language-text\">--module nodenext</code> 사용</li>\n<li>이전 버전의 Node.js를 사용하는 경우\n<ul>\n<li>기존의 <code class=\"language-text\">--module node16</code> 유지</li>\n<li>혹은 <code class=\"language-text\">--module node18</code>로 업그레이드</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"--module-node18-지원\"><code class=\"language-text\">--module node18</code> 지원</h2>\n<p>TypeScript 5.8에서는 새로운 안정적인 <code class=\"language-text\">--module node18</code> 플래그를 도입했다. 이 옵션은 Node.js 18을 고정적으로 사용하는 유저들에게 일관된 동작을 보장한다.</p>\n<p>--module node18 vs. --module nodenext 비교</p>\n<table>\n<thead>\n<tr>\n<th>기능</th>\n<th><code class=\"language-text\">--module node18</code></th>\n<th><code class=\"language-text\">--module nodenext</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CommonJS에서 ESM require()</td>\n<td>❌ (불가능)</td>\n<td>✅ (가능)</td>\n</tr>\n<tr>\n<td>import 어설션 (import assertions) 지원</td>\n<td>✅ (가능)</td>\n<td>❌ (불가능, import 속성으로 대체됨)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"--erasablesyntaxonly-옵션\">``--erasableSyntaxOnly` 옵션</h2>\n<p>최근 Node.js 23.6에선 TypeScript 파일을 직접 실행할 수 있도록 하는 실험적 기능이 플래그 없이 제공되었다. 하지만 이 모드에서는 특정 TypeScript 문법만 지원한다.</p>\n<p>Node.js에서는 <code class=\"language-text\">--experimental-strip-types</code> 모드를 도입했는데, 이 ㅁ드에서는 TypeScript 전용 문법이 런타임 동작을 가지면 안된다. 즉 TypeScript 문법을 지워도 유효한 JS 코드가 남아있어야 한다.</p>\n<p>아래와 같은 런타임에서 의미를 가지는 TypeScript 문법은 지원되지 않는다.</p>\n<ul>\n<li><code class=\"language-text\">enum</code> 선언</li>\n<li><code class=\"language-text\">namespaces</code> 및 런타임 코드를 포함한 <code class=\"language-text\">module</code></li>\n<li>클래스의 매개변수 속성</li>\n<li><code class=\"language-text\">import =</code> 형식의 별칭</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ❌ error: A namespace with runtime code.</span>\n<span class=\"token keyword\">namespace</span> container <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Bar</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ❌ error: An `import =` alias</span>\n<span class=\"token keyword\">import</span> Bar <span class=\"token operator\">=</span> container<span class=\"token punctuation\">.</span>Bar<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ❌ error: Parameter properties</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ❌ error: An enum declaration.</span>\n<span class=\"token keyword\">enum</span> Direction <span class=\"token punctuation\">{</span>\n    Up<span class=\"token punctuation\">,</span>\n    Down<span class=\"token punctuation\">,</span>\n    Left<span class=\"token punctuation\">,</span>\n    Right<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기존 <code class=\"language-text\">ts-blank-space</code>나 <code class=\"language-text\">Amaro</code>(Node.js에서 타입 제거를 담당하는 라이브러리)와 같은 유사한 도구들은 오류 메시지를 제공하지만 실제로 코드를 실행해보기 전까지는 코드가 동작하지 않는다는 사실을 알 수 없다.</p>\n<p>TypeScript 5.8 에서는 <code class=\"language-text\">--erasableSyntaxOnly</code> 도입해 이 플래그가 활성화되면 런타임 동작을 가지는 대부분의 TypeScript 전용 문법에 대해 오류를 발생시킨다.</p>\n<p>권장 옵션 조합</p>\n<ul>\n<li><code class=\"language-text\">--erasableSyntaxOnly</code></li>\n<li><code class=\"language-text\">--verbatimModuleSyntax</code> (모듈의 import 문법을 강제하고, import 생략을 방지)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token comment\">//          ~~~~~~~~~~~~~~~~</span>\n    <span class=\"token comment\">// error! This syntax is not allowed when 'erasableSyntaxOnly' is enabled.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"--libreplacement-플래그\"><code class=\"language-text\">--libReplacement</code> 플래그</h2>\n<p>TypeScript 4.5에서 기본 <code class=\"language-text\">lib</code> 파일을 사용자 정의 파일로 대체할 수 있는 기능을 도입했다. 이는 <code class=\"language-text\">@typescript/lib-*</code> 패키지에서 라이브러리 파일을 가져올 수 있도록 하는 방식에 기반한다.</p>\n<p>예를들어 <code class=\"language-text\">@types/web</code> 패키지의 특정 버전의 DOM 라이브러리를 고정하려면 다음과 같이 <code class=\"language-text\">package.json</code>을 설정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"devDependencies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token property\">\"@typescript/lib-dom\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm:@types/web@0.0.199\"</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 패키지가 설치되면 TypeScript는 <code class=\"language-text\">dom</code> 라이브러리를 포함하는 설정이 있을 경우 항상 해당 패키지를 조회한다.</p>\n<p>이 기능은 강력하지만 추가적인 성능 비용이 발생한다.</p>\n<ul>\n<li>해당 기능을 사용하지 않더라도 TypeScript는 항상 이 라이브러리를 찾으려고 시도한다.</li>\n<li>또한 <code class=\"language-text\">node_modules</code>을 감시하여 새로운 라이브러리 대체 패키지가 추가되었는지 확인해야 한다.</li>\n</ul>\n<p>TypeScript 5.8에는 이 동작을 비활성화할 수 있는 <code class=\"language-text\">--libReplacement</code> 플래그가 도입되었다.</p>\n<ul>\n<li>기본적으로 --libReplacement<code class=\"language-text\">를 사용하지 않는다면, --libReplacement false</code> 옵션을 설정하여 이 동작을 비활성화할 수 있다.</li>\n<li>현재 이 기능을 사용하는 경우, <code class=\"language-text\">--libReplacement true</code>를 명시적으로 설정하는 것이 좋다.</li>\n<li>향후 TypeScript에서 <code class=\"language-text\">--libReplacement false</code>가 기본값이 될 가능성이 높으므로, 이 기능이 필요하다면 명시적으로 활성화해야 한다.</li>\n</ul>\n<h2 id=\"선언-파일에서-계산된-프로퍼티-이름-보존\">선언 파일에서 계산된 프로퍼티 이름 보존</h2>\n<p>선언 파일에서 계산된 프로퍼티를 보다 예측 가능하게 만들기 위해 TypeScript 5.8은 클래스의 계산된 프로퍼티 이름(<code class=\"language-text\">bareVariables</code>나 <code class=\"language-text\">dotted.names.that.look.like.this</code>와 같은 엔터티)을 일관되게 보존한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 이전 버전의 TypeScript에선 이 모듈에 대한 선언 파일 생성 시 오류 발생</span>\n<span class=\"token comment\">// 최선의 노력으로 index signature를 생성함</span>\n<span class=\"token comment\">// [propName] 부분을 [x: string]: number와 같은 인덱스 시그니처 생성</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> propName <span class=\"token operator\">=</span> <span class=\"token string\">\"theAnswer\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//  ~~~~~~~~~~</span>\n<span class=\"token comment\">// error!</span>\n<span class=\"token comment\">// A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type.</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\">// TypeScript 5.8에서 아래 예제는 허용되고 선언 파일을 작성한 내용과 일치</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 기능은 클래스에 정적으로 이름이 지정된 프로퍼티를 생성하지 않는다. 여전히 <code class=\"language-text\">[x: string]: number</code>와 같은 인덱스 시그니처 형태로 출력된다.\n따라서 이 경우에는 <code class=\"language-text\">unique symbols</code>이나 리터럴 타입을 사용해야 할 수 있다.</p>\n<p>현재 <code class=\"language-text\">--isolatedDeclarations</code> 플래그 아래에서는 이 코드를 작성하는 것이 오류로 처리된다. 하지만 이번 변경 덕분에, 계산된 프로퍼티 이름이 선언 파일에서 일반적으로 허용될 것으로 예상된다.</p>\n<p>또한, TypeScript 5.8에서 컴파일된 파일이 TypeScript 5.7 이하 버전과 호환되지 않는 선언 파일을 생성할 가능성도 있지만, 이는 드물게 발생할 것이다.</p>","frontmatter":{"date":"25.03.01","description":"TypeScript 5.8 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42mOwD9z6n5qYga4GOgRBsGPwNggO2gbmk22gjd+W/9a+m/9b+Wz6bwWmN/+38d1CnoG2/lv+R2cd+B+fd/B/WsmR/ynFh/+nAumY7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg/+j825wDY5bi8TtDLlkBvmntt+m/hDcEgr1MUy7BIgUUQRZEyKNIhABp8yGCqIO1VAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["Typescript","번역"],"title":"TypeScript 5.8 번역"},"tableOfContents":"<ul>\n<li><a href=\"#%EB%B0%98%ED%99%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B8%EB%B6%84%ED%99%94%EB%90%9C-%EA%B2%80%ED%86%A0\">반환 표현식에서의 세분화된 검토</a></li>\n<li><a href=\"#--module-nodenext%EC%97%90%EC%84%9C-ecmascript-%EB%AA%A8%EB%93%88%EC%9D%98-require-%EC%A7%80%EC%9B%90\"><code class=\"language-text\">--module nodenext</code>에서 ECMAScript 모듈의 <code class=\"language-text\">require()</code> 지원</a></li>\n<li><a href=\"#--module-node18-%EC%A7%80%EC%9B%90\"><code class=\"language-text\">--module node18</code> 지원</a></li>\n<li><a href=\"#--erasablesyntaxonly-%EC%98%B5%EC%85%98\">``--erasableSyntaxOnly` 옵션</a></li>\n<li><a href=\"#--libreplacement-%ED%94%8C%EB%9E%98%EA%B7%B8\"><code class=\"language-text\">--libReplacement</code> 플래그</a></li>\n<li><a href=\"#%EC%84%A0%EC%96%B8-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EA%B3%84%EC%82%B0%EB%90%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9D%B4%EB%A6%84-%EB%B3%B4%EC%A1%B4\">선언 파일에서 계산된 프로퍼티 이름 보존</a></li>\n</ul>"}},"pageContext":{"id":"2a937397-78c7-5ca1-9c48-3e916aebb541","frontmatter__slug":"/translate-ts-5-8","previous":null,"previousTitle":null,"next":"/translate-ts-5-7","nextTitle":"TypeScript 5.7 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}