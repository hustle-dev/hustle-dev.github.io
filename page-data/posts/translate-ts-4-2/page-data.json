{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-4-2/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html</a></p>\n</blockquote>\n<h2 id=\"더-스마트한-타입-별칭-보존\">더 스마트한 타입 별칭 보존</h2>\n<p>타입스크립트에는 타입 별칭이라고 하는 타입의 새 이름을 선언하는 방법이 있다. <code class=\"language-text\">string | number | boolean</code>에서 모두 작동하는 함수 집합을 작성하는 경우 타입 별칭을 작성하여 반복되는 작업을 피할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">BasicPrimitive</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>TS는 타입을 출력할 때, 타입 별칭을 재사용할 시점에 대해 항상 일련의 규칙과 추측을 사용했다. 예를 들어 다음 코드 스니펫을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">BasicPrimitive</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> BasicPrimitive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Visual Studio, Visual Studio Code 또는 TypeScript Playground와 같은 편집기에서 마우스 커서를 <code class=\"language-text\">x</code>로 가져가면 <code class=\"language-text\">BasicPrimitive</code> 타입이 표시된 빠른 정보 패널이 나타난다. 마찬가지로 이 파일에 대한 선언 파일 출력(<code class=\"language-text\">.d.ts</code> 출력)을 가져오는 경우 TypeScript는 <code class=\"language-text\">doStuff</code>가 <code class=\"language-text\">BasicPrimitive</code>를 반환한다고 말한다.</p>\n<p>하지만 <code class=\"language-text\">BasicPrimitive</code> 혹은 <code class=\"language-text\">undefined</code>를 반환하는 경우 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">BasicPrimitive</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> BasicPrimitive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeScript 4.1 플레이그라운드에서 어떤 일이 일어나는지 확인할 수 있다.\nTypeScript가 <code class=\"language-text\">doStuff</code>의 반환 타입을 <code class=\"language-text\">BasicPrimitive | undefined</code>으로 표시하기를 원하지만, 대신 <code class=\"language-text\">string | number | boolean | undefined</code>으로 표시된다! 왜 그럴까?</p>\n<p>이는 타입스크립트가 내부적으로 타입을 표현하는 방식과 관련이 있다. 하나 이상의 유니온 타입에서 유니온 타입을 생성할 때 항상 해당 타입을 새로운 flattened된 유니온 유형으로 정규화하지만 그렇게 하면 정보가 손실된다. 타입체커는 <code class=\"language-text\">tring | number | boolean | undefined</code>에서 모든 타입 조합을 찾아서 어떤 타입 별칭이 사용되었는지 확인해야 하며, 그 경우에도 <code class=\"language-text\">tring | number | boolean</code>에 대한 여러 타입 별칭이 있을 수 있다.</p>\n<p>TypeScript 4.2에서는 내부가 좀 더 스마트해졌다. 시간이 지남에 따라 타입이 원래 어떻게 작성되고 구성되었는지에 대한 부분을 유지함으로써 타입이 어떻게 구성되었는지 추적할 수 있다. 또한 타입 별칭을 추적하고 다른 별칭의 인스턴스와 구별한다!</p>\n<p>코드에서 사용한 방식에 따라 유형을 다시 출력할 수 있다는 것은 TypeScript 사용자로서 안타깝게도 많은 타입이 표시되는 것을 피할 수 있다는 의미이며, 이는 종종 빠른 정보 및 서명 도움말에서 <code class=\"language-text\">.d.ts</code> 파일 출력, 오류 메시지 및 편집기 내 타입 표시가 개선되는 것으로 해석된다. 이를 통해 TypeScript를 처음 접하는 분들에게 조금 더 친근하게 다가갈 수 있다.</p>\n<h2 id=\"튜플-타입의-첫중간-나머지-요소\">튜플 타입의 첫/중간 나머지 요소</h2>\n<p>TS에서 튜플 타입은 특정 길이와 요소 타입을 가진 배열을 모델링하기 위한 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// A tuple that stores a pair of numbers</span>\n<span class=\"token keyword\">let</span> a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// A tuple that stores a string, a number, and a boolean</span>\n<span class=\"token keyword\">let</span> b<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>시간이 지남에 따라 TypeScript의 튜플 타입은 JavaScript의 매개변수 목록과 같은 것을 모델링하는 데에도 사용되기 때문에 점점 더 정교해졌다. 그 결과 선택적 요소와 나머지 요소를 가질 수 있고, 도구와 가독성을 위한 레이블을 가질 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// A tuple that has either one or two strings.</span>\n<span class=\"token keyword\">let</span> c<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nc <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// A labeled tuple that has either one or two strings.</span>\n<span class=\"token keyword\">let</span> d<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>first<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> second<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nd <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// A tuple with a *rest element* - holds at least 2 strings at the front,</span>\n<span class=\"token comment\">// and any number of booleans at the back.</span>\n<span class=\"token keyword\">let</span> e<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token builtin\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\ne <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\ne <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\ne <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>TypeScript 4.2에서는 rest 요소의 사용 방법이 특히 확장되었다. 이전 버전에서 TypeScript는 튜플 타입의 맨 마지막 위치에만 <code class=\"language-text\">...rest</code> 요소를 허용했다.</p>\n<p>그러나 이제 몇 가지 제한 사항만 적용하면 튜플 내 어느 위치에서나 rest 요소를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nfoo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">123</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nfoo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">123</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nfoo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'hello!'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hello!'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hello!'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">123</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nbar <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nbar <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'some text'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nbar <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'some'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'separated'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>유일한 제한 사항은 다른 선택적 요소나 나머지 요소가 뒤에 오지 않는 한 나머지 요소는 튜플의 어느 곳에나 배치할 수 있다는 것이다. 즉, 튜플당 rest 요소는 하나만 있고 rest 요소 뒤에는 선택 요소가 없어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Clown</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Joker</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> StealersWheel<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>Clown<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'me'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>Joker<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// A rest element cannot follow another rest element.</span>\n\n<span class=\"token keyword\">let</span> StringsAndMaybeBoolean<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// An optional element cannot follow a rest element.</span></code></pre></div>\n<p>이러한 후행이 아닌 rest 요소는 몇 개의 선행 인수와 몇 개의 고정 인수가 뒤따르는 함수를 모델링하는 데 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>names<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> shouldCapitalize<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/*shouldCapitalize:*/</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fee'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'fi'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'fo'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'fum'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/*shouldCapitalize:*/</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>JavaScript에는 선행 rest 매개변수를 모델링하는 구문이 없지만, 선행 rest 요소를 사용하는 튜플 타입으로 <code class=\"language-text\">...args</code> rest 매개변수를 선언하여 선행 인수를 취하는 함수로 <code class=\"language-text\">doStuff</code>를 선언할 수 있었다. 이렇게 하면 기존의 많은 자바스크립트를 모델링하는 데 도움이 될 수 있다!</p>\n<h2 id=\"in-연산자에-대한-더-엄격한-검사\"><code class=\"language-text\">in</code> 연산자에 대한 더 엄격한 검사</h2>\n<p>JS에서 <code class=\"language-text\">in</code> 연산자의 오른쪽에 객체가 아닌 타입을 사용하는 것은 런타임 에러이다. TypeScript 4.2에서는 이를 디자인 타임(코드를 작성하는 순간)에 포착할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token string\">'foo'</span> <span class=\"token keyword\">in</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// The right-hand side of an 'in' expression must not be a primitive.</span></code></pre></div>\n<p>이 검사는 대부분 상당히 보수적이므로 이와 관련된 오류가 발생하면 코드에 문제가 있는 것일 수 있다.</p>\n<h2 id=\"--nopropertyaccessfromindexsignature\"><code class=\"language-text\">--noPropertyAccessFromIndexSignature</code></h2>\n<p>TypeScript가 처음 인덱스 시그니처를 도입했을 때만 해도 <code class=\"language-text\">person[\"name\"]</code>과 같이 '괄호로 묶인' 엘리먼트 액세스 구문을 사용하여 선언된 프로퍼티만 가져올 수 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">SomeType</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** This is an index signature. */</span>\n  <span class=\"token punctuation\">[</span>propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> SomeType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> value<span class=\"token punctuation\">[</span><span class=\"token string\">'someProperty'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 임의의 속성을 가진 객체로 작업해야 하는 상황에서 번거로웠다. 예를 들어, 프로퍼티 이름 끝에 <code class=\"language-text\">s</code>를 추가하여 철자를 잘못 입력하는 것이 일반적인 API를 상상해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Options</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** File patterns to be excluded. */</span>\n  exclude<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/**\n   * It handles any extra properties that we haven't declared as type 'any'.\n   */</span>\n  <span class=\"token punctuation\">[</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOptions</span><span class=\"token punctuation\">(</span>opts<span class=\"token operator\">:</span> Options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Notice we're *intentionally* accessing `excludes`, not `exclude`</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>excludes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'The option `excludes` is not valid. Did you mean `exclude`?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이러한 상황을 더 쉽게 처리하기 위해 얼마 전 TypeScript는 타입에 문자열 인덱스 시그니처가 있는 경우 <code class=\"language-text\">person.name</code>과 같은 \"점선\" 속성 액세스 구문을 사용할 수 있도록 했다. 이를 통해 기존 JavaScript 코드를 TypeScript로 쉽게 전환할 수 있게 되었다.</p>\n<p>그러나 제한이 완화되면서 명시적으로 선언된 프로퍼티의 철자를 잘못 입력하는 것이 훨씬 쉬워졌다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">processOptions</span><span class=\"token punctuation\">(</span>opts<span class=\"token operator\">:</span> Options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token comment\">// Notice we're *accidentally* accessing `excludes` this time.</span>\n  <span class=\"token comment\">// Oops! Totally valid.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> excludePattern <span class=\"token keyword\">of</span> opts<span class=\"token punctuation\">.</span>excludes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>어떤 경우에는 사용자가 인덱스 시그니처를 명시적으로 선택하기를 원할 수도 있다. 점으로 표시된 속성 액세스가 특정 속성 선언과 일치하지 않을 때 오류 메시지가 표시되기를 원하기 때문이다.</p>\n<p>이것이 바로 TypeScript가 <code class=\"language-text\">noPropertyAccessFromIndexSignature</code>라는 새로운 플래그를 도입한 이유이다. 이 모드에서는 오류를 발생시키는 TypeScript의 이전 동작을 선택하게 됩니다. 이 새로운 설정은 사용자가 특정 코드베이스에서 다른 코드베이스보다 더 유용하다고 생각하기 때문에 엄격한 플래그 계열에 속하지 않았다.</p>\n<h2 id=\"abstract-생성자-시그니처\"><code class=\"language-text\">abstract</code> 생성자 시그니처</h2>\n<p>타입스크립트에서는 클래스를 <code class=\"language-text\">abstract</code>으로 표시할 수 있다. 이는 TypeScript가 클래스를 확장하기 위한 용도로만 사용되며, 실제로 인스턴스를 생성하려면 특정 멤버를 서브클래스에서 채워야 한다는 것을 알려준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Shape</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Shape</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Cannot create an instance of an abstract class.</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Shape</span> <span class=\"token punctuation\">{</span>\n  #sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#sideLength <span class=\"token operator\">=</span> sideLength<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#sideLength <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Works fine.</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Square</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">abstract</code> 클래스를 새로 생성할 때 이러한 제한이 일관되게 적용되도록 하려면 생성자 시그니처가 필요한 모든 항목에 추상 클래스를 할당할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">HasArea</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> Ctor<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> HasArea <span class=\"token operator\">=</span> Shape<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Type 'typeof Shape' is not assignable to type 'new () => HasArea'.</span>\n<span class=\"token comment\">//  Cannot assign an abstract constructor type to a non-abstract constructor type.</span></code></pre></div>\n<p>이는 <code class=\"language-text\">new Ctor</code>와 같은 코드를 실행하려는 경우에는 올바르게 작동하지만, <code class=\"language-text\">Ctor</code>의 서브클래스를 작성하려는 경우에는 지나치게 제한적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Shape</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">HasArea</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeSubclassWithArea</span><span class=\"token punctuation\">(</span>Ctor<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> HasArea<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token keyword\">extends</span></span> Ctor <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> MyShape <span class=\"token operator\">=</span> <span class=\"token function\">makeSubclassWithArea</span><span class=\"token punctuation\">(</span>Shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.</span>\n<span class=\"token comment\">//  Cannot assign an abstract constructor type to a non-abstract constructor type.</span></code></pre></div>\n<p>또한 <code class=\"language-text\">InstanceType</code>과 같은 기본 제공 헬퍼 유형에서는 잘 작동하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">MyInstance</span> <span class=\"token operator\">=</span> InstanceType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> Shape<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이것이 바로 타입스크립트 4.2에서 생성자 시그니처에 <code class=\"language-text\">abstract</code> 수정자를 지정할 수 있는 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">HasArea</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Works!</span>\n<span class=\"token keyword\">let</span> Ctor<span class=\"token operator\">:</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> HasArea <span class=\"token operator\">=</span> Shape<span class=\"token punctuation\">;</span></code></pre></div>\n<p>생성자 시그니처에 <code class=\"language-text\">abstract</code> 수정자를 추가하면 <code class=\"language-text\">abstract</code> 생성자에서 전달할 수 있다는 신호가 된다. \"구체적인\" 다른 클래스/생성자 함수를 전달하는 것을 막는 것이 아니라, 생성자를 직접 실행할 의도가 없다는 신호일 뿐이므로 어느 클래스 유형으로 전달해도 안전하다.</p>\n<p>이 기능을 사용하면 추상 클래스를 지원하는 방식으로 믹스인 팩토리를 작성할 수 있다. 예를 들어, 다음 코드 스니펫에서는 믹스인 함수 <code class=\"language-text\">withStyles</code>를 <code class=\"language-text\">abstract</code> 클래스 <code class=\"language-text\">SuperClass</code>와 함께 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SuperClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">badda</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AbstractConstructor<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">withStyles</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> AbstractConstructor<span class=\"token operator\">&lt;</span>object<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>Ctor<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StyledClass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Ctor</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getStyles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> StyledClass<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SubClass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">withStyles</span><span class=\"token punctuation\">(</span>SuperClass<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">withStyles</code>은 일반적이고 추상 생성자(예: <code class=\"language-text\">Ctor</code>)에 의해 경계가 지정된 값을 확장하는 클래스(예: <code class=\"language-text\">StyledClass</code>)도 추상적으로 선언해야 한다는 특정 규칙을 보여드리고 있다는 점에 유의하자. 추상 멤버가 더 많은 클래스가 전달되었는지 알 수 있는 방법이 없기 때문에 하위 클래스가 모든 추상 멤버를 구현하는지 여부를 알 수 없기 때문이다.</p>\n<h2 id=\"--explainfiles를-사용하여-프로젝ㅌ-구조-이해하기\"><code class=\"language-text\">--explainFiles</code>를 사용하여 프로젝ㅌ 구조 이해하기</h2>\n<p>타입스크립트 사용자들이 의외로 흔히 하는 질문은 \"왜 타입스크립트에 이 파일이 포함되나요?\"이다. 프로그램의 파일을 추론하는 것은 복잡한 과정이기 때문에 특정 조합의 <code class=\"language-text\">lib.d.ts</code>가 사용된 이유, <code class=\"language-text\">node_modules</code>의 특정 파일이 포함된 이유, <code class=\"language-text\">exclude</code>를 지정하면 제외될 줄 알았는데 특정 파일이 포함된 이유 등 여러 가지 이유가 있을 수 있다.</p>\n<p>이것이 바로 TypeScript가 이제 <code class=\"language-text\">explainFiles</code> 플래그를 제공하는 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">tsc <span class=\"token parameter variable\">--explainFiles</span></code></pre></div>\n<p>이 옵션을 사용하면 TypeScript 컴파일러에서 파일이 프로그램에 포함된 이유에 대한 매우 자세한 출력을 제공한다. 이 출력을 더 쉽게 읽으려면 출력을 파일로 전달하거나 쉽게 볼 수 있는 프로그램으로 파이프할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Forward output to a text file</span>\ntsc <span class=\"token parameter variable\">--explainFiles</span> <span class=\"token operator\">></span> explanation.txt\n\n<span class=\"token comment\"># Pipe output to a utility program like `less`, or an editor like VS Code</span>\ntsc <span class=\"token parameter variable\">--explainFiles</span> <span class=\"token operator\">|</span> <span class=\"token function\">less</span>\n\ntsc <span class=\"token parameter variable\">--explainFiles</span> <span class=\"token operator\">|</span> code -</code></pre></div>\n<p>일반적으로 출력은 <code class=\"language-text\">lib.d.ts</code> 파일을 포함해야 하는 이유를 나열하는 것으로 시작하여 로컬 파일, <code class=\"language-text\">node_modules</code> 파일 순으로 나열한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">TS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts\n  Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts\n  Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts\n  Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts\n  Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts\n  Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts\n  Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts\n  Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts\n  Library 'lib.esnext.d.ts' specified in compilerOptions\n\n... More Library References...\n\nfoo.ts\n  Matched by include pattern '**/*' in 'tsconfig.json'</code></pre></div>\n<p>현재로서는 출력 형식에 대해 보장할 수 없으며 시간이 지남에 따라 변경될 수 있다.</p>\n<h2 id=\"논리-표현식에서-호출되지-않은-함수-검사-기능-개선\">논리 표현식에서 호출되지 않은 함수 검사 기능 개선</h2>\n<p>TS의 호출되지 않은 함수 검사가 <code class=\"language-text\">&amp;&amp;</code> 및 <code class=\"language-text\">||</code> 표현식 내에 적용된다.</p>\n<p><code class=\"language-text\">strictNullChecks</code>에서는 이제 다음 코드에서 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">shouldDisplayElement</span><span class=\"token punctuation\">(</span>element<span class=\"token operator\">:</span> Element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getVisibleItems</span><span class=\"token punctuation\">(</span>elements<span class=\"token operator\">:</span> Element<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> elements<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> shouldDisplayElement <span class=\"token operator\">&amp;&amp;</span> e<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//                          ~~~~~~~~~~~~~~~~~~~~</span>\n  <span class=\"token comment\">// This condition will always return true since the function is always defined.</span>\n  <span class=\"token comment\">// Did you mean to call it instead.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"디스트럭처링된-변수를-명시적으로-미사용으로-표시할-수-있다\">디스트럭처링된 변수를 명시적으로 미사용으로 표시할 수 있다</h2>\n<p>이제 디스트럭처링된 변수 앞에 밑줄(<code class=\"language-text\">_</code> 문자)을 붙여 사용하지 않는 것으로 표시할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>_first<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">getValues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이전에는 <code class=\"language-text\">_first</code>가 나중에 한 번도 사용되지 않으면 TypeScript가 <code class=\"language-text\">noUnusedLocals</code>에서 오류를 발생시켰다. 이제 TypeScript는 <code class=\"language-text\">_first</code>를 사용할 의도가 없었기 때문에 의도적으로 밑줄을 넣어 명명했음을 인식한다.</p>\n<h2 id=\"선택적-속성과-문자열-인덱스-시그니처-간의-완화된-규칙\">선택적 속성과 문자열 인덱스 시그니처 간의 완화된 규칙</h2>\n<p>문자열 인덱스 시그니처는 임의의 키로 액세스를 허용하려는 사전과 같은 객체를 입력하는 방식이다</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> movieWatchCount<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">watchMovie</span><span class=\"token punctuation\">(</span>title<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  movieWatchCount<span class=\"token punctuation\">[</span>title<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>movieWatchCount<span class=\"token punctuation\">[</span>title<span class=\"token punctuation\">]</span> <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>물론 아직 사전에 없는 영화 제목의 경우 <code class=\"language-text\">movieWatchCount[title]</code>은 <code class=\"language-text\">undefined</code>이다(TypeScript 4.1에서는 이와 같은 인덱스 시그니처에서 읽을 때 <code class=\"language-text\">undefined</code>을 포함하도록 <code class=\"language-text\">noUncheckedIndexedAccess</code> 옵션이 추가되었다). <code class=\"language-text\">movieWatchCount</code>에 존재하지 않는 문자열이 있어야 한다는 것이 분명하지만, 이전 버전의 TypeScript에서는 <code class=\"language-text\">undefined</code>이기 때문에 선택적 객체 속성을 다른 호환 가능한 인덱스 시그니처에 할당할 수 없는 것으로 처리했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">WesAndersonWatchCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'Fantastic Mr. Fox'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token string\">'The Royal Tenenbaums'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token string\">'Moonrise Kingdom'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token string\">'The Grand Budapest Hotel'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> wesAndersonWatchCount<span class=\"token operator\">:</span> WesAndersonWatchCount<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> movieWatchCount<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> wesAndersonWatchCount<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ~~~~~~~~~~~~~~~ error!</span>\n<span class=\"token comment\">// Type 'WesAndersonWatchCount' is not assignable to type '{ [key: string]: number; }'.</span>\n<span class=\"token comment\">//    Property '\"Fantastic Mr. Fox\"' is incompatible with index signature.</span>\n<span class=\"token comment\">//      Type 'number | undefined' is not assignable to type 'number'.</span>\n<span class=\"token comment\">//        Type 'undefined' is not assignable to type 'number'. (2322)</span></code></pre></div>\n<p>타입스크립트 4.2에서는 이 할당이 허용된다. 그러나 타입이 <code class=\"language-text\">undefined</code>와 함께 비선택적 속성의 할당은 허용되지 않으며, 특정 키에 <code class=\"language-text\">undefined</code> 쓰기도 허용되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">BatmanWatchCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"Batman Begins\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n  <span class=\"token string-property property\">\"The Dark Knight\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n  <span class=\"token string-property property\">\"The Dark Knight Rises\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> batmanWatchCount<span class=\"token operator\">:</span> BatmanWatchCount<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Still an error in TypeScript 4.2.</span>\n<span class=\"token keyword\">const</span> movieWatchCount<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> batmanWatchCount<span class=\"token punctuation\">;</span>\nType <span class=\"token string\">'BatmanWatchCount'</span> <span class=\"token keyword\">is</span> not assignable to <span class=\"token keyword\">type</span> <span class=\"token string\">'{ [key: string]: number; }'</span><span class=\"token punctuation\">.</span>\n  Property <span class=\"token string\">'\"Batman Begins\"'</span> <span class=\"token keyword\">is</span> incompatible <span class=\"token keyword\">with</span> index signature<span class=\"token punctuation\">.</span>\n    Type <span class=\"token string\">'number | undefined'</span> <span class=\"token keyword\">is</span> not assignable to <span class=\"token keyword\">type</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">.</span>\n      Type <span class=\"token string\">'undefined'</span> <span class=\"token keyword\">is</span> not assignable to <span class=\"token keyword\">type</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token comment\">// Still an error in TypeScript 4.2.</span>\n<span class=\"token comment\">// Index signatures don't implicitly allow explicit `undefined`.</span>\nmovieWatchCount<span class=\"token punctuation\">[</span><span class=\"token string\">\"It's the Great Pumpkin, Charlie Brown\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\nType <span class=\"token string\">'undefined'</span> <span class=\"token keyword\">is</span> not assignable to <span class=\"token keyword\">type</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>숫자 인덱스 시그니처는 배열과 유사하고 밀도가 높다고 가정하므로 새 규칙은 숫자 인덱스 시그니처에는 적용되지 않는다</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> sortOfArrayish<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> numberKeys<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">42</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nsortOfArrayish <span class=\"token operator\">=</span> numberKeys<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//  Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.</span>\n<span class=\"token comment\">//  Property '42' is incompatible with index signature.</span>\n<span class=\"token comment\">//    Type 'string | undefined' is not assignable to type 'string'.</span>\n<span class=\"token comment\">//      Type 'undefined' is not assignable to type 'string'.</span></code></pre></div>\n<h2 id=\"누락된-헬퍼-함수-선언\">누락된 헬퍼 함수 선언</h2>\n<p>이제 호출한 코드를 기반으로 새로운 함수와 메서드를 선언할 수 있는 빠른 수정 기능이 추가되었다!</p>\n<h2 id=\"주요-변경-사항\">주요 변경 사항</h2>\n<p>TS 4.2에는 몇 가지 중요한 변경 사항이 포함되어 있지만 업그레이드에서 관리할 수 있는 수준이라고 생각한다.</p>\n<h3 id=\"libdts-updates\"><code class=\"language-text\">lib.d.ts</code> Updates</h3>\n<p>모든 타입스크립트 버전과 마찬가지로 <code class=\"language-text\">lib.d.ts</code>의 선언(특히 웹 컨텍스트에 대해 생성된 선언)이 변경되었다. 여러 가지 변경 사항이 있지만 <code class=\"language-text\">Intl</code>과 <code class=\"language-text\">ResizeObserver</code>의 변경 사항이 가장 큰 영향을 미칠 수 있다.</p>\n<h3 id=\"noimplicitany-에러가-느슨한-yield-표현식에-적용\"><code class=\"language-text\">noImplicitAny</code> 에러가 느슨한 <code class=\"language-text\">yield</code> 표현식에 적용</h3>\n<p><code class=\"language-text\">yield</code> 표현식의 값이 캡처되었지만 TypeScript가 수신하려는 타입을 즉시 파악할 수 없는 경우(즉, <code class=\"language-text\">yield</code> 표현식이 컨텍스트에 맞게 타입화되지 않은 경우) 이제 TypeScript에서 암시적 오류를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">g1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'yield'</span> expression implicitly results <span class=\"token keyword\">in</span> an <span class=\"token string\">'any'</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">because</span> its containing generator lacks a <span class=\"token keyword\">return</span><span class=\"token operator\">-</span><span class=\"token keyword\">type</span> <span class=\"token class-name\">annotation</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">g2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// No error.</span>\n  <span class=\"token comment\">// The result of `yield 1` is unused.</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">g3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// No error.</span>\n  <span class=\"token comment\">// `yield 1` is contextually typed by 'string'.</span>\n  <span class=\"token keyword\">const</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">g4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Generator<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// No error.</span>\n  <span class=\"token comment\">// TypeScript can figure out the type of `yield 1`</span>\n  <span class=\"token comment\">// from the explicit return type of `g4`.</span>\n  <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"확장된-호출되지-않은-함수-검사\">확장된 호출되지 않은 함수 검사</h3>\n<p>위에서 설명한 대로, 이제 <code class=\"language-text\">strictNullChecks</code>를 사용할 때 호출되지 않은 함수 검사가 <code class=\"language-text\">&amp;&amp;</code> 및 <code class=\"language-text\">||</code> 표현식 내에서 일관되게 작동한다. 이는 새로운 중단의 원인이 될 수 있지만 일반적으로 기존 코드의 논리 오류를 나타냅니다.</p>\n<h3 id=\"javascript의-타입-인수가-타입-인수로-파싱되지-않음\">JavaScript의 타입 인수가 타입 인수로 파싱되지 않음</h3>\n<p>자바스크립트에서는 이미 타입 인수가 허용되지 않았지만, 타입스크립트 4.2에서는 파서가 보다 사양을 준수하는 방식으로 타입 인수를 구문 분석한다. 따라서 JavaScript 파일에 다음 코드를 작성할 때</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">f <span class=\"token operator\">&lt;</span> <span class=\"token constant\">T</span> <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>TypeScript는 이를 다음과 같은 자바스크립트로 구문 분석한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">f <span class=\"token operator\">&lt;</span> <span class=\"token constant\">T</span> <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 문제는 자바스크립트 파일의 타입 구문을 구문 분석하기 위해 타입스크립트 API를 사용하는 경우 영향을 미칠 수 있으며, 이는 Flow 파일을 구문 분석하려고 할 때 발생할 수 있다.</p>\n<h3 id=\"스프레드에-대한-튜플-크기-제한\">스프레드에 대한 튜플 크기 제한</h3>\n<p>타입스크립트에서 스프레드 구문 (<code class=\"language-text\">...</code>)을 사용하여 튜플 유형을 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Tuple types with spread elements</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">NumStr</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">NumStrNumStr</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>NumStr<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>NumStr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Array spread expressions</span>\n<span class=\"token keyword\">const</span> numStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">123</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> numStrNumStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>numStr<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>numStr<span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>때때로 이러한 튜플 타입은 실수로 커질 수 있으며, 이로 인해 타입 검사에 오랜 시간이 걸릴 수 있다. 타입 검사 프로세스가 중단되는 대신(편집기 시나리오에서 특히 나쁘다), 타입스크립트에는 이 모든 작업을 수행하지 않도록 하는 리미터가 있다.</p>\n<h3 id=\"가져오기-경로에-dts-확장자를-사용할-수-없음\">가져오기 경로에 <code class=\"language-text\">.d.ts</code> 확장자를 사용할 수 없음</h3>\n<p>TypeScript 4.2에서는 이제 가져오기 경로의 확장자에 .d.ts가 포함되는 것이 오류이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// must be changed something like</span>\n<span class=\"token comment\">//   - \"./foo\"</span>\n<span class=\"token comment\">//   - \"./foo.js\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./foo.d.ts'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>대신, 임포트 경로는 런타임에 로더가 수행하는 모든 작업을 반영해야 한다. 다음 임포트를 대신 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./foo.js'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./foo/index.js'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"템플릿-리터럴-추론-되돌리기\">템플릿 리터럴 추론 되돌리기</h3>\n<p>이 변경으로 인해 TypeScript 4.2 베타 버전에서 기능이 제거되었다. 마지막 안정 릴리스 이후 아직 업그레이드하지 않았다면 영향을 받지 않지만 변경 사항에 관심이 있을 수 있다.</p>\n<p>TypeScript 4.2 베타 버전에는 템플릿 문자열에 대한 추론 기능이 변경되었다. 이 변경 사항에서는 템플릿 문자열 리터럴에 템플릿 문자열 유형이 주어지거나 여러 문자열 리터럴 유형으로 단순화된다. 그런 다음 이러한 타입은 가변 변수에 할당할 때 <code class=\"language-text\">string</code>으로 확장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> yourName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'bar' is constant.</span>\n<span class=\"token comment\">// It has type '`hello ${string}`'.</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>yourName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'baz' is mutable.</span>\n<span class=\"token comment\">// It has type 'string'.</span>\n<span class=\"token keyword\">let</span> baz <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>yourName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 문자열 리터럴 추론이 작동하는 방식과 유사하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 'bar' has type '\"hello\"'.</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'baz' has type 'string'.</span>\n<span class=\"token keyword\">let</span> baz <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이러한 이유로 템플릿 문자열 표현식에 템플릿 문자열 타입이 있으면 '일관성'이 유지될 것이라고 생각했지만, 보고 들은 바에 따르면 이것이 항상 바람직한 것은 아니다.</p>\n<p>이에 따라 이 기능(그리고 잠재적인 변경 사항)을 되돌렸다. 템플릿 문자열 표현식에 리터럴과 유사한 타입을 부여하고 싶다면 언제든지 표현식 끝에 const를 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> yourName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'bar' has type '`hello ${string}`'.</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>yourName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//                              ^^^^^^^^</span>\n<span class=\"token comment\">// 'baz' has type 'string'.</span>\n<span class=\"token keyword\">const</span> baz <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>yourName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"visitnode안의-타입스크립트의-lift-콜백은-다른-타입을-사용\"><code class=\"language-text\">visitNode</code>안의 타입스크립트의 <code class=\"language-text\">lift</code> 콜백은 다른 타입을 사용</h3>\n<p>타입스크립트에는 <code class=\"language-text\">lift</code> 함수를 받는 <code class=\"language-text\">visitNode</code> 함수가 있다. 이제 <code class=\"language-text\">lift</code>는 <code class=\"language-text\">NodeArray&lt;Node></code> 대신 <code class=\"language-text\">readonly Node[]</code>를 기대한다. 이는 기술적으로 API를 깨는 변경 사항으로, 자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/42000\">여기</a>에서 확인할 수 있다.</p>","frontmatter":{"date":"23.03.04","description":"TypeScript 4.2 Release를 번역하면서 어떤 기능들이 전에 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42mOwD9z6n5qYgW4G2gVsgbMdgrb+dwiEYHQ5ogyEabD23fzf0nvTfwvvTXDaymczXA02g3G60NZ/y/+ozP3/43IP/k8tPvw/ufDw/5Tiw/+jsvb/t/HbQrqXQZqCk/f8z6489j+99Mj/+LyD/zPKjv6PyT7w39pvM3letvHb/N/SZ9N/cy+IdynyMkakQDFZkUJIE1kGkpsOAVDDx+dN5GA6AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 4.2 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%8D%94-%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%95%9C-%ED%83%80%EC%9E%85-%EB%B3%84%EC%B9%AD-%EB%B3%B4%EC%A1%B4\">더 스마트한 타입 별칭 보존</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8A%9C%ED%94%8C-%ED%83%80%EC%9E%85%EC%9D%98-%EC%B2%AB%EC%A4%91%EA%B0%84-%EB%82%98%EB%A8%B8%EC%A7%80-%EC%9A%94%EC%86%8C\">튜플 타입의 첫/중간 나머지 요소</a></p>\n</li>\n<li>\n<p><a href=\"#in-%EC%97%B0%EC%82%B0%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8D%94-%EC%97%84%EA%B2%A9%ED%95%9C-%EA%B2%80%EC%82%AC\"><code class=\"language-text\">in</code> 연산자에 대한 더 엄격한 검사</a></p>\n</li>\n<li>\n<p><a href=\"#--nopropertyaccessfromindexsignature\"><code class=\"language-text\">--noPropertyAccessFromIndexSignature</code></a></p>\n</li>\n<li>\n<p><a href=\"#abstract-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98\"><code class=\"language-text\">abstract</code> 생성자 시그니처</a></p>\n</li>\n<li>\n<p><a href=\"#--explainfiles%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%E3%85%8C-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\"><code class=\"language-text\">--explainFiles</code>를 사용하여 프로젝ㅌ 구조 이해하기</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%85%BC%EB%A6%AC-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90%EC%84%9C-%ED%98%B8%EC%B6%9C%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%ED%95%A8%EC%88%98-%EA%B2%80%EC%82%AC-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EC%84%A0\">논리 표현식에서 호출되지 않은 함수 검사 기능 개선</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81%EB%90%9C-%EB%B3%80%EC%88%98%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%AF%B8%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">디스트럭처링된 변수를 명시적으로 미사용으로 표시할 수 있다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%ED%83%9D%EC%A0%81-%EC%86%8D%EC%84%B1%EA%B3%BC-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EA%B0%84%EC%9D%98-%EC%99%84%ED%99%94%EB%90%9C-%EA%B7%9C%EC%B9%99\">선택적 속성과 문자열 인덱스 시그니처 간의 완화된 규칙</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%88%84%EB%9D%BD%EB%90%9C-%ED%97%AC%ED%8D%BC-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8\">누락된 헬퍼 함수 선언</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9A%94-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD\">주요 변경 사항</a></p>\n<ul>\n<li><a href=\"#libdts-updates\"><code class=\"language-text\">lib.d.ts</code> Updates</a></li>\n<li><a href=\"#noimplicitany-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%8A%90%EC%8A%A8%ED%95%9C-yield-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%EC%A0%81%EC%9A%A9\"><code class=\"language-text\">noImplicitAny</code> 에러가 느슨한 <code class=\"language-text\">yield</code> 표현식에 적용</a></li>\n<li><a href=\"#%ED%99%95%EC%9E%A5%EB%90%9C-%ED%98%B8%EC%B6%9C%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%ED%95%A8%EC%88%98-%EA%B2%80%EC%82%AC\">확장된 호출되지 않은 함수 검사</a></li>\n<li><a href=\"#javascript%EC%9D%98-%ED%83%80%EC%9E%85-%EC%9D%B8%EC%88%98%EA%B0%80-%ED%83%80%EC%9E%85-%EC%9D%B8%EC%88%98%EB%A1%9C-%ED%8C%8C%EC%8B%B1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%8C\">JavaScript의 타입 인수가 타입 인수로 파싱되지 않음</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%ED%8A%9C%ED%94%8C-%ED%81%AC%EA%B8%B0-%EC%A0%9C%ED%95%9C\">스프레드에 대한 튜플 크기 제한</a></li>\n<li><a href=\"#%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0-%EA%B2%BD%EB%A1%9C%EC%97%90-dts-%ED%99%95%EC%9E%A5%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%97%86%EC%9D%8C\">가져오기 경로에 <code class=\"language-text\">.d.ts</code> 확장자를 사용할 수 없음</a></li>\n<li><a href=\"#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%B6%94%EB%A1%A0-%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0\">템플릿 리터럴 추론 되돌리기</a></li>\n<li><a href=\"#visitnode%EC%95%88%EC%9D%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-lift-%EC%BD%9C%EB%B0%B1%EC%9D%80-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9\"><code class=\"language-text\">visitNode</code>안의 타입스크립트의 <code class=\"language-text\">lift</code> 콜백은 다른 타입을 사용</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"87d274bf-f670-5a7a-bc1b-6fa32076586c","frontmatter__slug":"/translate-ts-4-2","previous":"/translate-ts-4-3","previousTitle":"TypeScript 4.3 번역","next":"/translate-ts-4-1","nextTitle":"TypeScript 4.1 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}