{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-6/","result":{"data":{"markdownRemark":{"html":"<!-- 썸네일 -->\n<!-- 본문 -->\n<blockquote>\n<p>TypeScript 5.6에서 중요하다고 생각되는 부분을 번역했습니다. 더 자세한 글은 아래 원글 링크를 참고해주세요.\r\n<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/\">https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/</a></p>\n</blockquote>\n<h2 id=\"허용되지-않는-nullish-및-truthy-검사\">허용되지 않는 Nullish 및 Truthy 검사</h2>\n<p>아래 코드들은 모두 유효한 JS 코드여서 이전에는 TS가 허용했지만 5.6부터는 오류를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">0x[0-9a-f]</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">//  ~~~~~~~~~~~~</span>\r\n<span class=\"token comment\">// error: This kind of expression is always truthy.</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">//  ~~~~~~</span>\r\n<span class=\"token comment\">// error: This kind of expression is always truthy.</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> options<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> strictness<span class=\"token operator\">:</span> <span class=\"token string\">\"strict\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"loose\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>strictness <span class=\"token operator\">===</span> <span class=\"token string\">\"loose\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        value <span class=\"token operator\">=</span> <span class=\"token operator\">+</span>value\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">return</span> value <span class=\"token operator\">&lt;</span> options<span class=\"token punctuation\">.</span>max <span class=\"token operator\">??</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">//     ~~~~~~~~~~~~~~~~~~~</span>\r\n    <span class=\"token comment\">// error: Right operand of ?? is unreachable because the left operand is never nullish.</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\r\n    <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>primaryValue<span class=\"token punctuation\">,</span> <span class=\"token string\">\"strict\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>secondaryValue<span class=\"token punctuation\">,</span> <span class=\"token string\">\"strict\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\r\n    <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>primaryValue<span class=\"token punctuation\">,</span> <span class=\"token string\">\"loose\"</span> <span class=\"token operator\">||</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>secondaryValue<span class=\"token punctuation\">,</span> <span class=\"token string\">\"loose\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">//                    ~~~~~~~</span>\r\n    <span class=\"token comment\">// error: This kind of expression is always truthy.</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이와 비슷한 결과는 ESLint의 <code class=\"language-text\">no-constant-binary-expression</code> 규칙을 활성화해 얻을 수 있지만 TS에서 수행하는 검사 규칙과 완전히 일치하지는 않는다.</p>\n<p>코드를 반복 및 디버깅시에 유용한 표현식들은 항상 <code class=\"language-text\">truthy</code>한 값이나 <code class=\"language-text\">nullish</code>로 평가되더라도 여전히 허용된다.</p>\n<p>코드 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">doOtherStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span> <span class=\"token operator\">||</span> <span class=\"token function\">inDebuggingOrDevelopmentEnvironment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"iterator-헬퍼-메서드\">Iterator 헬퍼 메서드</h2>\n<p>많은 사람들이 배열에서 자주 사용하는 <code class=\"language-text\">map</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">reduce</code> 메서드를 <code class=\"language-text\">Iterable</code> 및 <code class=\"language-text\">IterableIterator</code> 에서 사용할 수 없다는 점을 아쉬워했다. 이를 해결하기 위해 <a href=\"https://github.com/tc39/proposal-iterator-helpers\">ECMAScript에서는 JavaScript에서 생성된 대부분의 <code class=\"language-text\">IterableIterator</code>에 배열 메서드들을 추가하는 제안</a>이 최근에 제출되었다.</p>\n<p>이제 모든 제너레이터는 <code class=\"language-text\">map</code> 메서드와 <code class=\"language-text\">take</code> 메서드를 가진 객체를 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">positiveIntegers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">yield</span> i<span class=\"token punctuation\">;</span>\r\n        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">const</span> evenNumbers <span class=\"token operator\">=</span> <span class=\"token function\">positiveIntegers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Output:</span>\r\n<span class=\"token comment\">//    2</span>\r\n<span class=\"token comment\">//    4</span>\r\n<span class=\"token comment\">//    6</span>\r\n<span class=\"token comment\">//    8</span>\r\n<span class=\"token comment\">//   10</span>\r\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> value <span class=\"token keyword\">of</span> evenNumbers<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Map</code>과 <code class=\"language-text\">Set</code>의 <code class=\"language-text\">key()</code>, <code class=\"language-text\">values()</code>, <code class=\"language-text\">entries()</code>와 같은 메서드들 모두 마찬가지이다.</p>\n<blockquote>\n<p><code class=\"language-text\">key()</code>, <code class=\"language-text\">values()</code>, <code class=\"language-text\">entries()</code> 메서드들 모두 <code class=\"language-text\">Iterator</code> 객체를 반환함.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">invertKeysAndValues</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>map<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>\r\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Iterator</code> 객체를 <code class=\"language-text\">extend</code>할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\r\n * Provides an endless stream of `0`s.\r\n */</span>\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Zeroes</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Iterator<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">const</span> zeroes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Zeroes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Transform into an endless stream of `1`s.</span>\r\n<span class=\"token keyword\">const</span> ones <span class=\"token operator\">=</span> zeroes<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n</code></pre></div>\n<p>그리고 기존 이터러블이나 이터레이터를 <code class=\"language-text\">Iterator.from</code>을 사용해 이 새로운 타입에 적용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">Iterator<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>someFunction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 새로운 메서드들은 최신 JavaScript 런타임에서 실행하거나 새로운 <code class=\"language-text\">Iterator</code> 객체에 대한 폴리필을 사용할 경우 모두 정상적으로 동작한다.</p>\n<p><code class=\"language-text\">Iterable</code>과 <code class=\"language-text\">Iterator</code>에 대한 TypeScript 타입이 있지만 이 타입이 모든 메서드를 구현하는 것은 아니다.</p>\n<p>문제가 되는 부분은 JS 런타임에서 <code class=\"language-text\">Iterator</code>라는 실제 값이 존재한다는 것이다. 이 부분과 TS의 타입 검사 용도의 <code class=\"language-text\">Iterator</code>의 이름이 충돌한다.</p>\n<p>이러한 충돌을 해결하기 위해 TypeScript는 별도의 타입인 <code class=\"language-text\">IteratorObject</code>를 도입했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IteratorObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">,</span> TNext <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Iterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token punctuation\">,</span> TNext<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IteratorObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn<span class=\"token punctuation\">,</span> TNext<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>많은 내장 컬레션과 메서드들은 <code class=\"language-text\">IteratorObject</code>의 하위 타입들을 생성한다. 예를들어 <code class=\"language-text\">ArrayIterator</code>, <code class=\"language-text\">SetIterator</code>, <code class=\"language-text\">MapIterator</code>등이 있으며 <code class=\"language-text\">lib.d.ts</code>의 핵심 JS 및 DOM 타입들과 함께 <code class=\"language-text\">@types/node</code>도 이 새로운 타입을 사용하도록 업데이트 되었다.</p>\n<p>마찬가지로, <code class=\"language-text\">AsyncIteratorObject</code> 타입도 추가되었다. 이는 <code class=\"language-text\">AsyncIterator</code>를 위한 런타임 값으로 아직 존재하지 않지만, <code class=\"language-text\">AsyncIterable</code>s 에 동일한 메서드를 제공하기 위한 제안이 활발히 진행 중이며, 이 새로운 타입은 이를 대비한 것이다.</p>\n<h2 id=\"엄격한-내장-iterator-검사--strictbuiltiniteratorreturn\">엄격한 내장 Iterator 검사(<code class=\"language-text\">--strictBuiltinIteratorReturn</code>)</h2>\n<p><code class=\"language-text\">Iterator&lt;T, TReturn></code>에서 <code class=\"language-text\">next()</code> 메서드를 호출하면 메서드는 <code class=\"language-text\">value</code>와 <code class=\"language-text\">done</code> 속성을 가진 객체를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">IteratorResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TReturn <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> IteratorYieldResult<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> IteratorReturnResult<span class=\"token operator\">&lt;</span>TReturn<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IteratorYieldResult<span class=\"token operator\">&lt;</span>TYield<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    done<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\r\n    value<span class=\"token operator\">:</span> TYield<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IteratorReturnResult<span class=\"token operator\">&lt;</span>TReturn<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\r\n    value<span class=\"token operator\">:</span> TReturn<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>새로운 <code class=\"language-text\">IteratorObject</code> 타입을 도입하면서 안전하게 이를 구현하는데 몇 가지 어려움을 발견했다. <code class=\"language-text\">IteratorResult</code>의 <code class=\"language-text\">TReturn</code>이 <code class=\"language-text\">any</code>인 경우 이 타입의 <code class=\"language-text\">value</code>는 단순히 <code class=\"language-text\">any</code>가 되어버린다.</p>\n<p>결국 타입 시스템에서 <code class=\"language-text\">value</code>가 구체적으로 어떤 값인지 알 수 없기에 예기치 않은 문제를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">uppercase</span><span class=\"token punctuation\">(</span>iter<span class=\"token operator\">:</span> Iterator<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> done <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">yield</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// oops! forgot to check for `done` first and misspelled `toUpperCase`</span>\r\n\r\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeScript 5.6은 <code class=\"language-text\">BuiltinIteratorReturn</code>이라는 새로운 내장 타입과 <code class=\"language-text\">--strictBuiltinIteratorReturn</code>이라는 새로운 <code class=\"language-text\">--strict</code> 모드 플래그를 도입했다. <code class=\"language-text\">lib.d.ts</code>와 같은 곳에서 <code class=\"language-text\">IteratorObject</code>가 사용될 때는 항상 <code class=\"language-text\">TReturn</code>을 위한 타입으로 <code class=\"language-text\">BuiltinIteratorReturn</code>이 사용된다(하지만 더 구체적인 <code class=\"language-text\">MapIterator</code>, <code class=\"language-text\">ArrayIterator</code>, <code class=\"language-text\">SetIterator</code>와 같은 타입을 더 자주 보게 될 것이다).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">MapIterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IteratorObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> BuiltinIteratorReturn<span class=\"token punctuation\">,</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MapIterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// ...</span>\r\n\r\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Map<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n\r\n    <span class=\"token comment\">/**\r\n     * Returns an iterable of key, value pairs for every entry in the map.\r\n     */</span>\r\n    <span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MapIterator<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">/**\r\n     * Returns an iterable of keys in the map\r\n     */</span>\r\n    <span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MapIterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">/**\r\n     * Returns an iterable of values in the map\r\n     */</span>\r\n    <span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MapIterator<span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기본적으로, <code class=\"language-text\">BuiltinIteratorReturn</code> <code class=\"language-text\">any</code>로 설정되지만, <code class=\"language-text\">--strictBuiltinIteratorReturn</code> 플래그가 활성화되면(또는 <code class=\"language-text\">--strict</code> 플래그를 통해 가능), 이 값은 <code class=\"language-text\">undefined</code>로 설정된다. 이 새로운 모드에서 <code class=\"language-text\">BuiltinIteratorReturn</code>을 사용할 경우, 이전에 언급한 예시는 이제 올바르게 오류를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">uppercase</span><span class=\"token punctuation\">(</span>iter<span class=\"token operator\">:</span> Iterator<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> BuiltinIteratorReturn<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> done <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">yield</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">//    ~~~~~ ~~~~~~~~~~~</span>\r\n        <span class=\"token comment\">// error! ┃      ┃</span>\r\n        <span class=\"token comment\">//        ┃      ┗━ Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</span>\r\n        <span class=\"token comment\">//        ┃</span>\r\n        <span class=\"token comment\">//        ┗━ 'value' is possibly 'undefined'.</span>\r\n\r\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">lib.d.ts</code> 전반에서 <code class=\"language-text\">BuiltinIteratorReturn</code>이 <code class=\"language-text\">IteratorObject</code>와 함께 사용되는 것을 자주 볼 수 있다. 가능하다면 자신의 코드에서 <code class=\"language-text\">TReturn</code>에 대해 더 명시적으로 정의하는 것을 권장한다.</p>\n<h2 id=\"임의의-모듈-식별자-지원\">임의의 모듈 식별자 지원</h2>\n<p>JS는 모듈이 문자열 리터럴로 유효하지 않은 식별자 이름을 내보내는 것을 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> banana <span class=\"token operator\">=</span> <span class=\"token string\">\"🍌\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> banana <span class=\"token keyword\">as</span> <span class=\"token string\">\"🍌\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 이런 모듈에서 <code class=\"language-text\">import</code> 하여 유효한 식별자에 바인딩 하는것도 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">\"🍌\"</span> <span class=\"token keyword\">as</span> banana <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./foo\"</span>\r\n\r\n<span class=\"token comment\">/**\r\n * om nom nom\r\n */</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span>food<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Eating\"</span><span class=\"token punctuation\">,</span> food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token function\">eat</span><span class=\"token punctuation\">(</span>banana<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이러한 기능은 다른 언어와의 상호 운용성을 위해 유용하다.(특히 JavaScript ↔ WebAssembly 경계에서) 왜냐하면 다른 언어들은 유효한 식별자에 대한 규칙이 다를 수 있기 때문이다.</p>\n<p>TypeScript 5.6에서는 이러한 임의의 모듈 식별자를 코드에서 사용할 수 있다.</p>\n<h2 id=\"--nouncheckedsideeffectimports-옵션\"><code class=\"language-text\">--noUncheckedSideEffectImports</code> 옵션</h2>\n<p>JS에선 실제로 값을 가져오지 않고도 모듈을 import 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token string\">\"some-module\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 import를 <em>side effect import</em>라고 부른다.</p>\n<p>TS에선 이런 모듈을 import 시에 소스 파일이 없는 경우에도 해당 import를 무시했다. 이는 JS 생태계에서 사용되는 패턴을 모델링하는 데서 일부 기인한다.</p>\n<p>아래와 같은 구문은 번들러에서 CSS나 다른 에셋을 로드하기 위한 특수 로더와 함께 사용되기도 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token string\">\"./button-component.css\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Button</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 이는 이런 <em>side effect import</em>에서 발생할 수 있는 오타를 감추게 된다. 이런 이유로 TS 5.6은 새로운 컴파일러 옵션인 <code class=\"language-text\">--noUncheckedSideEffectImports</code>를 도입하여 이러한 경우를 잡아낸다.</p>\n<p>이 옵션이 활성화되면 TS는 <em>side effect import</em>에 대한 소스 파일을 찾지 못할 경우 오류를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token string\">\"oops-this-module-does-not-exist\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\r\n<span class=\"token comment\">// error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations.</span></code></pre></div>\n<p>이 옵션을 활성화화면 위 CSS 예시처럼 정상적으로 동작하던 코드에서 오류가 날 수 있다. 이런 경우 아래와 같이 와일드카드 지정자를 사용한 <em>ambient 모듈 선언</em>을 작성하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ./src/globals.d.ts</span>\r\n\r\n<span class=\"token comment\">// Recognize all CSS files as module imports.</span>\r\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">module</span> <span class=\"token string\">\"*.css\"</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>실제로 프로젝트에 이미 이러한 파일이 존재할 수 있다. <code class=\"language-text\">vite init</code>과 같은 명령을 실행해 비슷한 파일인 <code class=\"language-text\">vite-env.d.ts</code>가 생성될 수 있다.</p>\n<h2 id=\"--nocheck-옵션\"><code class=\"language-text\">--noCheck</code> 옵션</h2>\n<p>TypeScript 5.6은 새로운 컴파일러 옵션으로 <code class=\"language-text\">--noCheck</code>를 도입했다. 이는 모든 입력 파일에 대한 타입 검사를 건너뛸 수 있고, 이를 통해 출력 파일을 생성할 때 불필요한 타입검사를 피할 수 있다.</p>\n<p>사용 사례</p>\n<ul>\n<li>JS 파일 생성을 타입 검사와 별도로 실행\n<ul>\n<li>개발 중엔 <code class=\"language-text\">tsc --noCheck</code>를 사용해 빠르게 빌드</li>\n<li>나중에 <code class=\"language-text\">tsc --noEmit</code>을 실행해 철저한 타입검사 수행</li>\n<li>이 둘을 병렬로도 실행할 수 있고 <code class=\"language-text\">--watch</code> 모드에서도 가능하며 동시에 실행 시 <code class=\"language-text\">--tsBuildInfoFile</code> 경로를 지정하는 것이 좋음</li>\n</ul>\n</li>\n<li>선언 파일 생성 시 활용\n<ul>\n<li><code class=\"language-text\">isolatedDeclarations</code>를 사용하는 프로젝트에서 <code class=\"language-text\">--noCheck</code> 사용 시 타입 검사를 건너뛰고 빠르게 파일 선언 파일 생성(생성된 선언 파일은 빠른 구문 변환에 의존)</li>\n<li><code class=\"language-text\">isolatedDeclarations</code>를 사용하지 않는 경우 <code class=\"language-text\">.d.ts</code> 파일을 생성하기 위해 필요한 최소한의 타입 검사를 수행할 수 있음</li>\n<li>이 옵션은 TS API에서도 사용할 수 있고 내부적으로 <code class=\"language-text\">transpileModule</code>과 <code class=\"language-text\">transpileDeclaration</code>은 이미 이를 사용해 속도를 향상시키고 있음</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"--build에서-중간-오류-허용\"><code class=\"language-text\">--build</code>에서 중간 오류 허용</h2>\n<p>TypeScript 5.6에서는 중간 의존성에 오류가 있더라도 프로젝트 빌드를 계속 진행할 수 있다.</p>\n<p>빌드를 오류 발생 시 중단하려면 <code class=\"language-text\">--stopOnBuildErrors</code> 플래그를 사용할 수 있다. 이는 CI 환경에서나 다른 프로젝트가 많이 의존하는 프로젝트를 작업할때 유용하다.</p>\n<h2 id=\"에디터에서-지역-우선-진단\">에디터에서 지역 우선 진단</h2>\n<p>TypeScript 5.6에서는 <strong>지역 우선 진단</strong> 기능을 도입해 사용자가 보고 있는 특정 부분에 대한 진단을 요청할 수 있도록 한다. 이를 통해 큰 파일에서 딜레이가 발생하는 것을 방지할 수 있다.</p>\n<p>따라서 TypeScript 언어 서버는 지역 진단, 파일 전체에 대한 두 가지 진단 세트를 제공한다.</p>\n<h2 id=\"granular-commit-characters\">Granular Commit Characters</h2>\n<p>TS 언어 서비스는 각 자동 완성 항목에 대해 고유의 커밋 문자를 제공한다. 커밋 문자는 특정 문자를 입력 시 현재 제안된 자동 완성 항목을 확정하는데 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> food<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>foo<span class=\"token comment\">/**/</span></code></pre></div>\n<p>우리가 작성 중인 코드가 <code class=\"language-text\">let f = (food.eat())</code> 또는 <code class=\"language-let f = (foo, bar) =\"> foo + bar</code>와 같은 것일 수 있다. 입력하는 문자에 따라 자동 완성 동작이 달라질 수 있다. 만약 <code class=\"language-text\">.</code>을 입력하면 <code class=\"language-text\">food</code>가 자동 완성되고, <code class=\"language-text\">,</code>를 입력하면 화살표 함수의 매개변수를 작성 중일 가능성이 높다.</p>\n<p>이제 TypeScript는 각 자동 완성 항목에 대해 안전한 커밋 문자를 명시적으로 제공한다.</p>\n<p>이를 통해 에디터가 자동 완성 항목을 더 자주 확정할 수 있고, VSCode Insiders에서 TS nightly 버전을 사용할 경우 이러한 개선 사항을 즉시 경험할 수 있다.</p>\n<h2 id=\"auto-import에서-제외-패턴-지원\">Auto-Import에서 제외 패턴 지원</h2>\n<p>TS 언어 서비스는 특정 규칙에 맞는 import 제안을 필터링할 수 있는 정규 표현식 패턴을 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// `lodash`와 같은 패키지에서 \"deepl\" import 제외하기 위한 설정</span>\r\n<span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"typescript.preferences.autoImportSpecifierExcludeRegexes\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/lodash/\"</span><span class=\"token punctuation\">]</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// 엔트리 포인트에서 가져오기를 허용하지 않는 설정</span>\r\n<span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"typescript.preferences.autoImportSpecifierExcludeRegexes\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n        <span class=\"token string\">\"^lodash$\"</span>\r\n    <span class=\"token punctuation\">]</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// `node:` import를 피하는 설정</span>\r\n<span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"typescript.preferences.autoImportSpecifierExcludeRegexes\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n        <span class=\"token string\">\"^node:\"</span>\r\n    <span class=\"token punctuation\">]</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">i</code>나 <code class=\"language-text\">u</code> 같은 정규픽 플래그를 지정하려면 정규식을 슬래시로 둘러싸야한다. 주변 슬래시를 제공할 때는 다른 내부 슬래시를 이스케이프 처리해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"typescript.preferences.autoImportSpecifierExcludeRegexes\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n        <span class=\"token string\">\"^./lib/internal\"</span><span class=\"token punctuation\">,</span>        <span class=\"token comment\">// no escaping needed</span>\r\n        <span class=\"token string\">\"/^.\\\\/lib\\\\/internal/\"</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// escaping needed - note the leading and trailing slashes</span>\r\n        <span class=\"token string\">\"/^.\\\\/lib\\\\/internal/i\"</span>  <span class=\"token comment\">// escaping needed - we needed slashes to provide the 'i' regex flag</span>\r\n    <span class=\"token punctuation\">]</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>VSCode의 <code class=\"language-text\">javascript.preferences.autoImportSpecifierExcludeRegexes</code> 통해 JS에도 동일한 설정을 적용할 수 있다.</p>\n<h2 id=\"주목할-만한-동작-변경\">주목할 만한 동작 변경</h2>\n<h3 id=\"tsbuildinfo-는-항상-생성\"><code class=\"language-text\">.tsbuildinfo</code> 는 항상 생성</h3>\n<p>종속성에서 중간 오류가 발생하더라도 <code class=\"language-text\">--build</code>가 프로젝트를 계속 빌드할 수 있도록 하고 명령줄에서 <code class=\"language-text\">--noCheck</code>를 지원하기 위해 TS는 <code class=\"language-text\">--build</code> 호출에서 모든 프로젝트에 대해 항상 <code class=\"language-text\">.tsbuildinfo</code> 파일을 생성한다.</p>\n<h3 id=\"node_modules-내부의-파일-확장자와-packagejson의-처리\"><code class=\"language-text\">node_modules</code> 내부의 파일 확장자와 <code class=\"language-text\">package.json</code>의 처리</h3>\n<p>Node.js 12버전에서 ECMAScript 모듈에 대한 지원을 구현하기 전엔 TS가 <code class=\"language-text\">node_mdules</code>에서 찾은 <code class=\"language-text\">.d.ts</code> 파일이 CommonJS로 작성된 JS 파일인지 ECMASCRipt 모듈인지 TS가 알 수 있는 방법이 없었다. npm의 대부분이 CommonJS만을 사용하던 시절에는 큰 문제가 없었는데, 그럴 경우 TypeScript는 모든 것이 CommonJS처럼 동작한다고 가정할 수 있었다. 그러나 이 가정이 잘못된 경우, 안전하지 않은 import를 허용할 수 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// node_modules/dep/index.d.ts</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// index.ts</span>\r\n<span class=\"token comment\">// Okay if \"dep\" is a CommonJS module, but fails if</span>\r\n<span class=\"token comment\">// it's an ECMAScript module - even in bundlers!</span>\r\n<span class=\"token keyword\">import</span> dep <span class=\"token keyword\">from</span> <span class=\"token string\">\"dep\"</span><span class=\"token punctuation\">;</span>\r\ndep<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실제로 이러한 문제가 자주 발생하지는 않았지만, Node.js가 ECMAScript 모듈을 지원하기 시작한 이후로 npm에서 ESM의 비중이 증가했다. 다행히도, Node.js는 TypeScript가 파일이 ECMAScript 모듈인지 CommonJS 모듈인지를 판단하는 데 도움이 되는 메커니즘을 도입했다. 이는 <code class=\"language-text\">.mjs</code> 및 <code class=\"language-text\">.cjs</code> 파일 확장자와 <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">\"type\"</code> 필드를 사용하는 것이다. TypeScript 4.7에서는 이러한 지표를 이해하고 <code class=\"language-text\">.mts</code> 및 <code class=\"language-text\">.cts</code> 파일을 작성하는 지원이 추가되었지만, 이는 <code class=\"language-text\">--module node16</code> 및 <code class=\"language-text\">--module nodenext</code> 옵션에서만 적용되었다. 따라서 <code class=\"language-text\">--module esnext</code> 및 <code class=\"language-text\">--moduleResolution bundler</code>를 사용하는 경우에는 여전히 안전하지 않은 import 문제가 남아 있었다.</p>\n<p>이를 해결하기 위해 TypeScript 5.6은 모든 모듈 모드에서(amd, umd, system을 제외하고) 모듈 형식 정보를 수집하고 이를 사용하여 위의 예와 같은 모호성을 해결한다. <code class=\"language-text\">.mts</code> 및 <code class=\"language-text\">.cts</code>와 같은 형식별 파일 확장자는 발견된 모든 곳에서 고려되며, <code class=\"language-text\">node_modules</code> 내부의 종속성에 있는 <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">\"type\"</code> 필드도 모듈 설정과 관계없이 참조된다.</p>\n<p>이전에는 CommonJS 출력을 <code class=\"language-text\">.mjs</code> 파일로 생성하거나 그 반대로 생성하는 것이 기술적으로 가능했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// main.mts</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token string\">\"oops\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// $ tsc --module commonjs main.mts</span>\r\n<span class=\"token comment\">// main.mjs</span>\r\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>exports<span class=\"token punctuation\">,</span> <span class=\"token string\">\"__esModule\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nexports<span class=\"token punctuation\">.</span>default <span class=\"token operator\">=</span> <span class=\"token string\">\"oops\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 이제 <code class=\"language-text\">.mts</code> 파일은 절대 CommonJS 출력을 생성하지 않으며, <code class=\"language-text\">.cts</code> 파일은 절대 ESM 출력을 생성하지 않는다.</p>\n<p>이러한 동작의 대부분은 TypeScript 5.5의 사전 릴리스 버전에서 이미 제공되었지만, TypeScript 5.6에서는 이 동작이 <code class=\"language-text\">node_modules</code> 내부의 파일로 확장되었다</p>\n<h2 id=\"computed-properties의-올바른-override-검사\">Computed Properties의 올바른 override 검사</h2>\n<p>이전에는 <code class=\"language-text\">override</code>로 표시된 계산된 속성(computed properties)이 상위 클래스 멤버의 존재 여부를 올바르게 확인하지 않았다. 또한, <code class=\"language-text\">noImplicitOverride</code> 옵션을 사용한 경우에도 계산된 속성에 <code class=\"language-text\">override</code> 수식자를 추가하지 않아도 오류가 발생하지 않았다.</p>\n<p>TypeScript 5.6에서는 이 두 가지 경우 모두에 대해 계산된 속성을 올바르게 검사한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">[</span>bar<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    override <span class=\"token punctuation\">[</span>foo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\r\n<span class=\"token comment\">//           ~~~~~</span>\r\n<span class=\"token comment\">// 오류: 이 멤버는 기본 클래스 'Base'에 선언되어 있지 않으므로 'override' 수식자를 가질 수 없습니다.</span>\r\n\r\n    <span class=\"token punctuation\">[</span>bar<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\r\n<span class=\"token comment\">//  ~~~~~</span>\r\n<span class=\"token comment\">// noImplicitOverride 옵션이 활성화된 경우의 오류: 이 멤버는 기본 클래스 'Base'의 멤버를 재정의하므로 'override' 수식자를 가져야 합니다.</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 TypeScript는 <code class=\"language-text\">override</code> 수식자가 잘못된 곳에 사용되거나 필요한 곳에 누락된 경우를 정확하게 잡아낸다. 이러한 개선은 상속 구조에서 메서드 오버라이딩과 관련된 잠재적인 버그를 사전에 방지하는 데 도움이 된다.</p>","frontmatter":{"date":"24.09.17","description":"TypeScript 5.6 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVR42mOwCtpDNmKgvmbrYBCyCdkLQmA2CZrN/Xeb+e028d1l6rcLSALZxGq2CNgdln0sOv94UunJhOKTQDI85xhQ0JpIzf4phzOrzySXnYopOJ5ScToi9xjQLZiOx+lsoGuNvHca+4AQ0PGkhTYkwCAhR1qA0SOeAcffA3lILlLfAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/8cd737fd0b788260edc7a8720216bdad/18b2e/heroImage.png","srcSet":"/static/8cd737fd0b788260edc7a8720216bdad/a4d46/heroImage.png 175w,\n/static/8cd737fd0b788260edc7a8720216bdad/d8f52/heroImage.png 350w,\n/static/8cd737fd0b788260edc7a8720216bdad/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/8cd737fd0b788260edc7a8720216bdad/eac4f/heroImage.webp 175w,\n/static/8cd737fd0b788260edc7a8720216bdad/a4795/heroImage.webp 350w,\n/static/8cd737fd0b788260edc7a8720216bdad/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["Typescript","번역"],"title":"TypeScript 5.6 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%97%88%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-nullish-%EB%B0%8F-truthy-%EA%B2%80%EC%82%AC\">허용되지 않는 Nullish 및 Truthy 검사</a></p>\n</li>\n<li>\n<p><a href=\"#iterator-%ED%97%AC%ED%8D%BC-%EB%A9%94%EC%84%9C%EB%93%9C\">Iterator 헬퍼 메서드</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EB%82%B4%EC%9E%A5-iterator-%EA%B2%80%EC%82%AC--strictbuiltiniteratorreturn\">엄격한 내장 Iterator 검사(<code class=\"language-text\">--strictBuiltinIteratorReturn</code>)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%84%EC%9D%98%EC%9D%98-%EB%AA%A8%EB%93%88-%EC%8B%9D%EB%B3%84%EC%9E%90-%EC%A7%80%EC%9B%90\">임의의 모듈 식별자 지원</a></p>\n</li>\n<li>\n<p><a href=\"#--nouncheckedsideeffectimports-%EC%98%B5%EC%85%98\"><code class=\"language-text\">--noUncheckedSideEffectImports</code> 옵션</a></p>\n</li>\n<li>\n<p><a href=\"#--nocheck-%EC%98%B5%EC%85%98\"><code class=\"language-text\">--noCheck</code> 옵션</a></p>\n</li>\n<li>\n<p><a href=\"#--build%EC%97%90%EC%84%9C-%EC%A4%91%EA%B0%84-%EC%98%A4%EB%A5%98-%ED%97%88%EC%9A%A9\"><code class=\"language-text\">--build</code>에서 중간 오류 허용</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-%EC%A7%80%EC%97%AD-%EC%9A%B0%EC%84%A0-%EC%A7%84%EB%8B%A8\">에디터에서 지역 우선 진단</a></p>\n</li>\n<li>\n<p><a href=\"#granular-commit-characters\">Granular Commit Characters</a></p>\n</li>\n<li>\n<p><a href=\"#auto-import%EC%97%90%EC%84%9C-%EC%A0%9C%EC%99%B8-%ED%8C%A8%ED%84%B4-%EC%A7%80%EC%9B%90\">Auto-Import에서 제외 패턴 지원</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EB%AA%A9%ED%95%A0-%EB%A7%8C%ED%95%9C-%EB%8F%99%EC%9E%91-%EB%B3%80%EA%B2%BD\">주목할 만한 동작 변경</a></p>\n<ul>\n<li><a href=\"#tsbuildinfo-%EB%8A%94-%ED%95%AD%EC%83%81-%EC%83%9D%EC%84%B1\"><code class=\"language-text\">.tsbuildinfo</code> 는 항상 생성</a></li>\n<li><a href=\"#node_modules-%EB%82%B4%EB%B6%80%EC%9D%98-%ED%8C%8C%EC%9D%BC-%ED%99%95%EC%9E%A5%EC%9E%90%EC%99%80-packagejson%EC%9D%98-%EC%B2%98%EB%A6%AC\"><code class=\"language-text\">node_modules</code> 내부의 파일 확장자와 <code class=\"language-text\">package.json</code>의 처리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#computed-properties%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-override-%EA%B2%80%EC%82%AC\">Computed Properties의 올바른 override 검사</a></p>\n</li>\n</ul>"}},"pageContext":{"id":"895251ae-09ee-5228-95fb-55ea20a4ad0a","frontmatter__slug":"/translate-ts-5-6","previous":"/translate-ts-5-7","previousTitle":"TypeScript 5.7 번역","next":"/translate-ts-5-5","nextTitle":"TypeScript 5.5 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}