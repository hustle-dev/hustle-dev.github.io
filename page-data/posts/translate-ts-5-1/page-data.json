{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-1/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html</a></p>\n</blockquote>\n<h2 id=\"더-쉬운-undefined---반환-함수-리턴\">더 쉬운 <code class=\"language-text\">undefined</code> - 반환 함수 리턴</h2>\n<p>JS에서 함수가 반환을 하지 않고 실행을 완료하면 <code class=\"language-text\">undefined</code> 값을 반환 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no return</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// x = undefined</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>하지만 이전 버전의 TS에서는 반환문이 전혀 없는 함수는 <code class=\"language-text\">void</code>함수와 <code class=\"language-text\">any</code> 함수 뿐이었다. 즉, '이 함수는 <code class=\"language-text\">undefined</code> 값을 반환한다'라고 명시적으로 말하더라도 적어도 하나의 반환문이 있어야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ✅ fine - we inferred that 'f1' returns 'void'</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ✅ fine - 'void' doesn't need a return statement</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ✅ fine - 'any' doesn't need a return statement</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ❌ error!</span>\n<span class=\"token comment\">// A function whose declared type is neither 'void' nor 'any' must return a value.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일부 API에서 <code class=\"language-text\">undefined</code> 함수를 반환할 것으로 예상되는 경우, <code class=\"language-text\">undefined</code> 반환을 명시적으로 하나 이상 반환하거나 <code class=\"language-text\">return</code>문과 명시적 어노테이션이 있어야 하므로 문제가 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span>\n<span class=\"token comment\">// ❌ error!</span>\n<span class=\"token comment\">// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ❌ error!</span>\n<span class=\"token comment\">// A function whose declared type is neither 'void' nor 'any' must return a value.</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ❌ error!</span>\n<span class=\"token comment\">// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ✅ works</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">undefined</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ✅ works</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이러한 동작은 특히 사용자가 제어할 수 없는 함수를 호출할 때 답답하고 혼란스러웠다.<code class=\"language-text\">undefined</code> 함수에 대한 무효 추론, <code class=\"language-text\">undefined</code> 반환 함수에 <code class=\"language-text\">return</code>문이 필요한지 여부 등의 상호 작용을 이해하는 것은 산만해 보였다.</p>\n<p>첫째, TS 5.1에서는 이제 <code class=\"language-text\">undefined</code> 반환 함수에 반환문을 포함하지 않아도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ✅ Works in TypeScript 5.1!</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ✅ Works in TypeScript 5.1!</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>둘째, 함수에 반환 표현식이 없고 <code class=\"language-text\">undefined</code> 함수를 반환할 것으로 예상되는 함수로 전달되는 경우 TS는 해당 함수의 반환 타입을 <code class=\"language-text\">undefined</code>로 추론한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ✅ Works in TypeScript 5.1!</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//                 ^ return type is undefined</span>\n  <span class=\"token comment\">// no returns</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ✅ Works in TypeScript 5.1!</span>\n<span class=\"token function\">takesFunction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//                 ^ return type is undefined</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>또 다른 유사한 문제점을 해결하기 위해 TS의 <code class=\"language-text\">--noImplicitReturns</code> 옵션에 따라 <code class=\"language-text\">undefined</code> 값만 반환하는 함수는 이제 모든 코드 경로가 명시적 반환으로 끝나지 않아도 된다는 점에서 <code class=\"language-text\">void</code>와 유사한 예외를 적용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ✅ Works in TypeScript 5.1 under '--noImplicitReturns'!</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some stuff...</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"getters-및-setters와-관련-없는-타입\">Getters 및 Setters와 관련 없는 타입</h2>\n<p>TypeScript 4.3에서는 <code class=\"language-text\">get</code> 및 <code class=\"language-text\">set</code> 접근자 쌍이 서로 다른 두 가지 타입을 지정할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Serializer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> box<span class=\"token operator\">:</span> Serializer\n<span class=\"token comment\">// Allows writing a 'boolean'</span>\nbox<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token comment\">// Comes out as a 'string'</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>box<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>처음에는 <code class=\"language-text\">get</code> 타입이 <code class=\"language-text\">set</code> 타입의 하위 타입이어야 했다.</p>\n<p>이는 이 아래 코드를 의미했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 항상 유효함</span>\nbox<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> box<span class=\"token punctuation\">.</span>value</code></pre></div>\n<p>그러나 기존 API와 제안된 API에는 Getter와 Setter 사이에 전혀 관련이 없는 유형이 많이 있다. 예를 들어 가장 일반적인 예 중 하나인 DOM 및 CSSStyleRule API의 스타일 속성을 생각해 보자. 모든 스타일 규칙에는 스타일 프로퍼티가 있는데, 이 프로퍼티에 쓰려고 하면 문자열로만 제대로 작동한다.</p>\n<p>이제 TypeScript 5.1에서는 명시적인 타입 어노테이션이 있는 경우 접근자 속성 <code class=\"language-text\">get</code> 및 <code class=\"language-text\">set</code>에 전혀 관련이 없는 유형을 허용한다. 이 버전의 TypeScript에서는 아직 이러한 내장 인터페이스의 유형이 변경되지는 않았지만, 이제 다음과 같은 방식으로 <code class=\"language-text\">CSSStyleRule</code>을 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">CSSStyleRule</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token comment\">/** Always reads as a `CSSStyleDeclaration` */</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">style</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CSSStyleDeclaration\n  <span class=\"token comment\">/** Can only write a `string` here. */</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">style</span><span class=\"token punctuation\">(</span>newValue<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 <code class=\"language-text\">set</code> 액세서가 \"유효한\" 데이터만 허용하도록 요구하지만, 일부 기본 상태가 아직 초기화되지 않은 경우 <code class=\"language-text\">get</code> 액세서가 <code class=\"language-text\">undefined</code> 상태로 반환될 수 있도록 지정하는 등의 다른 패턴도 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SafeBox</span> <span class=\"token punctuation\">{</span>\n  #value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span>\n  <span class=\"token comment\">// Only accepts strings!</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newValue<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Must check for 'undefined'!</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#value\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>사실 이것은 <code class=\"language-text\">--exactOptionalProperties</code>에서 선택적 속성을 검사하는 방식과 유사하다.</p>\n<h2 id=\"jsx-요소와-jsx-태그-타입-간의-분리된-타입-검사\">JSX 요소와 JSX 태그 타입 간의 분리된 타입 검사</h2>\n<p>TypeScript가 JSX를 사용하면서 겪었던 한 가지 문제점은 모든 JSX 요소의 태그 타입에 대한 요구 사항이었다.</p>\n<p>문맥상 JSX 요소는 다음 중 하나이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// A self-closing JSX tag</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Foo</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token comment\">// A regular element with an opening/closing tag</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Bar</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Bar</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p><code class=\"language-text\">&lt;Foo /></code> 또는<code class=\"language- <bar\">&lt;/Bar</code>를 타입 검사할 때 TypeScript는 항상 <code class=\"language-text\">JSX</code>라는 네임스페이스를 조회하고 거기에서 <code class=\"language-text\">Element</code>라는 타입을 가져오거나 더 직접적으로는 <code class=\"language-text\">JSX.Element</code>를 조회한다.</p>\n<p>하지만 <code class=\"language-text\">Foo</code> 또는 <code class=\"language-text\">Bar</code> 자체가 태그 이름으로 사용하기에 유효한지 확인하기 위해 TypeScript는 대략적으로 <code class=\"language-text\">Foo</code> 또는 <code class=\"language-text\">Bar</code>가 반환하거나 생성한 타입을 가져와 <code class=\"language-text\">JSX.Element</code>(또는 해당 타입이 생성 가능한 경우 <code class=\"language-text\">JSX.ElementClass</code>라는 다른 타입)와의 호환성을 확인한다.</p>\n<p>여기서 제한은 컴포넌트가 <code class=\"language-text\">JSX.Element</code>보다 더 광범위한 타입을 반환하거나 \"렌더링\"하는 경우 사용할 수 없다는 것을 의미한다. 예를 들어 JSX 라이브러리에서 문자열이나 프로미스를 반환하는 컴포넌트는 괜찮을 수 있다.</p>\n<p>좀 더 구체적인 예로, React는 Promises를 반환하는 컴포넌트에 대한 제한적인 지원을 추가하는 것을 고려하고 있지만, 기존 버전의 TypeScript에서는 <code class=\"language-text\">JSX.Element</code>의 타입을 대폭 완화하지 않고는 이를 표현할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Foo</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token comment\">//             ~~~</span>\n<span class=\"token comment\">// 'Foo' cannot be used as a JSX component.</span>\n<span class=\"token comment\">//   Its return type 'Promise&lt;Element>' is not a valid JSX element.</span></code></pre></div>\n<p>이를 표현할 수 있는 방법을 라이브러리에 제공하기 위해 TypeScript 5.1은 이제 <code class=\"language-text\">JSX.ElementType</code>이라는 타입을 조회한다. <code class=\"language-text\">ElementType</code>은 JSX 엘리먼트에서 태그로 사용할 수 있는 것을 정확하게 지정한다. 따라서 오늘날에는 다음과 같이 입력될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">namespace</span> <span class=\"token constant\">JSX</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">ElementType</span> <span class=\"token operator\">=</span>\n        <span class=\"token comment\">// All the valid lowercase tags</span>\n        <span class=\"token keyword\">keyof</span> IntrinsicAttributes\n        <span class=\"token comment\">// Function components</span>\n        <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Element\n        <span class=\"token comment\">// Class components</span>\n        <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> ElementClass<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">IntrinsictAttributes</span> <span class=\"token keyword\">extends</span> <span class=\"token comment\">/*...*/</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Element</span> <span class=\"token operator\">=</span> <span class=\"token comment\">/*...*/</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">ClassElement</span> <span class=\"token operator\">=</span> <span class=\"token comment\">/*...*/</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"네임스페이스-jsx-속성\">네임스페이스 JSX 속성</h2>\n<p>TypeScript는 이제 JSX를 사용할 때 네임스페이스 속성 이름을 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Both of these are equivalent:</span>\n<span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Foo</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">a:</span>b</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hello<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Foo</span></span> <span class=\"token attr-name\">a</span> <span class=\"token attr-name\">:</span> <span class=\"token attr-name\">b</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hello<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">FooProps</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string-property property\">\"a:b\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> FooProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">[</span><span class=\"token string\">\"a:b\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>네임스페이스 태그 이름은 이름의 첫 번째 세그먼트가 소문자 이름일 때 <code class=\"language-text\">JSX.IntrinsicAttributes</code>에서 비슷한 방식으로 조회된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// In some library's code or in an augmentation of that library:</span>\n<span class=\"token keyword\">namespace</span> <span class=\"token constant\">JSX</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">IntrinsicElements</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'a:b'</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> prop<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// In our code:</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">a:</span>b</span> <span class=\"token attr-name\">prop</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hello!<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<h2 id=\"typeroots-모듈-해상도에서-참조된다\"><code class=\"language-text\">typeRoots</code> 모듈 해상도에서 참조된다.</h2>\n<p>TypeScript의 지정된 모듈 조회 전략이 경로를 확인할 수 없는 경우, 이제 지정된 <code class=\"language-text\">typeRoot</code>를 기준으로 패키지를 확인한다.</p>\n<h2 id=\"선언을-기존-파일로-이동\">선언을 기존 파일로 이동</h2>\n<p>선언을 새 파일로 이동하는 것 외에도 TypeScript는 이제 기존 파일로 선언을 이동할 수 있는 미리보기 기능도 제공한다. 이 기능은 최신 버전의 Visual Studio Code에서 사용해 볼 수 있다.</p>\n<p>gif 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#move-declarations-to-existing-files\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#move-declarations-to-existing-files</a></p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/9366537f-8e0a-466c-88dd-fd510839a731\" alt=\"image\"></p>\n<p>이 기능은 현재 프리뷰 버전이며, 이에 대한 추가 피드백을 받고 있다.</p>\n<h2 id=\"jsx-태그용-링크-커서\">JSX 태그용 링크 커서</h2>\n<p>TypeScript는 이제 JSX 태그 이름에 대한 링크 편집을 지원한다. 연결된 편집(때때로 \"미러 커서\"라고도 함)을 사용하면 편집기에서 여러 위치를 동시에 자동으로 편집할 수 있다.</p>\n<p>gif 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#linked-cursors-for-jsx-tags\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#linked-cursors-for-jsx-tags</a></p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/18900ff3-bb40-4b6f-8e11-45ebc3a43219\" alt=\"image\"></p>\n<p>이 새로운 기능은 TypeScript 및 JavaScript 파일 모두에서 작동하며, Visual Studio 코드 인사이더에서 활성화할 수 있다. Visual Studio Code에서 <code class=\"language-text\">Editor: Linked Editing</code>를 편집하거나 설정 UI에서 편집할 수 있다. 또는 <code class=\"language-text\">editor.linkedEditing</code>을 JSON 설정 파일에서 설정할 수 있다.</p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/642b0122-269b-4b55-b2d3-48a5f3e67dfa\" alt=\"image\"></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token property\">\"editor.linkedEditing\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"jsdoc-태그인-param에-대한-스니펫-완성\">JSDoc 태그인 <code class=\"language-text\">@param</code>에 대한 스니펫 완성</h2>\n<p>이제 TypeScript와 JavaScript 파일 모두에서 <code class=\"language-text\">@param</code> 태그를 입력할 때 스니펫 완성 기능을 제공한다. 이 기능을 사용하면 코드를 문서화하거나 JavaScript에서 JSDoc 타입을 추가할 때 텍스트를 입력하거나 이동하는 횟수를 줄일 수 있다.</p>\n<h2 id=\"최적화\">최적화</h2>\n<h3 id=\"불필요한-타입-인스턴스화-방지\">불필요한 타입 인스턴스화 방지</h3>\n<p>TypeScript 5.1은 이제 외부 타입 매개변수에 대한 참조를 포함하지 않는 것으로 알려진 객체 타입 내에서 타입 인스턴스화를 수행하지 않는다. 이를 통해 불필요한 계산을 많이 줄일 수 있으며, material-ui의 문서 디렉터리에서 유형 검사 시간을 50% 이상 단축할 수 있다.</p>\n<h3 id=\"유니온-리터럴에-대한-네거티브-대소문자-검사\">유니온 리터럴에 대한 네거티브 대소문자 검사</h3>\n<p>소스 타입이 유니온 타입의 일부인지 확인할 때 TypeScript는 먼저 해당 소스에 대한 내부 타입 식별자를 사용하여 빠른 조회를 수행한다. 조회에 실패하면 TypeScript는 유니온 내의 모든 타입에 대해 호환성을 확인한다.</p>\n<p>리터럴 타입을 순수 리터럴 타입의 유니온에 연관시킬 때, 이제 TypeScript는 공용체의 다른 모든 타입에 대한 전체 검사를 피할 수 있다. TypeScript는 항상 리터럴 유형을 인턴/캐시하기 때문에 이 가정은 안전하지만, \"새로운\" 리터럴 유형과 관련하여 처리해야 할 몇 가지 에지 케이스가 있다.</p>\n<p>이 최적화를 통해 이번 이슈에서 코드의 타입 검사 시간을 약 45초에서 약 0.4초로 단축할 수 있었다.</p>\n<h3 id=\"jsdoc-구문-분석을-위한-스캐너-호출-감소\">JSDoc 구문 분석을 위한 스캐너 호출 감소</h3>\n<p>이전 버전의 TypeScript는 JSDoc 주석을 구문 분석할 때 스캐너/토큰화기를 사용하여 주석을 세분화된 토큰으로 나누고 그 내용을 다시 조합했다. 이 방법은 주석 텍스트를 정규화하여 여러 개의 공백이 하나로 합쳐지도록 하는 데 유용할 수 있지만, 매우 '수다스럽기' 때문에 구문 분석기와 스캐너가 매우 자주 왔다 갔다 하면서 JSDoc 구문 분석에 오버헤드를 가중시켰다.</p>\n<p>TypeScript 5.1은 스캐너/토큰라이저로 JSDoc 주석을 분해하는 로직을 더 많이 이동시켰다. 이제 스캐너는 더 큰 콘텐츠 청크를 구문 분석기에 직접 반환하여 필요에 따라 처리한다.</p>\n<p>이러한 변경 사항으로 인해 대부분 산문 주석이 포함된 10MB짜리 JavaScript 파일 몇 개의 구문 분석 시간이 절반가량 단축되었다. 보다 현실적인 예로, 성능 제품군의 xstate 스냅샷은 구문 분석 시간이 약 300밀리초 단축되어 로드 및 분석 속도가 빨라졌다.</p>\n<h2 id=\"주요-변경사항\">주요 변경사항</h2>\n<h3 id=\"최소-런타임-요구-사항인-es2020-및-nodejs-1417\">최소 런타임 요구 사항인 ES2020 및 Node.js 14.17</h3>\n<p>TypeScript 5.1은 이제 ECMAScript 2020에 도입된 JavaScript 기능을 제공한다. 따라서 최소한의 최신 런타임에서 TypeScript를 실행해야 한다. 대부분의 사용자에게 이는 이제 TypeScript가 Node.js 14.17 이상에서만 실행된다는 것을 의미한다.</p>\n<p>Node 10 또는 12와 같은 이전 버전의 Node.js에서 TypeScript 5.1을 실행하려고 하면 <code class=\"language-text\">tsc.js</code> 또는 <code class=\"language-text\">tsserver.js</code> 에서 다음과 같은 오류가 표시될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">node_modules/typescript/lib/tsserver.js:2406\n  for (let i = startIndex ?? 0; i &lt; array.length; i++) {\n                           ^\n\nSyntaxError: Unexpected token '?'\n    at wrapSafe (internal/modules/cjs/loader.js:915:16)\n    at Module._compile (internal/modules/cjs/loader.js:963:27)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)\n    at Module.load (internal/modules/cjs/loader.js:863:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:708:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)\n    at internal/main/run_main_module.js:17:47</code></pre></div>\n<p>또한 TypeScript를 설치하려고 하면 npm에서 다음과 같은 오류 메시지가 표시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm WARN EBADENGINE Unsupported engine {\nnpm WARN EBADENGINE   package: 'typescript@5.1.1-rc',\nnpm WARN EBADENGINE   required: { node: '>=14.17' },\nnpm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' }\nnpm WARN EBADENGINE }</code></pre></div>\n<p>yarn 에서</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\"\nerror Found incompatible module.</code></pre></div>\n<h3 id=\"node_modulestypes를-위해-명시적-typeroots-에-대한-상향-이동을-비활성화-환다\"><code class=\"language-text\">node_modules/@types</code>를 위해 명시적 <code class=\"language-text\">typeRoots</code> 에 대한 상향 이동을 비활성화 환다.</h3>\n<p>이전에는 <code class=\"language-text\">tsconfig.json</code>에 <code class=\"language-text\">typeRoots</code> 옵션이 지정되었지만 <code class=\"language-text\">typeRoots</code> 디렉터리 확인에 실패한 경우 TypeScript가 계속해서 상위 디렉터리로 이동하여 각 상위의 <code class=\"language-text\">node_modules/@types</code> 폴더 내의 패키지를 확인하려고 시도했다.</p>\n<p>이 동작은 과도한 조회를 유발할 수 있으며 TypeScript 5.1에서는 비활성화되었다. 그 결과 <code class=\"language-text\">tsconfig.json</code>의 <code class=\"language-text\">types</code> 옵션 또는 <code class=\"language-text\">/// &lt;reference ></code> 지시어의 항목에 따라 다음과 같은 오류가 표시될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error TS2688: Cannot find type definition file for 'node'.\nerror TS2688: Cannot find type definition file for 'mocha'.\nerror TS2688: Cannot find type definition file for 'jasmine'.\nerror TS2688: Cannot find type definition file for 'chai-http'.\nerror TS2688: Cannot find type definition file for 'webpack-env\"'.</code></pre></div>\n<p>해결책은 일반적으로 <code class=\"language-text\">node_modules/@types</code>에 대한 특정 항목을 <code class=\"language-text\">typeRoots</code>에 추가하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"types\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mocha\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"typeRoots\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token comment\">// Keep whatever you had around before.</span>\n      <span class=\"token string\">\"./some-custom-types/\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// You might need your local 'node_modules/@types'.</span>\n      <span class=\"token string\">\"./node_modules/@types\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// You might also need to specify a shared 'node_modules/@types'</span>\n      <span class=\"token comment\">// if you're using a \"monorepo\" layout.</span>\n      <span class=\"token string\">\"../../node_modules/@types\"</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"23.06.12","description":"TypeScript 5.1 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42mOwD9z6n5qYgW4G2gVsgbMdgrb+dwiEYHQ5ogyEabD23fzf0nvTfwvvTXDaymczXA02g3G60NZ/y/+ozP3/43IP/k8tPvw/ufDw/5Tiw/+jsvb/t/HbQrqXQZqCk/f8z6489j+99Mj/+LyD/zPKjv6PyT7w39pvM3letvHb/N/SZ9N/cy+IdynyMkakQDFZkUJIE1kGkpsOAVDDx+dN5GA6AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 5.1 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%8D%94-%EC%89%AC%EC%9A%B4-undefined---%EB%B0%98%ED%99%98-%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B4\">더 쉬운 <code class=\"language-text\">undefined</code> - 반환 함수 리턴</a></p>\n</li>\n<li>\n<p><a href=\"#getters-%EB%B0%8F-setters%EC%99%80-%EA%B4%80%EB%A0%A8-%EC%97%86%EB%8A%94-%ED%83%80%EC%9E%85\">Getters 및 Setters와 관련 없는 타입</a></p>\n</li>\n<li>\n<p><a href=\"#jsx-%EC%9A%94%EC%86%8C%EC%99%80-jsx-%ED%83%9C%EA%B7%B8-%ED%83%80%EC%9E%85-%EA%B0%84%EC%9D%98-%EB%B6%84%EB%A6%AC%EB%90%9C-%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC\">JSX 요소와 JSX 태그 타입 간의 분리된 타입 검사</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-jsx-%EC%86%8D%EC%84%B1\">네임스페이스 JSX 속성</a></p>\n</li>\n<li>\n<p><a href=\"#typeroots-%EB%AA%A8%EB%93%88-%ED%95%B4%EC%83%81%EB%8F%84%EC%97%90%EC%84%9C-%EC%B0%B8%EC%A1%B0%EB%90%9C%EB%8B%A4\"><code class=\"language-text\">typeRoots</code> 모듈 해상도에서 참조된다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%9D%84-%EA%B8%B0%EC%A1%B4-%ED%8C%8C%EC%9D%BC%EB%A1%9C-%EC%9D%B4%EB%8F%99\">선언을 기존 파일로 이동</a></p>\n</li>\n<li>\n<p><a href=\"#jsx-%ED%83%9C%EA%B7%B8%EC%9A%A9-%EB%A7%81%ED%81%AC-%EC%BB%A4%EC%84%9C\">JSX 태그용 링크 커서</a></p>\n</li>\n<li>\n<p><a href=\"#jsdoc-%ED%83%9C%EA%B7%B8%EC%9D%B8-param%EC%97%90-%EB%8C%80%ED%95%9C-%EC%8A%A4%EB%8B%88%ED%8E%AB-%EC%99%84%EC%84%B1\">JSDoc 태그인 <code class=\"language-text\">@param</code>에 대한 스니펫 완성</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94\">최적화</a></p>\n<ul>\n<li><a href=\"#%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%ED%83%80%EC%9E%85-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94-%EB%B0%A9%EC%A7%80\">불필요한 타입 인스턴스화 방지</a></li>\n<li><a href=\"#%EC%9C%A0%EB%8B%88%EC%98%A8-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EA%B1%B0%ED%8B%B0%EB%B8%8C-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EA%B2%80%EC%82%AC\">유니온 리터럴에 대한 네거티브 대소문자 검사</a></li>\n<li><a href=\"#jsdoc-%EA%B5%AC%EB%AC%B8-%EB%B6%84%EC%84%9D%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8A%A4%EC%BA%90%EB%84%88-%ED%98%B8%EC%B6%9C-%EA%B0%90%EC%86%8C\">JSDoc 구문 분석을 위한 스캐너 호출 감소</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9A%94-%EB%B3%80%EA%B2%BD%EC%82%AC%ED%95%AD\">주요 변경사항</a></p>\n<ul>\n<li><a href=\"#%EC%B5%9C%EC%86%8C-%EB%9F%B0%ED%83%80%EC%9E%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD%EC%9D%B8-es2020-%EB%B0%8F-nodejs-1417\">최소 런타임 요구 사항인 ES2020 및 Node.js 14.17</a></li>\n<li><a href=\"#node_modulestypes%EB%A5%BC-%EC%9C%84%ED%95%B4-%EB%AA%85%EC%8B%9C%EC%A0%81-typeroots-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%81%ED%96%A5-%EC%9D%B4%EB%8F%99%EC%9D%84-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94-%ED%99%98%EB%8B%A4\"><code class=\"language-text\">node_modules/@types</code>를 위해 명시적 <code class=\"language-text\">typeRoots</code> 에 대한 상향 이동을 비활성화 환다.</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"4ba6ccd2-743f-5669-a93c-73204c376312","frontmatter__slug":"/translate-ts-5-1","previous":null,"previousTitle":null,"next":"/velog-to-gatsby-blog","nextTitle":"velog to Gatsby 블로그 이전기"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}