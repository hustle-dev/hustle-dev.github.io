{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-4/","result":{"data":{"markdownRemark":{"html":"<!-- 썸네일 -->\n<!-- 본문 -->\n<blockquote>\n<p>원글링크: <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/\">https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/</a></p>\n</blockquote>\n<h2 id=\"마지막-할당-이후의-클로저에서-좁혀진-타입-유지\">마지막 할당 이후의 클로저에서 좁혀진 타입 유지</h2>\n<p>TypeScript는 일반적으로 수행하는 검사를 기반으로 변수에 대해 좀 더 구체적인 타입을 추론할 수 있다. 이를 narrowing(좁히기)라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">uppercaseStrings</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// 타입스크립트는 여기서 'x'를 'string'으로 인식한다.</span>\r\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>한 가지 일반적인 문제점은 이렇게 좁혀진 타입들이 함수 클로저 내에서 항상 유지되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUrls</span><span class=\"token punctuation\">(</span>url<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token constant\">URL</span><span class=\"token punctuation\">,</span> names<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> url <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        url <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">URL</span></span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token keyword\">return</span> names<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n        url<span class=\"token punctuation\">.</span>searchParams<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\r\n        <span class=\"token comment\">//  ~~~~~~~~~~~~</span>\r\n        <span class=\"token comment\">// error!</span>\r\n        <span class=\"token comment\">// Property 'searchParams' does not exist on type 'string | URL'.</span>\r\n\r\n        <span class=\"token keyword\">return</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 TypeScript는 URL이 다른 곳에서 변경되었기 때문에 콜백 함수에서 URL 객체라고 가정하는 것이 \"안전하지 않다\"고 판단했다. 하지만, 이 경우 화살표 함수는 항상 URL에 대한 할당 이후에 생성되며 URL에 대한 마지막 할당이다.</p>\n<p>TypeScript 5.4에서는 이를 활용해 좀 더 스마트하게 타입을 좁힐 수 있다. 파라미터와 <code class=\"language-text\">let</code> 변수가 호이스트되지 않은 함수에서 사용되는 경우 타입 체커는 마지막 할당 지점을 찾는다. 마지막 할당 지점이 발견되면 TypeScript는 포함 함수 외부에서 안전하게 타입을 좁힐 수 있다. 즉, 위의 예제가 이제 작동한다.</p>\n<p>변수가 중첩 함수 내에서 어딘가에 할당된 경우에는 좁히기 분석이 작동하지 않는다. 나중에 함수가 호출될지 여부를 확실히 알 수 없기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">printValueLater</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        value <span class=\"token operator\">=</span> <span class=\"token string\">\"missing!\"</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// 그 타입에 영향을 미치지 않는 방식으로도 '값'을 수정하면,</span>\r\n        <span class=\"token comment\">// 클로저의 유형 세분화가 무효화된다.</span>\r\n        value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">//          ~~~~~</span>\r\n        <span class=\"token comment\">// error! 'value' is possibly 'undefined'.</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 변경 사항으로 일반적인 JavaScript 코드를 더 쉽게 작성할 수 있게 되었다.</p>\n<h2 id=\"noinfer-유틸리티-타입\"><code class=\"language-text\">NoInfer</code> 유틸리티 타입</h2>\n<p>제네릭 함수를 호출할 때 TypeScript는 전달한 인수로부터 타입 인수를 추론할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">doSomething</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arg<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n\r\n<span class=\"token comment\">// 'T'는 'string'이어야 한다고 명시적으로 말할 수 있다.</span>\r\n<span class=\"token generic-function\"><span class=\"token function\">doSomething</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// 'T'의 타입을 유추할 수도 있다.</span>\r\n<span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 한 가지 문제는 \"최선의\" 타입을 추론하는 것이 항상 명확하지 않다는 점이다. 이로 인해 TypeScript가 유효한 호출을 거부하거나, 의심스러운 호출을 허용하거나, 버그를 잡을 때 더 심각한 오류 메시지를 보고하게 될 수 있다.</p>\n<p>예를 들어, 색상 이름 목록과 선택적 기본 색상을 받는 <code class=\"language-text\">createStreetLight</code> 함수를 가정해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">createStreetLight</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>colors<span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> defaultColor<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">createStreetLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"red\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">colors</code> 배열에 없던 <code class=\"language-text\">defaultColor</code>를 전달하면 어떻게 될까? 이 함수에서 colors는 \"진실의 원천\"으로 간주되어야 하며, defaultColor에 전달할 수 있는 값을 설명해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Oops! This undesirable, but is allowed!</span>\r\n<span class=\"token function\">createStreetLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 호출에서 타입 추론은 <code class=\"language-text\">\"blue\"</code>가 <code class=\"language-text\">\"red\"</code>, <code class=\"language-text\">\"yellow\"</code>, <code class=\"language-text\">\"green\"</code>만큼 유효한 타입이라고 결정했다. 그래서 TypeScript는 호출을 거부하는 대신 C의 타입을 <code class=\"language-text\">\"red\" | \"yellow\" | \"green\" | \"blue\"</code>로 추론했다.</p>\n<p>현재 이 문제를 해결하는 한 가지 방법은 기존 타입 매개변수로 제한된 별도의 타입 매개변수를 추가하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">createStreetLight</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">D</span> <span class=\"token keyword\">extends</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>colors<span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> defaultColor<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">D</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">createStreetLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                            ~~~~~~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.</span></code></pre></div>\n<p>이 방법은 작동하지만 <code class=\"language-text\">D</code>가 <code class=\"language-text\">createStreetLight</code>의 시그니처 다른 곳에서는 사용되지 않을 것이기 때문에 약간 어색하다. 이 경우엔 그렇게 나쁘지 않지만, 시그니처에서 타입 매개변수를 한 번만 사용하는 것은 종종 코드에서 냄새를 풍긴다.</p>\n<p>그래서 TypeScript 5.4에서는 새로운 <code class=\"language-text\">NoInfer&lt;T></code> 유틸리티 타입을 도입했다. 타입을 <code class=\"language-text\">NoInfer&lt;...></code> 로 감싸면 TypeScript에게 내부 타입을 파고들어 타입 추론 후보를 찾지 말라는 신호를 보낸다.</p>\n<p><code class=\"language-text\">NoInfer</code>를 사용하여 <code class=\"language-text\">createStreetLight</code>를 다음과 같이 재작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">createStreetLight</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>colors<span class=\"token operator\">:</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> defaultColor<span class=\"token operator\">?</span><span class=\"token operator\">:</span> NoInfer<span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// ...</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">createStreetLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                            ~~~~~~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.</span></code></pre></div>\n<p>추론을 위해 탐색되는 <code class=\"language-text\">defaultColor</code> 타입을 제외하면 <code class=\"language-text\">\"blue\"</code>가 추론 후보가 되지 않으며 타입 체커가 이를 거부할 수 있다.</p>\n<h2 id=\"objectgroupby와-mapgroupby\"><code class=\"language-text\">Object.groupBy</code>와 <code class=\"language-text\">Map.groupBy</code></h2>\n<p>TypeScript 5.4는 JavaScript의 새로운 <code class=\"language-text\">Object.groupBy</code> 및 <code class=\"language-text\">Map.groupBy</code> 정적 메서드에 대한 선언을 추가한다.</p>\n<p><code class=\"language-text\">Object.groupBy</code>는 이터러블과 각 요소를 어느 \"그룹\"에 배치할지 결정하는 함수를 받는다. 이 함수는 각각의 고유한 그룹에 대해 \"키\"를 만들어야 하며, <code class=\"language-text\">Object.groupBy</code>는 해당 키를 사용하여 모든 키가 원래 요소가 있는 배열에 매핑되는 객체를 만든다.</p>\n<p>따라서 다음 자바스크립트는</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">groupBy</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"even\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"odd\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 작성하는 것과 동일하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\r\n    even<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n    odd<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Map.groupBy</code>도 비슷하지만 일반 객체 대신 맵을 생성한다. <code class=\"language-text\">Map</code>의 보증이 필요하거나 <code class=\"language-text\">Map</code>을 기대하는 API를 다루거나 자바스크립트에서 프로퍼티 이름으로 사용할 수 있는 키뿐만 아니라 그룹화를 위해 모든 종류의 키를 사용해야 하는 경우 이 방법이 더 바람직할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> Map<span class=\"token punctuation\">.</span><span class=\"token function\">groupBy</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"even\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"odd\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이전과 마찬가지로 동일한 방법으로 <code class=\"language-text\">myObj</code>를 만들 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"even\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"odd\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 <code class=\"language-text\">Object.groupBy</code> 예제에서 생성된 객체는 모든 선택적 프로퍼티를 사용한다는 점에 유유의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">EvenOdds</span> <span class=\"token punctuation\">{</span>\r\n    even<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n    odd<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">const</span> myObj<span class=\"token operator\">:</span> EvenOdds <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">groupBy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nmyObj<span class=\"token punctuation\">.</span>even<span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//    ~~~~</span>\r\n<span class=\"token comment\">// Error to access this under 'strictNullChecks'.</span></code></pre></div>\n<p>모든 키가 그룹별로 생성되었다는 것을 일반적인 방법으로 보장할 수 있는 방법이 없기 때문이다.</p>\n<p>또한 이러한 메서드는 <code class=\"language-text\">target</code>을 <code class=\"language-text\">esnext</code>로 구성하거나 <code class=\"language-text\">lib</code> 설정을 조정해야만 액세스할 수 있다. 결국 안정적인 <code class=\"language-text\">es2024</code> 타겟에서 사용할 수 있을 것으로 예상된다.</p>\n<h2 id=\"--moduleresolution-bundler-및---module-preserve에서-require-호출-지원\"><code class=\"language-text\">--moduleResolution bundler</code> 및 <code class=\"language-text\">--module preserve</code>에서 <code class=\"language-text\">require()</code> 호출 지원</h2>\n<p>TypeScript에는 최신 번들러가 가져오기 경로가 참조하는 파일을 파악하는 방식을 모델링하기 위한 <code class=\"language-text\">bundler</code>라는 <code class=\"language-text\">moduleResolution</code> 옵션이 있다. 이 옵션의 한계 중 하나는 <code class=\"language-text\">--module esnext</code>와 쌍을 이루어야 하므로 <code class=\"language-text\">import ... = require(...)</code> 구문을 사용할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// previously errored</span>\r\n<span class=\"token keyword\">import</span> myModule <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"module/path\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>표준 ECMAScript <code class=\"language-text\">import</code> 만 사용할 계획이라면 큰 문제가 되지 않을 수 있지만, 조건부 내보내기가 포함된 패키지를 사용할 때는 차이가 있다..</p>\n<p>TypeScript 5.4에서는 이제 <code class=\"language-text\">module</code> 설정을 <code class=\"language-text\">preserve</code>라는 새로운 옵션으로 설정할 때 <code class=\"language-text\">require()</code>를 사용할 수 있다.</p>\n<p><code class=\"language-text\">--module preserve</code>과 <code class=\"language-text\">--moduleResolution</code> 번들러는 Bun과 같은 번들러와 런타임이 허용하는 것과 모듈 조회를 수행하는 방법을 보다 정확하게 모델링한다. 실제로 <code class=\"language-text\">--module preserve</code>를 사용할 때 <code class=\"language-text\">bundler</code> 옵션은 암시적으로 <code class=\"language-text\">--moduleResolution</code>에 대해 설정됩니다(<code class=\"language-text\">--esModuleInterop</code> 및 <code class=\"language-text\">--resolveJsonModule</code>과 함께).</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"module\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"preserve\"</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token comment\">// ^ also implies:</span>\r\n        <span class=\"token comment\">// \"moduleResolution\": \"bundler\",</span>\r\n        <span class=\"token comment\">// \"esModuleInterop\": true,</span>\r\n        <span class=\"token comment\">// \"resolveJsonModule\": true,</span>\r\n\r\n        <span class=\"token comment\">// ...</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">--module preserve</code>에서는 ECMAScript <code class=\"language-text\">import</code>가 항상 그대로 전송되며, <code class=\"language-text\">import ... = require(...)</code>는 <code class=\"language-text\">require()</code> 호출로 전송된다(실제로는 코드에 번들러를 사용할 가능성이 높으므로 <code class=\"language-text\">emit</code>시에 TypeScript를 사용하지 않을 수도 있지만). 이는 포함 파일의 파일 확장자에 관계없이 적용된다. 따라서 이 코드의 출력은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 이렇게 작성하면</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> foo <span class=\"token keyword\">from</span> <span class=\"token string\">\"some-package/foo\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">import</span> bar <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some-package/bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// 이렇게 된다.</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> foo <span class=\"token keyword\">from</span> <span class=\"token string\">\"some-package/foo\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">var</span> bar <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some-package/bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이것은 또한 선택한 구문에 따라 조건부 내보내기가 일치하는 방식이 결정된다는 것을 의미한다. 따라서 위의 예에서 <code class=\"language-text\">some-package</code>의 <code class=\"language-text\">package.json</code>은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"some-package\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.0.1\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"exports\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"./foo\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"import\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./esm/foo-from-import.mjs\"</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token property\">\"require\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./cjs/foo-from-require.cjs\"</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token property\">\"./bar\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"import\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./esm/bar-from-import.mjs\"</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token property\">\"require\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./cjs/bar-from-require.cjs\"</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeScript는 이러한 경로를 <code class=\"language-text\">[...]/some-package/esm/foo-from-import.mjs</code> 및 <code class=\"language-text\">[...]/some-package/cjs/bar-from-require.cjs</code>로 확인한다.</p>\n<h2 id=\"import-attribues-및-assertions-확인\">Import Attribues 및 Assertions 확인</h2>\n<p>이제 Import Attribues와 Assertions이 글로벌 <code class=\"language-text\">ImportAttributes</code> 타입에 대해 검사된다. 즉, 이제 런타임이 Import Attribues를 더 정확하게 설명할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// In some global file.</span>\r\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ImportAttributes</span> <span class=\"token punctuation\">{</span>\r\n    type<span class=\"token operator\">:</span> <span class=\"token string\">\"json\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// In some other module</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> ns <span class=\"token keyword\">from</span> <span class=\"token string\">\"foo\"</span> <span class=\"token keyword\">with</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"not-json\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">//                                     ~~~~~~~~~~</span>\r\n<span class=\"token comment\">// error!</span>\r\n<span class=\"token comment\">//</span>\r\n<span class=\"token comment\">// Type '{ type: \"not-json\"; }' is not assignable to type 'ImportAttributes'.</span>\r\n<span class=\"token comment\">//  Types of property 'type' are incompatible.</span>\r\n<span class=\"token comment\">//    Type '\"not-json\"' is not assignable to type '\"json\"'.</span></code></pre></div>\n<h2 id=\"누락된-매개변수-추가를-위한-빠른-수정\">누락된 매개변수 추가를 위한 빠른 수정</h2>\n<p>이제 TypeScript에 인수가 너무 많아 호출되는 함수에 새 매개변수를 추가하는 빠른 수정 기능이 추가되었다.</p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/0b40cc19-55c7-4506-a812-acd590c8c9e5\" alt=\"image\"></p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/33d3ba25-db3a-4d1c-a07c-80cd2d5512f5\" alt=\"image\"></p>\n<p>이는 현재 번거로울 수 있는 여러 기존 함수를 통해 새 인수를 스레딩할 때 유용할 수 있다.</p>\n<h2 id=\"하위-경로-가져오기에-대한-자동-가져오기-지원\">하위 경로 가져오기에 대한 자동 가져오기 지원</h2>\n<p>Node.js에서 <code class=\"language-text\">package.json</code>은 imports라는 필드를 통해 \"하위 경로 가져오기\"라는 기능을 지원한다. 이는 패키지 내부의 경로를 다른 모듈 경로로 다시 매핑하는 방법이다. 개념적으로는 특정 모듈 번들러와 로더가 지원하는 기능인 경로 매핑과 매우 유사하며, 타입스크립트는 <code class=\"language-text\">paths</code>라는 기능을 통해 이를 지원한다. 유일한 차이점은 하위 경로 가져오기는 항상 <code class=\"language-text\">#</code>로 시작해야 한다는 것이다.</p>\n<p>TypeScript의 자동 가져오기 기능은 이전에는 <code class=\"language-text\">imports</code> 시 경로를 고려하지 않았기 때문에 불편할 수 있었다. 대신 사용자가 <code class=\"language-text\">tsconfig.json</code>에서 경로를 수동으로 정의해야 했다. 이제 TypeScript의 자동 가져오기 기능이 하위 경로 가져오기를 지원한다!</p>\n<h2 id=\"typescript-50-사용-중단으로-인한-향후-변경-사항\">TypeScript 5.0 사용 중단으로 인한 향후 변경 사항</h2>\n<p>TypeScript 5.0에서는 다음 옵션 및 동작이 더 이상 사용되지 않는다</p>\n<ul>\n<li><code class=\"language-text\">charset</code></li>\n<li><code class=\"language-text\">target: ES3</code></li>\n<li><code class=\"language-text\">importsNotUsedAsValues</code></li>\n<li><code class=\"language-text\">noImplicitUseStrict</code></li>\n<li><code class=\"language-text\">noStrictGenericChecks</code></li>\n<li><code class=\"language-text\">keyofStringsOnly</code></li>\n<li><code class=\"language-text\">suppressExcessPropertyErrors</code></li>\n<li><code class=\"language-text\">suppressImplicitAnyIndexErrors</code></li>\n<li><code class=\"language-text\">out</code></li>\n<li><code class=\"language-text\">preserveValueImports</code></li>\n<li>프로젝트 참조의 <code class=\"language-text\">prepend</code></li>\n<li>암시적으로 OS에 특화된 <code class=\"language-text\">newLine</code></li>\n</ul>\n<p>이를 계속 사용하려면 TypeScript 5.0 및 기타 최신 버전을 사용하는 개발자는 <code class=\"language-text\">\"5.0\"</code>이라는 값으로 <code class=\"language-text\">ignoreDeprecations</code>라는 새 옵션을 지정해야 했다.</p>\n<p>그러나 TypeScript 5.4는 이러한 기능이 정상적으로 계속 작동하는 마지막 버전이 될 것이다. TypeScript 5.5(2024년 6월 예정)에서는 이러한 옵션이 하드 에러가 되어 이를 사용하는 코드를 마이그레이션해야 한다.</p>\n<h2 id=\"주목할-만한-변화\">주목할 만한 변화</h2>\n<p>이 섹션에서는 업그레이드의 일부로 인지하고 이해해야 하는 일련의 주목할 만한 변경 사항을 강조한다. 사용 중단, 제거 및 새로운 제한 사항이 강조 표시되는 경우도 있다. 또한 기능적으로 개선되었지만 새로운 오류를 발생시켜 기존 빌드에 영향을 줄 수 있는 버그 수정도 포함될 수 있다.</p>\n<h3 id=\"libdts-변경-사항\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</h3>\n<p>DOM용으로 생성된 타입은 코드베이스의 타입 검사에 영향을 미칠 수 있다. 자세한 내용은 TypeScript 5.4의 DOM 업데이트를 참조하세요.</p>\n<h3 id=\"보다-정확한-조건부-타입-제약-조건\">보다 정확한 조건부 타입 제약 조건</h3>\n<p>다음 코드는 더 이상 함수 <code class=\"language-text\">foo</code>에서 두 번째 변수 선언을 허용하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">IsArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token builtin\">any</span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">foo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span> <span class=\"token keyword\">extends</span> object<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> IsArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">let</span> first<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// Error</span>\r\n    <span class=\"token keyword\">let</span> second<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Error, but previously wasn't</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이전에는 TypeScript가 <code class=\"language-text\">second</code>를 이니셜라이저로 검사할 때 <code class=\"language-text\">IsArray&lt;U></code>가 단위 타입에 할당 가능한지 <code class=\"language-text\">false</code>인지 확인해야 했다. <code class=\"language-text\">IsArray&lt;U></code>는 명백한 방식으로 호환되지 않지만 TypeScript는 해당 타입의 제약 조건도 살펴본다. 다음과 같은 <code class=\"language-text\">T extends Foo ? TrueBranch : FalseBranch</code> 조건부 타입에서, 여기서 <code class=\"language-text\">T</code>가 제네릭인 경우 타입 시스템은 <code class=\"language-text\">T</code>의 제약 조건을 살펴보고 <code class=\"language-text\">T</code> 자체에 대입한 후 참 또는 거짓 분기를 결정한다.</p>\n<p>하지만 이 동작은 지나치게 열성적이어서 부정확했다. <code class=\"language-text\">T</code>의 제약조건을 <code class=\"language-text\">Foo</code>에 할당할 수 없다고 해서 할당할 수 있는 것으로 인스턴스화되지 않는다는 의미는 아니다. 따라서 더 올바른 동작은 <code class=\"language-text\">T</code>가 절대 또는 항상 <code class=\"language-text\">Foo</code>를 확장하지 않는다는 것을 증명할 수 없는 경우 조건형의 제약 조건에 대한 공용체 타입을 생성하는 것이다.</p>\n<p>타입스크립트 5.4는 이보다 정확한 동작을 채택했다. 이것이 실제로 의미하는 바는 일부 조건부 타입 인스턴스가 더 이상 해당 분기와 호환되지 않는다는 것을 발견할 수 있다는 것이다.</p>\n<h3 id=\"타입-변수와-primitive-타입-간의-교집합을-보다-공격적으로-줄이기\">타입 변수와 Primitive 타입 간의 교집합을 보다 공격적으로 줄이기</h3>\n<p>이제 타입 변수의 제약 조건이 해당 Primitive와 겹치는 방식에 따라 타입 변수와 프리미티브와의 교집합을 보다 적극적으로 줄인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">intersect</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">U</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">foo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token string\">\"abc\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"def\"</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> num<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n\r\n    <span class=\"token comment\">// Was 'T &amp; string', now is just 'T'</span>\r\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">// Was 'T &amp; number', now is just 'never'</span>\r\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\">// Was '(T &amp; \"abc\") | (T &amp; \"def\")', now is just 'T'</span>\r\n    <span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span> <span class=\"token operator\">?</span>\r\n        <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\r\n        <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">\"def\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"보간을-사용한-템플릿-문자열-검사-개선\">보간을 사용한 템플릿 문자열 검사 개선</h3>\n<p>이제 TypeScript가 템플릿 문자열 타입의 placeholder 슬롯에 문자열을 할당할 수 있는지 여부를 더 정확하게 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">a</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">let</span> x<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> <span class=\"token builtin\">string</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token comment\">// Used to error, now doesn't.</span>\r\n    x <span class=\"token operator\">=</span> <span class=\"token string\">\"-id\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 동작이 더 바람직하지만 이러한 규칙 변경을 쉽게 목격할 수 있는 조건부 타입과 같은 구문을 사용하는 코드에서 코드가 손상될 수 있다.</p>\n<h3 id=\"타입-전용-임포트가-로컬-값과-충돌할-때-발생하는-오류\">타입 전용 임포트가 로컬 값과 충돌할 때 발생하는 오류</h3>\n<p>이전에는 TypeScript에서 <code class=\"language-text\">Something</code>에 대한 임포트가 타입만 참조하는 경우 <code class=\"language-text\">isolatedModules</code>에서 다음 코드가 허용되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Something <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./some/path\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">let</span> Something <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그러나 단일 파일 컴파일러는 런타임에 코드가 실패하도록 보장되어 있더라도 가져오기를 삭제하는 것이 \"안전한지\" 여부를 판단하는 것은 안전하지 않다. TypeScript 5.4에서 이 코드는 다음과 같은 오류를 트리거한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">Import <span class=\"token string\">'Something'</span> conflicts <span class=\"token keyword\">with</span> local value<span class=\"token punctuation\">,</span> so must be declared <span class=\"token keyword\">with</span> a type<span class=\"token operator\">-</span>only <span class=\"token keyword\">import</span> when <span class=\"token string\">'isolatedModules'</span> <span class=\"token keyword\">is</span> enabled<span class=\"token punctuation\">.</span></code></pre></div>\n<p>수정 방법은 로컬에서 이름을 바꾸거나 오류에 명시된 대로 가져오기에 <code class=\"language-text\">type</code> 수정자를 추가하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> Something <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./some/path\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// or</span>\r\n\r\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Something</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./some/path\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"새로운-열거형-할당-가능성-제한\">새로운 열거형 할당 가능성 제한</h3>\n<p>두 열거형에 선언된 이름과 열거형 멤버 이름이 동일한 경우 이전에는 항상 호환되는 것으로 간주되었지만, 값을 알 수 있는 경우 TypeScript에서 자동으로 다른 값을 가질 수 있도록 허용했다.</p>\n<p>TypeScript 5.4에서는 값이 알려진 경우 값이 동일해야 함으로써 이 제한이 강화되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">namespace</span> First <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">enum</span> SomeEnum <span class=\"token punctuation\">{</span>\r\n        <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">namespace</span> Second <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">enum</span> SomeEnum <span class=\"token punctuation\">{</span>\r\n        <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> First<span class=\"token punctuation\">.</span>SomeEnum<span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> Second<span class=\"token punctuation\">.</span>SomeEnum<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// Both used to be compatible - no longer the case,</span>\r\n    <span class=\"token comment\">// TypeScript errors with something like:</span>\r\n    <span class=\"token comment\">//</span>\r\n    <span class=\"token comment\">//  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.</span>\r\n    x <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\r\n    y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 열거형 멤버 중 하나에 정적으로 알려진 값이 없는 경우에 대한 새로운 제한 사항이 있다. 이러한 경우 다른 열거형은 적어도 암시적으로 숫자이거나(예: 정적으로 확인된 이니셜라이저가 없음), 명시적으로 숫자이거나(즉, 타입스크립트가 값을 숫자로 확인할 수 있음) 둘 중 하나여야 한다. 실질적으로 이것이 의미하는 바는 문자열 열거형 멤버는 같은 값의 다른 문자열 열거형과만 호환된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">namespace</span> First <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">enum</span> SomeEnum <span class=\"token punctuation\">{</span>\r\n        <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">namespace</span> Second <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">enum</span> SomeEnum <span class=\"token punctuation\">{</span>\r\n        <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"some known string\"</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> First<span class=\"token punctuation\">.</span>SomeEnum<span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> Second<span class=\"token punctuation\">.</span>SomeEnum<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// 둘 다 예전에는 호환되었지만 더 이상 호환되지 않는다.</span>\r\n    <span class=\"token comment\">// 다음과 같은 타입스크립트 오류가 발생한다.</span>\r\n    <span class=\"token comment\">//</span>\r\n    <span class=\"token comment\">//  'SomeEnum.B'의 한 값은 '\"일부 알려진 문자열\"'이고 다른 값은 알 수 없는 숫자 값으로 가정한다.</span>\r\n    x <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\r\n    y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"열거형-멤버의-이름-제한\">열거형 멤버의 이름 제한</h3>\n<p>TypeScript는 더 이상 열거형 멤버에 <code class=\"language-text\">Infinity</code>, <code class=\"language-text\">-Infinity</code> 또는 <code class=\"language-text\">NaN</code>이라는 이름을 사용할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Errors on all of these:</span>\r\n<span class=\"token comment\">//</span>\r\n<span class=\"token comment\">//  An enum member cannot have a numeric name.</span>\r\n<span class=\"token keyword\">enum</span> <span class=\"token constant\">E</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token number\">Infinity</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token string\">\"-Infinity\"</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\r\n    <span class=\"token number\">NaN</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"24.03.08","description":"TypeScript 5.4 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42mOwD9z6n5qYga4GOgRBsGPwNggO2gbmk22gjd+W/9a+m/9b+Wz6bwWmN/+38d1CnoG2/lv+R2cd+B+fd/B/WsmR/ynFh/+nAumY7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg/+j825wDY5bi8TtDLlkBvmntt+m/hDcEgr1MUy7BIgUUQRZEyKNIhABp8yGCqIO1VAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["Typescript","번역"],"title":"TypeScript 5.4 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%A7%88%EC%A7%80%EB%A7%89-%ED%95%A0%EB%8B%B9-%EC%9D%B4%ED%9B%84%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%97%90%EC%84%9C-%EC%A2%81%ED%98%80%EC%A7%84-%ED%83%80%EC%9E%85-%EC%9C%A0%EC%A7%80\">마지막 할당 이후의 클로저에서 좁혀진 타입 유지</a></p>\n</li>\n<li>\n<p><a href=\"#noinfer-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%ED%83%80%EC%9E%85\"><code class=\"language-text\">NoInfer</code> 유틸리티 타입</a></p>\n</li>\n<li>\n<p><a href=\"#objectgroupby%EC%99%80-mapgroupby\"><code class=\"language-text\">Object.groupBy</code>와 <code class=\"language-text\">Map.groupBy</code></a></p>\n</li>\n<li>\n<p><a href=\"#--moduleresolution-bundler-%EB%B0%8F---module-preserve%EC%97%90%EC%84%9C-require-%ED%98%B8%EC%B6%9C-%EC%A7%80%EC%9B%90\"><code class=\"language-text\">--moduleResolution bundler</code> 및 <code class=\"language-text\">--module preserve</code>에서 <code class=\"language-text\">require()</code> 호출 지원</a></p>\n</li>\n<li>\n<p><a href=\"#import-attribues-%EB%B0%8F-assertions-%ED%99%95%EC%9D%B8\">Import Attribues 및 Assertions 확인</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%88%84%EB%9D%BD%EB%90%9C-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%B6%94%EA%B0%80%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B9%A0%EB%A5%B8-%EC%88%98%EC%A0%95\">누락된 매개변수 추가를 위한 빠른 수정</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%98%EC%9C%84-%EA%B2%BD%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%90%EB%8F%99-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0-%EC%A7%80%EC%9B%90\">하위 경로 가져오기에 대한 자동 가져오기 지원</a></p>\n</li>\n<li>\n<p><a href=\"#typescript-50-%EC%82%AC%EC%9A%A9-%EC%A4%91%EB%8B%A8%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%ED%96%A5%ED%9B%84-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD\">TypeScript 5.0 사용 중단으로 인한 향후 변경 사항</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EB%AA%A9%ED%95%A0-%EB%A7%8C%ED%95%9C-%EB%B3%80%ED%99%94\">주목할 만한 변화</a></p>\n<ul>\n<li><a href=\"#libdts-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</a></li>\n<li><a href=\"#%EB%B3%B4%EB%8B%A4-%EC%A0%95%ED%99%95%ED%95%9C-%EC%A1%B0%EA%B1%B4%EB%B6%80-%ED%83%80%EC%9E%85-%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4\">보다 정확한 조건부 타입 제약 조건</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EB%B3%80%EC%88%98%EC%99%80-primitive-%ED%83%80%EC%9E%85-%EA%B0%84%EC%9D%98-%EA%B5%90%EC%A7%91%ED%95%A9%EC%9D%84-%EB%B3%B4%EB%8B%A4-%EA%B3%B5%EA%B2%A9%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A4%84%EC%9D%B4%EA%B8%B0\">타입 변수와 Primitive 타입 간의 교집합을 보다 공격적으로 줄이기</a></li>\n<li><a href=\"#%EB%B3%B4%EA%B0%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%82%AC-%EA%B0%9C%EC%84%A0\">보간을 사용한 템플릿 문자열 검사 개선</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EC%A0%84%EC%9A%A9-%EC%9E%84%ED%8F%AC%ED%8A%B8%EA%B0%80-%EB%A1%9C%EC%BB%AC-%EA%B0%92%EA%B3%BC-%EC%B6%A9%EB%8F%8C%ED%95%A0-%EB%95%8C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%98%A4%EB%A5%98\">타입 전용 임포트가 로컬 값과 충돌할 때 발생하는 오류</a></li>\n<li><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%97%B4%EA%B1%B0%ED%98%95-%ED%95%A0%EB%8B%B9-%EA%B0%80%EB%8A%A5%EC%84%B1-%EC%A0%9C%ED%95%9C\">새로운 열거형 할당 가능성 제한</a></li>\n<li><a href=\"#%EC%97%B4%EA%B1%B0%ED%98%95-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%9D%B4%EB%A6%84-%EC%A0%9C%ED%95%9C\">열거형 멤버의 이름 제한</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"2b4e2cb7-e760-520f-96ee-9cd3d4fa2465","frontmatter__slug":"/translate-ts-5-4","previous":null,"previousTitle":null,"next":"/reviews-support-coding-technologies","nextTitle":"코딩을 지탱하는 기술 서평"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}