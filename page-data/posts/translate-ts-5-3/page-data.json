{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-5-3/","result":{"data":{"markdownRemark":{"html":"<!-- 썸네일 -->\n<!-- 본문 -->\n<blockquote>\n<p>원글 링크: <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-5-3/\">https://devblogs.microsoft.com/typescript/announcing-typescript-5-3/</a></p>\n</blockquote>\n<h2 id=\"import-attributes\">Import Attributes</h2>\n<p>TS 5.3은 <a href=\"https://github.com/tc39/proposal-import-attributes\">import attributes</a> 에 대한 최신 업데이트를 지원한다.</p>\n<p><code class=\"language-text\">import attributes</code>의 한 가지 사용 사례는 모듈의 예상 형식에 대한 정보를 런타임에 제공하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 이것을 JSON으로만 해석되기를 원하고,</span>\r\n<span class=\"token comment\">// `.json` 확장자를 가진 실행 가능하거나 악의적인 JavaScript 파일이 아니다.</span>\r\n<span class=\"token keyword\">import</span> obj <span class=\"token keyword\">from</span> <span class=\"token string\">\"./something.json\"</span> <span class=\"token keyword\">with</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"json\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 속성들의 내용은 호스트에 따라 다르므로 TypeScript에서 확인하지 않고, 브라우저와 런타임이 처리할 수 있도록 그대로 둔다(에러 가능성 포함).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// TypeScript는 이것을 허용한다.</span>\r\n<span class=\"token comment\">// 하지만 브라우저에서는 아닐 수 있다.</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> foo <span class=\"token keyword\">from</span> <span class=\"token string\">\"./foo.js\"</span> <span class=\"token keyword\">with</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"fluffy bunny\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>동적 <code class=\"language-text\">import()</code> 호출은 두 번째 인수를 통해 <code class=\"language-text\">import attributes</code>를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./something.json\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">with</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"json\"</span> <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>두 번째 인수의 예상 타입은 <code class=\"language-text\">ImportCallOptions</code>라는 타입으로 정의되며, 기본적으로 <code class=\"language-text\">with</code>라는 속성을 기대한다.</p>\n<p><code class=\"language-text\">import attribute</code>는 TS 4.5에서 구현된 <code class=\"language-text\">import assertions</code>이라는 이전 제안에서 발전된 것이다. 가장 명확한 차이점은 <code class=\"language-text\">assert</code> 키워드 대신 <code class=\"language-text\">with</code> 키워드를 사용한다는 점이다. 또 다른 차이점은 런타임이 이제 <code class=\"language-text\">import</code> 경로의 해석과 해석을 안내하기 위해 attirbutes를 자유롭게 사용할 수 있게 되었지만, import 단언은 모듈을 로드한 후에만 일부 특성을 <code class=\"language-text\">assert</code>할 수 있었다는 것이다.</p>\n<p>시간이 지남에 따라 TS는 <code class=\"language-text\">import assertions</code>의 기존 구문을 폐기하고 <code class=\"language-text\">import attributes</code>에 대한 제안된 구문을 사용할 계획이다. <code class=\"language-text\">assert</code>를 사용하는 기존 코드는 <code class=\"language-text\">with</code> 키워드로 마이그레이션해야 한다. <code class=\"language-text\">import attribute</code>가 필요한 새 코드는 <code class=\"language-text\">with</code>을 사용해야 한다.</p>\n<h2 id=\"import-types에서-resolution-mode-지원-안정화\">Import Types에서 <code class=\"language-text\">resolution-mode</code> 지원 안정화</h2>\n<p>TS 4.7에서 TypeScript는 <code class=\"language-text\">/// &lt;reference types=\"...\" /></code>에 <code class=\"language-text\">resolution-mode</code> 속성을 추가하여 지정자가 <code class=\"language-text\">import</code> 또는 <code class=\"language-text\">require</code> 시맨틱을 통해 해석되어야 하는지 제어하는 기능을 지원하기 시작했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/// &lt;reference types=\"pkg\" resolution-mode=\"require\" /></span>\r\n\r\n<span class=\"token comment\">// or</span>\r\n\r\n<span class=\"token comment\">/// &lt;reference types=\"pkg\" resolution-mode=\"import\" /></span></code></pre></div>\n<p>타입 전용 import에 대한 <code class=\"language-text\">import assertion</code>에도 해당 필드가 추가되었지만, 이는 nightly 버전의 TS에서만 지원되었다. 그 이유는 <code class=\"language-text\">import assertion</code>이 본질적으로 모듈 해석을 위한 것이 아니었기 때문이다. 따라서 이 기능은 더 많은 피드백을 얻기 위해 nightly 전용 모드로 실험적으로 제공되었다.</p>\n<p>하지만 <code class=\"language-text\">import attributes</code>가 resolution 할 수 있고, 합리적인 사용 사례를 확인했으므로 이제 TS 5.3에서는 <code class=\"language-text\">import type</code>에 대한 <code class=\"language-text\">resolution-mode</code> 속성을 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// `require()`로 import 하는 것처럼 `pkg`를 확인</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> TypeFromRequire <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pkg\"</span> <span class=\"token keyword\">with</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token string-property property\">\"resolution-mode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"require\"</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// `import`로 import하는 것처럼 `pkg`를 확인</span>\r\n<span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> TypeFromImport <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"pkg\"</span> <span class=\"token keyword\">with</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token string-property property\">\"resolution-mode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"import\"</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">MergedType</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">TypeFromRequire</span><span class=\"token punctuation\">,</span> TypeFromImport <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>이러한 <code class=\"language-text\">import attributes</code>는 <code class=\"language-text\">import()</code> 타입에도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">TypeFromRequire</span> <span class=\"token operator\">=</span>\r\n    <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pkg\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">with</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">\"resolution-mode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"require\"</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>TypeFromRequire<span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">TypeFromImport</span> <span class=\"token operator\">=</span>\r\n    <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pkg\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">with</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">\"resolution-mode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"import\"</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>TypeFromImport<span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">MergedType</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">TypeFromRequire</span><span class=\"token punctuation\">,</span> TypeFromImport <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"resolution-mode-모든-모듈-모드에서-지원\"><code class=\"language-text\">resolution-mode</code> 모든 모듈 모드에서 지원</h2>\n<p>이전에는 <code class=\"language-text\">resolution-mode</code>를 사용할 수 있는 <code class=\"language-text\">moduleResolution</code> 옵션은 <code class=\"language-text\">node 16</code> 및 <code class=\"language-text\">nodenext</code>에서만 허용되었다. 타입별로 특정 모듈을 더 쉽게 찾기 위해, 이제 <code class=\"language-text\">resolution-mode</code>는 <code class=\"language-text\">bundler</code>, <code class=\"language-text\">node 10</code>과 같은 다른 모든 <code class=\"language-text\">moduleResolution</code> 옵션에서 적절하게 작동하며 <code class=\"language-text\">classic</code>에서는 오류를 발생시키지 않는다.</p>\n<h2 id=\"switch-true-narrowing\"><code class=\"language-text\">switch (true)</code> Narrowing</h2>\n<p>TS 5.3은 이제 <code class=\"language-text\">switch (true)</code>내의 각 <code class=\"language-text\">case</code> 절의 조건을 기반으로 타입을 좁힐 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">case</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">\"string\"</span><span class=\"token operator\">:</span>\r\n            <span class=\"token comment\">// 'x' is a 'string' here</span>\r\n            <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n            <span class=\"token comment\">// falls through...</span>\r\n\r\n        <span class=\"token keyword\">case</span> <span class=\"token builtin\">Array</span><span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\r\n            <span class=\"token comment\">// 'x' is a 'string | any[]' here.</span>\r\n            <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n            <span class=\"token comment\">// falls through...</span>\r\n\r\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\r\n          <span class=\"token comment\">// 'x' is 'unknown' here.</span>\r\n          <span class=\"token comment\">// ...</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"booleans과의-비교를-통한-narrowing\">Booleans과의 비교를 통한 Narrowing</h2>\n<p>어떤 조건에서 <code class=\"language-text\">true</code> 또는 <code class=\"language-text\">false</code>를 직접 비교해야 할 때가 있을 수 있다. 보통 이런 비교는 불필요한 비교이지만, 스타일의 한 포인트로 선호하거나 JS 진실성과 관련된 특정 문제를 피하기 위해 사용할 수 있다. 어쨋든 이전에는 TS가 좁히기를 수행할 때 이러한 형식을 인지하지 못했다.</p>\n<p>TS 5.3은 변수를 좁힐 때 이러한 표현식을 이해하고 유지한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span>\r\n    a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token punctuation\">{</span>\r\n    b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">MyType</span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">isA</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> MyType<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> x <span class=\"token keyword\">is</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"a\"</span> <span class=\"token keyword\">in</span> x<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">someFn</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> MyType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isA</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// works!</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"symbolhasinstance를-통한-instanceof-좁히기\"><code class=\"language-text\">Symbol.hasInstance</code>를 통한 <code class=\"language-text\">instanceof</code> 좁히기</h2>\n<p>JS의 난해한 특징은 <code class=\"language-text\">instanceof</code> 연산자의 동작을 재정의할 수 있다는 것이다. 이렇게 하려면 <code class=\"language-text\">instanceof</code>의 오른쪽에 있는 값에 <code class=\"language-text\">Symbol.hasInstance</code>로 명명된 특정 메서드가 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Weirdo</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>hasInstance<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>testedValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// wait, what?</span>\r\n        <span class=\"token keyword\">return</span> testedValue <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// false</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Weirdo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// true</span>\r\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Weirdo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">instanceof</code>에서 이 동작을 더 잘 모델링하기 위해 TS는 이제 해당 <code class=\"language-text\">[Symbol.hasInstance]</code> 메서드가 존재하고, 타입 예측 함수로 선언되어 있는지 확인한다. 그렇다면 <code class=\"language-text\">instanceof</code> 연산자 왼쪽의 테스트된 값은 해당 타입 예측에 의해 적절하게 좁혀진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">PointLike</span> <span class=\"token punctuation\">{</span>\r\n    x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\r\n    y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Point</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">PointLike</span> <span class=\"token punctuation\">{</span>\r\n    x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\r\n    y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">distanceFromOrigin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">**</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>hasInstance<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> val <span class=\"token keyword\">is</span> PointLike <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>val <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">&amp;&amp;</span>\r\n            <span class=\"token string\">\"x\"</span> <span class=\"token keyword\">in</span> val <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">\"y\"</span> <span class=\"token keyword\">in</span> val <span class=\"token operator\">&amp;&amp;</span>\r\n            <span class=\"token keyword\">typeof</span> val<span class=\"token punctuation\">.</span>x <span class=\"token operator\">===</span> <span class=\"token string\">\"number\"</span> <span class=\"token operator\">&amp;&amp;</span>\r\n            <span class=\"token keyword\">typeof</span> val<span class=\"token punctuation\">.</span>y <span class=\"token operator\">===</span> <span class=\"token string\">\"number\"</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// 이 두 가지에 접근 가능 - 정확!</span>\r\n        value<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\r\n        value<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span>\r\n\r\n        <span class=\"token comment\">// 이건 접근할 수 없음 - `PointLike`를 가지고 있지만,</span>\r\n        <span class=\"token comment\">// 실제로 'Point'는 아님</span>\r\n        value<span class=\"token punctuation\">.</span><span class=\"token function\">distanceFromOrigin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 예시에서 볼 수 있듯이, <code class=\"language-text\">Point</code>는 자체적인 [Symbol.hasInstance] 메서드를 정의한다. 그것은 사실 <code class=\"language-text\">PointLike</code>라는 별도의 타입에 대한 사용자 지정 타입 가드로 작용한다. <code class=\"language-text\">f</code> 함수에서 <code class=\"language-text\">instanceof</code>를 사용하여 <code class=\"language-text\">value</code>를 <code class=\"language-text\">PointLike</code>로 narrowing 할 수 있었지만 <code class=\"language-text\">Point</code>로는 할 수 없었다. 이는 우리가 <code class=\"language-text\">x</code> 및 <code class=\"language-text\">y</code> 속성에 접근할 수 있지만 <code class=\"language-text\">distanceFromOrigin</code> 메서드에는 접근할 수 없음을 의미한다.</p>\n<h2 id=\"instance-필드에-대한-super-속성-접근-검사\">Instance 필드에 대한 <code class=\"language-text\">super</code> 속성 접근 검사</h2>\n<p>JS에선 <code class=\"language-text\">super</code> 키워드를 통해 기본 클래스의 선언에 접근할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Base method called!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Derived method called!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Derived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// 출력:</span>\r\n<span class=\"token comment\">//   Derived method called!</span>\r\n<span class=\"token comment\">//   Base method called!</span></code></pre></div>\n<p>이것은 <code class=\"language-text\">this.someMethod()</code>와 같이 쓰는 것과 다르다. 왜냐하면 이것은 오버라이딩된 메서드를 호출할 수 있기 때문이다. 이것은 종종 두 가지가 구별되지 않는 경우가 많아 더욱 미묘한 차이이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"someMethod called!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">someOtherMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// 이 둘은 동일하게 작동합니다.</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Derived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">someOtherMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// 출력:</span>\r\n<span class=\"token comment\">//   someMethod called!</span>\r\n<span class=\"token comment\">//   someMethod called!</span></code></pre></div>\n<p>문제는 <code class=\"language-text\">super</code>를 필드로 정의된 메서드에 사용하면 런타임 오류가 발생할 수 있다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function-variable function\">someMethod</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"someMethod called!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">someOtherMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Derived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">someOtherMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// 💥</span>\r\n<span class=\"token comment\">// 작동하지 않습니다. 'super.someMethod'는 'undefined'입니다.</span></code></pre></div>\n<p>TS 5.3은 이제 <code class=\"language-text\">super</code> 속성 접근/메서드 호출을 더 면밀히 검사하여 클래스 필드에 해당하는지 확인한다. 즉, 이제 타입 검사 오류가 발생한다.</p>\n<h2 id=\"interactive-inlay-hints-for-types\">Interactive Inlay Hints for Types</h2>\n<p>TypeScript의 인레이 힌트는 이제 타입의 정의로 이동하는 것을 지원한다! 이것은 코드를 쉽게 탐색하는 데 도움이 된다.</p>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/ae06db2e-2d94-44ff-958f-bb7ba89e47df\" alt=\"image\"></p>\n<h2 id=\"type-auto-imports-선호-설정\"><code class=\"language-text\">type</code> Auto-Imports 선호 설정</h2>\n<p>이전에 TypeScript가 타입 위치에 대한 자동 가져오기를 생성할 때, 설정에 따라 <code class=\"language-text\">type</code> 수정자를 추가했다. 예를 들어, 다음과 같은 경우에 <code class=\"language-text\">Person</code>에 대한 자동 가져오기를 받을 때:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> p<span class=\"token operator\">:</span> Person</code></pre></div>\n<p>TS의 편집 경험은 보통 <code class=\"language-text\">Person</code>에 대한 가져오기를 다음과 같이 추가한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Person <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./types\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> p<span class=\"token operator\">:</span> Person</code></pre></div>\n<p>그리고 <code class=\"language-text\">verbatimModuleSyntax</code>와 같은 특정 설정에서는 타입 수정자를 추가한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./types\"</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> p<span class=\"token operator\">:</span> Person</code></pre></div>\n<p>하지만, 코드베이스가 이러한 옵션을 사용할 수 없거나 가능한 경우 명시적인 타입 가져오기를 선호할 수 있다.</p>\n<p>최근 변경으로 TS는 이제 이를 편집기별 옵션으로 활성화할 수 있다. Visual Studio Code에서는 UI에서 <code class=\"language-text\">\"TypeScript › Preferences: Prefer Type Only Auto Imports\"</code>로 활성화하거나, JSON 구성 옵션 <code class=\"language-text\">typescript.preferences.preferTypeOnlyAutoImports</code>로 설정할 수 있다.</p>\n<h2 id=\"jsdoc-파싱-생략에-의한-최적화\">JSDoc 파싱 생략에 의한 최적화</h2>\n<p><code class=\"language-text\">tsc</code>를 통해 TS를 실행할 때, 컴파일러는 이제 JSDoc 파싱을 피한다. 이것은 파싱 시간을 단축될 뿐만 아니라 주석을 저장하기 위한 메모리 사용량과 가비지 컬렉션에 소요되는 시간도 줄여준다. 전반적으로 컴파일 시간이 약간 빨라지고, <code class=\"language-text\">--watch</code> 모드에서 더 빠른 피드백을 볼 수 있을 것이다.</p>\n<p>TS를 사용하는 모든 도구가 JSDoc을 저장할 필요가 없기 때문에 (예: typescript-eslint 및 Prettier), 이 파싱 전략은 API 자체의 일부로 제공되었다. 이를 통해 이러한 도구들도 TS 컴파일러에 도입된 동일한 메모리 및 속도 개선 효과를 얻을 수 있다. 주석 파싱 전략에 대한 새로운 옵션은 <code class=\"language-text\">JSDocParsingMode</code>에 설명되어 있다.</p>\n<h2 id=\"비정규화된-교차점-비교에-의한-최적화\">비정규화된 교차점 비교에 의한 최적화</h2>\n<p>TS에서 합집합과 교집합은 항상 특정 형식을 따르며, 교집합은 항상 타입을 포함할 수 없다. 이는 <code class=\"language-text\">A &amp; (B | C)</code>와 같은 합집합 위에 교집합을 생성할 때, 그 교집합이 <code class=\"language-text\">(A &amp; B) | (A &amp; C)</code>로 정규화됨을 의미한다. 그러나 경우에 따라 타입 시스템은 표시 목적으로 원래 형태를 유지한다.</p>\n<p>원래 형태는 타입 간의 몇 가지 빠른 경로 비교에 사용될 수 있다.</p>\n<p>예를 들어, <code class=\"language-text\">SomeType &amp; (Type1 | Type2 | ... | Type99999NINE)</code>을 가지고 있고 이것이 <code class=\"language-text\">SomeType</code>에 할당 가능한지 확인하고 싶다고 가정해 보자. 소스 타입으로 실제 교집합을 가지고 있는 것이 아니라 <code class=\"language-text\">(SomeType &amp; Type1) | (SomeType &amp; Type2) | ... | (SomeType &amp; Type99999NINE)</code>과 같은 합집합을 가지고 있다는 것을 기억하자. 합집합이 어떤 대상 타입에 할당 가능한지 확인할 때, 합집합의 모든 구성원이 대상 타입에 할당 가능한지 확인해야 하며, 이는 매우 느릴 수 있다.</p>\n<p>TS 5.3에서는 원래의 교집합 형태를 살펴본다. 타입을 비교할 때, 소스 교집합의 구성 요소 중 하나에 대상이 존재하는지 빠르게 확인한다.</p>\n<h2 id=\"tsserverlibraryjs와-typescriptjs-간의-통합\"><code class=\"language-text\">tsserverlibrary.js</code>와 <code class=\"language-text\">typescript.js</code> 간의 통합</h2>\n<p>TS 자체는 두 개의 라이브러리 파일 <code class=\"language-text\">tsserverlibrary.js</code>와 <code class=\"language-text\">typescript.js</code>를 제공한다. <code class=\"language-text\">tsserverlibrary.js</code>에서만 사용할 수 있는 특정 API(<code class=\"language-text\">ProjectService</code> API)가 있으며, 일부 importer에게 유용할 수 있다. 그러나 두 개는 서로 다른 번들로 많은 중복 코드를 패키지에 포함하고 있다. 또한 자동 가져오기 또는 근육 기억(muslce memory)으로 인해 일관되게 하나를 다른 하나보다 사용하는 것이 어려울 수 있다. 실수로 두 모듈을 로드하는 것은 너무 쉽고, 다른 API 인스턴스에서 코드가 제대로 동작하지 않을 수 있다. 심지어 작동한다하더라도 두 번째 번들을 로드하는 것은 리소스 사용량을 증가시킨다.</p>\n<p>이를 고려해 두 모듈을 통합하기로 결정했다. 이제 <code class=\"language-text\">typescript.js</code>에는 <code class=\"language-text\">tsserverlibrary.js</code>에 포함되었던 내용이 포함되어 있으며, <code class=\"language-text\">tsserverlibrary.js</code>는 이제 단순히 <code class=\"language-text\">typescript.js</code>를 다시 내보낸다. 이 통합의 전후를 비교하면 패키지 크기가 다음과 같이 감소했다.</p>\n<ul>\n<li>Packed: 6.90 MiB에서 5.48 MiB로 -1.42 MiB 감소 (퍼센트로 -20.61%)</li>\n<li>Unpacked: 38.74 MiB에서 30.41 MiB로 -8.33 MiB 감소 (퍼센트로 -21.50%)</li>\n</ul>\n<p><img src=\"https://github.com/hustle-dev/hustle-dev.github.io/assets/53992007/d85a75de-eb97-4a52-a906-3b46d62c8107\" alt=\"image\"></p>\n<p>즉, 패키지 크기가 20.5% 이상 줄어든 것이다.</p>\n<h2 id=\"주요-변경-사항-및-정확성-개선-사항\">주요 변경 사항 및 정확성 개선 사항</h2>\n<h3 id=\"libdts-변경-사항\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</h3>\n<p>DOM에 대해 생성된 타입은 코드베이스에 영향을 미칠 수 있다. 자세한 정보는 <a href=\"https://github.com/microsoft/TypeScript/pull/55798\">여기</a> 참고.</p>\n<h3 id=\"instance-속성에-대한-super-접근-검사\">Instance 속성에 대한 <code class=\"language-text\">super</code> 접근 검사</h3>\n<p>TS 5.3은 <code class=\"language-text\">super.</code> 속성 접근이 클래스 필드를 참조하는 선언을 감지하고 오류를 발생시킨다. 이는 런타임에 발생할 수 있는 오류를 방지한다.</p>","frontmatter":{"date":"23.11.21","description":"TypeScript 5.3 Release를 번역하면서 어떤 기능들이 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42mOwD9z6n5qYga4GOgRBsGPwNggO2gbmk22gjd+W/9a+m/9b+Wz6bwWmN/+38d1CnoG2/lv+R2cd+B+fd/B/WsmR/ynFh/+nAumY7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg/+j825wDY5bi8TtDLlkBvmntt+m/hDcEgr1MUy7BIgUUQRZEyKNIhABp8yGCqIO1VAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["Typescript","번역"],"title":"TypeScript 5.3 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#import-attributes\">Import Attributes</a></p>\n</li>\n<li>\n<p><a href=\"#import-types%EC%97%90%EC%84%9C-resolution-mode-%EC%A7%80%EC%9B%90-%EC%95%88%EC%A0%95%ED%99%94\">Import Types에서 <code class=\"language-text\">resolution-mode</code> 지원 안정화</a></p>\n</li>\n<li>\n<p><a href=\"#resolution-mode-%EB%AA%A8%EB%93%A0-%EB%AA%A8%EB%93%88-%EB%AA%A8%EB%93%9C%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90\"><code class=\"language-text\">resolution-mode</code> 모든 모듈 모드에서 지원</a></p>\n</li>\n<li>\n<p><a href=\"#switch-true-narrowing\"><code class=\"language-text\">switch (true)</code> Narrowing</a></p>\n</li>\n<li>\n<p><a href=\"#booleans%EA%B3%BC%EC%9D%98-%EB%B9%84%EA%B5%90%EB%A5%BC-%ED%86%B5%ED%95%9C-narrowing\">Booleans과의 비교를 통한 Narrowing</a></p>\n</li>\n<li>\n<p><a href=\"#symbolhasinstance%EB%A5%BC-%ED%86%B5%ED%95%9C-instanceof-%EC%A2%81%ED%9E%88%EA%B8%B0\"><code class=\"language-text\">Symbol.hasInstance</code>를 통한 <code class=\"language-text\">instanceof</code> 좁히기</a></p>\n</li>\n<li>\n<p><a href=\"#instance-%ED%95%84%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-super-%EC%86%8D%EC%84%B1-%EC%A0%91%EA%B7%BC-%EA%B2%80%EC%82%AC\">Instance 필드에 대한 <code class=\"language-text\">super</code> 속성 접근 검사</a></p>\n</li>\n<li>\n<p><a href=\"#interactive-inlay-hints-for-types\">Interactive Inlay Hints for Types</a></p>\n</li>\n<li>\n<p><a href=\"#type-auto-imports-%EC%84%A0%ED%98%B8-%EC%84%A4%EC%A0%95\"><code class=\"language-text\">type</code> Auto-Imports 선호 설정</a></p>\n</li>\n<li>\n<p><a href=\"#jsdoc-%ED%8C%8C%EC%8B%B1-%EC%83%9D%EB%9E%B5%EC%97%90-%EC%9D%98%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94\">JSDoc 파싱 생략에 의한 최적화</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%90%9C-%EA%B5%90%EC%B0%A8%EC%A0%90-%EB%B9%84%EA%B5%90%EC%97%90-%EC%9D%98%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94\">비정규화된 교차점 비교에 의한 최적화</a></p>\n</li>\n<li>\n<p><a href=\"#tsserverlibraryjs%EC%99%80-typescriptjs-%EA%B0%84%EC%9D%98-%ED%86%B5%ED%95%A9\"><code class=\"language-text\">tsserverlibrary.js</code>와 <code class=\"language-text\">typescript.js</code> 간의 통합</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9A%94-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EB%B0%8F-%EC%A0%95%ED%99%95%EC%84%B1-%EA%B0%9C%EC%84%A0-%EC%82%AC%ED%95%AD\">주요 변경 사항 및 정확성 개선 사항</a></p>\n<ul>\n<li><a href=\"#libdts-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</a></li>\n<li><a href=\"#instance-%EC%86%8D%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%9C-super-%EC%A0%91%EA%B7%BC-%EA%B2%80%EC%82%AC\">Instance 속성에 대한 <code class=\"language-text\">super</code> 접근 검사</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"9a4a7743-f13e-5467-824a-5d7b885e6bb6","frontmatter__slug":"/translate-ts-5-3","previous":null,"previousTitle":null,"next":"/scrum-and-xp","nextTitle":"스크럼과 XP 스터디"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}