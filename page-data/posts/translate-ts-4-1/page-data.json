{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/translate-ts-4-1/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글 링크: <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html</a></p>\n</blockquote>\n<h2 id=\"템플릿-리터럴-타입\">템플릿 리터럴 타입</h2>\n<p>TS의 문자열 리터럴 타입은 특정한 문자열 집합을 요구하는 함수와 API를 모델링하는데 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">setVerticalAlignment</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> <span class=\"token string\">'top'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'middle'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'bottom'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setVerticalAlignment</span><span class=\"token punctuation\">(</span><span class=\"token string\">'middel'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Argument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.</span></code></pre></div>\n<p>이는 문자열 리터럴 타입이 문자열 값의 철자 오류를 검사할 수 있기 때문에 꽤 유용하다.</p>\n<p>또한 문자열 리터럴은 매핑된 타입에서 속성 이름으로 사용될 수 있다는 것도 좋은 점이다. 이런 면에서 문자열 리터럴은 구성 요소로서 사용될 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Options</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token string\">'noImplicitAny'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'strictNullChecks'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'strictFunctionTypes'</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// same as</span>\n<span class=\"token comment\">//   type Options = {</span>\n<span class=\"token comment\">//       noImplicitAny?: boolean,</span>\n<span class=\"token comment\">//       strictNullChecks?: boolean,</span>\n<span class=\"token comment\">//       strictFunctionTypes?: boolean</span>\n<span class=\"token comment\">//   };</span></code></pre></div>\n<p>더하여 문자열 리터럴 타입은 다른 문자열 리터럴 타입을 구성하는 데에 사용될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">World</span> <span class=\"token operator\">=</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>World<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// type Greeting = \"hello world\"</span></code></pre></div>\n<p>치환 위치에서 유니온 타입이 있는 경우 유니온 멤버가 나타낼 수 있는 모든 가능한 문자열 리터럴 집합을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Color</span> <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Quantity</span> <span class=\"token operator\">=</span> <span class=\"token string\">'one'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">SeussFish</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>Quantity <span class=\"token operator\">|</span> Color<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> fish</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// type SeussFish = \"one fish\" | \"two fish\" | \"red fish\" | \"blue fish\"</span></code></pre></div>\n<p>이러한 기능은 다음과 같은 상황에서 사용될 수 있다.\nUI 컴포넌트를 위한 여러 라이브러리는 수직 및 수평 정렬을 모두 지정하는 방법을 제공한다. 종종 단일 문자열인 <code class=\"language-text\">\"bottom-right\"</code>와 같이 둘 다를 한 번에 사용하는데, <code class=\"language-text\">\"top\", \"middle\", \"bottom\"</code>으로 수직 정렬하고 <code class=\"language-text\">\"left\", \"center\", \"right\"</code>으로 수평 정렬할 때, 총 9가지의 경우의 수가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">VerticalAlignment</span> <span class=\"token operator\">=</span> <span class=\"token string\">'top'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'middle'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'bottom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">HorizontalAlignment</span> <span class=\"token operator\">=</span> <span class=\"token string\">'left'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'center'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'right'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Takes</span>\n<span class=\"token comment\">//   | \"top-left\"    | \"top-center\"    | \"top-right\"</span>\n<span class=\"token comment\">//   | \"middle-left\" | \"middle-center\" | \"middle-right\"</span>\n<span class=\"token comment\">//   | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">setAlignment</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>VerticalAlignment<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>HorizontalAlignment<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setAlignment</span><span class=\"token punctuation\">(</span><span class=\"token string\">'top-left'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// works!</span>\n<span class=\"token function\">setAlignment</span><span class=\"token punctuation\">(</span><span class=\"token string\">'top-middel'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error!</span>\n<span class=\"token comment\">// Argument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.</span>\n<span class=\"token function\">setAlignment</span><span class=\"token punctuation\">(</span><span class=\"token string\">'top-pot'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error! but good doughnuts if you're ever in Seattle</span>\n<span class=\"token comment\">// Argument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.</span></code></pre></div>\n<p>사실, 9개의 문자열에 대해서는 수동으로 작성하는 것이 더 나을 것이다. 그러나 많은 양의 문자열이 필요한 경우, 모든 타입 검사에 작업을 절약하기 위해 미리 자동으로 생성하는 것이 좋다.</p>\n<p>실제 가치 중 일부는 동적으로 새로운 문자열 리터럴을 만드는 데서 온다. 예를 들어, 객체를 가져와 대부분 동일한 객체를 생성하지만 속성 변경을 감지하기 위한 새로운 on 메서드를 생성하는 makeWatchedObject API를 상상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token function\">makeWatchedObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  firstName<span class=\"token operator\">:</span> <span class=\"token string\">'Homer'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// give-or-take</span>\n  location<span class=\"token operator\">:</span> <span class=\"token string\">'Springfield'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'firstNameChanged'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">firstName was changed!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>\"firstNameChanged\"와 같은 이벤트를 수신하는 on 메서드의 타입을 어떻게 지정해야 할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PropEventSource<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">on</span><span class=\"token punctuation\">(</span>eventName<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token builtin\">string</span> <span class=\"token operator\">&amp;</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">Changed</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">callback</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/// Create a \"watched object\" with an 'on' method</span>\n<span class=\"token comment\">/// so that you can watch for changes to properties.</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeWatchedObject</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> PropEventSource<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이를 통해 잘못된 속성을 제공할 때 오류가 발생하는 것을 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// error!</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"firstName\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nArgument <span class=\"token keyword\">of</span> <span class=\"token keyword\">type</span> <span class=\"token string\">'\"firstName\"'</span> <span class=\"token keyword\">is</span> not assignable to parameter <span class=\"token keyword\">of</span> <span class=\"token keyword\">type</span> <span class=\"token string\">'\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token comment\">// error!</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"frstNameChanged\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nArgument <span class=\"token keyword\">of</span> <span class=\"token keyword\">type</span> <span class=\"token string\">'\"frstNameChanged\"'</span> <span class=\"token keyword\">is</span> not assignable to parameter <span class=\"token keyword\">of</span> <span class=\"token keyword\">type</span> <span class=\"token string\">'\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>템플릿 리터럴 타입에서도 치환 위치에서 추론하는 등의 특별한 것을 할 수 있다. 마지막 예제를 일반화하여 <code class=\"language-text\">eventName</code> 문자열의 일부분에서 연관된 속성을 찾아내도록 유추할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PropEventSource<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token generic-function\"><span class=\"token function\">on</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">&amp;</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>eventName<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token constant\">K</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">Changed</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">callback</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>newValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">makeWatchedObject</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> PropEventSource<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token function\">makeWatchedObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  firstName<span class=\"token operator\">:</span> <span class=\"token string\">'Homer'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span>\n  location<span class=\"token operator\">:</span> <span class=\"token string\">'Springfield'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// works! 'newName' is typed as 'string'</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'firstNameChanged'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 'newName' has the type of 'firstName'</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">new name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>newName<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// works! 'newAge' is typed as 'number'</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ageChanged'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>newAge<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newAge <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'warning! negative age'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 on을 일반 메서드로 만들었다. 사용자가 <code class=\"language-text\">\"firstNameChanged\"</code> 문자열로 호출하면 TypeScript는 K에 대한 적절한 타입을 추론하려고 한다. 이를 위해 \"Changed\" 이전의 내용과 K를 대조하여 <code class=\"language-text\">\"firstName\"</code> 문자열을 추론한다. TypeScript가 이를 파악하면 on 메서드는 원래 객체에서 <code class=\"language-text\">firstName</code>의 타입을 가져올 수 있고, 이 경우에는 string이다. 비슷하게 <code class=\"language-text\">\"ageChanged\"</code>로 호출할 때는 숫자인 <code class=\"language-text\">age</code> 속성의 타입을 찾는다).</p>\n<p>추론은 종종 문자열을 분해하고 다른 방식으로 재구성하는 데 다양한 방식으로 결합될 수 있다. 사실, 이러한 문자열 리터럴 타입 수정을 돕기 위해 문자 케이싱을 수정하기 위한 새로운 유틸리티 타입 별칭 몇 개가 추가되었다(예 : 소문자 및 대문자 문자로 변환).</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">EnthusiasticGreeting<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>Uppercase<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">HELLO</span></span> <span class=\"token operator\">=</span> EnthusiasticGreeting<span class=\"token operator\">&lt;</span><span class=\"token string\">'hello'</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// type HELLO = \"HELLO\"</span></code></pre></div>\n<p>새로운 타입 별칭은 <code class=\"language-text\">Uppercase</code>, <code class=\"language-text\">Lowercase</code>, <code class=\"language-text\">Capitalize</code> 및 <code class=\"language-text\">Uncapitalize</code>이다. 처음 두 개는 문자열의 모든 문자를 변환하고, 나머지 두 개는 문자열의 첫 번째 문자만 변환한다.</p>\n<h2 id=\"매핑된-타입의-키-재매핑\">매핑된 타입의 키 재매핑</h2>\n<p>매핑된 타입은 임의의 키 기반으로 새로운 객체 타입을 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Options</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token string\">'noImplicitAny'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'strictNullChecks'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'strictFunctionTypes'</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// same as</span>\n<span class=\"token comment\">//   type Options = {</span>\n<span class=\"token comment\">//       noImplicitAny?: boolean,</span>\n<span class=\"token comment\">//       strictNullChecks?: boolean,</span>\n<span class=\"token comment\">//       strictFunctionTypes?: boolean</span>\n<span class=\"token comment\">//   };</span></code></pre></div>\n<p>또는 다른 객체 타입을 기반으로 새로운 객체 타입을 만들 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/// 'Partial&lt;T>' is the same as 'T', but with each property marked optional.</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Partial<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>지금까지 매핑된 타입은 제공된 키를 기반으로만 새로운 객체 타입을 생성할 수 있었다. 그러나 대부분의 경우 입력에 기반하여 새로운 키를 만들거나 기존 키를 필터링하려는 경우가 많다.</p>\n<p>이것이 TypeScript 4.1에서 새로운 <code class=\"language-text\">as</code> 절을 사용하여 매핑된 타입에서 키를 다시 매핑할 수 있도록 허용하는 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">MappedTypeWithNewKeys<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">as</span> NewKeyType<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//            ^^^^^^^^^^^^^</span>\n  <span class=\"token comment\">//            This is the new syntax!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 새로운 <code class=\"language-text\">as</code> 절을 사용하면 템플릿 리터럴 타입과 같은 기능을 활용하여 기존 속성을 기반으로 속성 이름을 쉽게 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Getters<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">as</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">get</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>Capitalize<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  location<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">LazyPerson</span> <span class=\"token operator\">=</span> Getters<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">LazyPerson</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">getName</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">getAge</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">getLocation</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한, <code class=\"language-text\">never</code>를 생성함으로써 키를 필터링할 수도 있다. 이는 경우에 따라 추가적인 <code class=\"language-text\">Omit</code> 헬퍼 타입을 사용하지 않아도 된다는 것을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Remove the 'kind' property</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">RemoveKindField<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">as</span> Exclude<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'kind'</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Circle</span> <span class=\"token punctuation\">{</span>\n  kind<span class=\"token operator\">:</span> <span class=\"token string\">'circle'</span><span class=\"token punctuation\">;</span>\n  radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">KindlessCircle</span> <span class=\"token operator\">=</span> RemoveKindField<span class=\"token operator\">&lt;</span>Circle<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// type KindlessCircle = {</span>\n<span class=\"token comment\">//     radius: number;</span>\n<span class=\"token comment\">// }</span></code></pre></div>\n<h2 id=\"재귀-조건부-타입\">재귀 조건부 타입</h2>\n<p>JS에선 임의의 레벨에서 컨테이너 타입을 펼치고 빌드하는 함수를 자주 볼 수 있다. 예를 들어 <code class=\"language-text\">Promise</code> 인스턴스의 <code class=\"language-text\">.then()</code> 메서드를 생각해보자. <code class=\"language-text\">.then(...)</code>은 'promise-like'이 아닌 값이 나올 때까지 각 프로미스를 풀고, 그 값을 콜백으로 전달한다. 또한 상대적으로 새로운 <code class=\"language-text\">flat</code> 메서드가 있고, 이는 배열을 얼마나 깊이 펼칠지를 나타내는 depth를 사용할 수 있다.</p>\n<p>TS의 타입 시스템에서 이를 표현하는 것은 사실상 불가능하다. 이를 구현하기 위한 해키한 기법이 있지만, 타입은 매우 불합리해 보인다.</p>\n<p>그래서 TS 4.1은 조건부 타입에 대한 제한을 완하하여 이러한 패턴을 모델링할 수 있도록 했다. TS 4.1에서 조건부 타입은 이제 분기 안에서 즉시 자신을 참조할 수 있으므로, 재귀적인 타입 별칭을 작성하기가 더 쉬워졌다.</p>\n<p>예를들어, 중첩된 배열의 요소 타입을 가져오는 타입을 작성하려면 다음 <code class=\"language-text\">deepFlatten</code> 타입을 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ElementType<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ReadonlyArray<span class=\"token operator\">&lt;</span><span class=\"token keyword\">infer</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span> <span class=\"token operator\">?</span> ElementType<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">deepFlatten</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">readonly</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ElementType<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token string\">'not implemented'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// All of these return the type 'number[]':</span>\n<span class=\"token function\">deepFlatten</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">deepFlatten</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">deepFlatten</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>마찬가지로, TypeScript 4.1에서는 <code class=\"language-text\">Promise</code>를 깊게 풀어내는 <code class=\"language-text\">Awaited</code> 타입을 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Awaited<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PromiseLike<span class=\"token operator\">&lt;</span><span class=\"token keyword\">infer</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span> <span class=\"token operator\">?</span> Awaited<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/// Like `promise.then(...)`, but more accurate in types.</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">customThen</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">onFulfilled</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> Awaited<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>Awaited<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이러한 재귀적인 타입은 강력하지만, 책임 있고 절제되게 사용해야 한다는 것을 염두에 두어야 한다.</p>\n<p>첫째로, 이러한 타입은 많은 작업을 수행할 수 있으며, 이는 타입 체크 시간을 증가시킬 수 있다는 것을 의미한다. 콜라츠 추측이나 피보나치 수열의 숫자를 모델링하는 것은 재미있을 수 있지만, 이를 <code class=\"language-text\">.d.ts</code> 파일에서 npm에 배포하는 것은 지양해야 한다.</p>\n<p>또한 계산이 복잡할 뿐만 아니라, 이러한 타입은 충분히 복잡한 입력에 대해 내부 재귀 깊이 제한에 도달할 수 있다. 이 재귀 깊이 제한에 도달하면 컴파일 타임 오류가 발생한다. 일반적으로 실제적인 예제에서 실패하는 것보다는 이러한 타입을 사용하지 않는 것이 좋다.</p>\n<h2 id=\"확인된-인덱스-액세스--nouncheckedindexedaccess\">확인된 인덱스 액세스(<code class=\"language-text\">--noUncheckedIndexedAccess</code>)</h2>\n<p>TypeScript에는 인덱스 시그니처라는 기능이 있다. 이러한 시그니처는 사용자가 임의로 이름을 지정한 속성에 액세스할 수 있다는 것을 타입 시스템에 알리는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Options</span> <span class=\"token punctuation\">{</span>\n  path<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  permissions<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Extra properties are caught by this index signature.</span>\n  <span class=\"token punctuation\">[</span>propName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">checkOptions</span><span class=\"token punctuation\">(</span>opts<span class=\"token operator\">:</span> Options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  opts<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n  opts<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n\n  <span class=\"token comment\">// These are all allowed too!</span>\n  <span class=\"token comment\">// They have the type 'string | number'.</span>\n  opts<span class=\"token punctuation\">.</span>yadda<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  opts<span class=\"token punctuation\">[</span><span class=\"token string\">'foo bar baz'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  opts<span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 예제에서 <code class=\"language-text\">Options</code>은 인덱스 시그니처를 갖고 있으며, 이미 나열된 속성이 아닌 모든 액세스 속성은 <code class=\"language-text\">string | number</code> 타입을 가져야한다고 나타낸다. 이것은 자신이 무엇을하고 있는지 알고 있다고 가정하는 낙관적인 코드에 대해 편리하다. 그러나 대부분의 JavaScript 값은 모든 잠재적 속성 이름을 지원하지 않는다. 예를 들어, 이전 예제와 같이 <code class=\"language-text\">Math.random()</code>에 의해 생성된 속성 키를 갖는 값은 대부분의 타입에서 지원되지 않는다. 많은 사용자들에게 이러한 동작은 원하지 않는 것이었으며, strictNullChecks의 전체 엄격한 검사를 활용하지 않는 것처럼 느껴졌다.</p>\n<p>이것이 TypeScript 4.1에서 noUncheckedIndexedAccess라는 새로운 플래그가 제공되는 이유이다. 이 새로운 모드에서 모든 속성 액세스 (<code class=\"language-text\">foo.bar</code>와 같은) 또는 인덱스 액세스 (<code class=\"language-text\">foo[\"bar\"]</code>와 같은)는 잠재적으로 정의되지 않은 것으로 간주된다. 즉, 마지막 예제에서 <code class=\"language-text\">opts.yadda</code>는 <code class=\"language-text\">string | number</code> 대신 <code class=\"language-text\">string | number | undefined</code> 타입을 가지게된다. 그 속성에 액세스해야하는 경우, 먼저 존재 여부를 확인하거나 (후위 <code class=\"language-text\">!</code> 문자) non-null 단언 연산자를 사용해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">checkOptions</span><span class=\"token punctuation\">(</span>opts<span class=\"token operator\">:</span> Options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  opts<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span>\n  opts<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">;</span> <span class=\"token comment\">// number</span>\n\n  <span class=\"token comment\">// These are not allowed with noUncheckedIndexedAccess</span>\n  opts<span class=\"token punctuation\">.</span>yadda<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObject <span class=\"token keyword\">is</span> possibly <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">.</span>\n  opts<span class=\"token punctuation\">[</span><span class=\"token string\">\"foo bar baz\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObject <span class=\"token keyword\">is</span> possibly <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">.</span>\n  opts<span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObject <span class=\"token keyword\">is</span> possibly <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">.</span>\n\n  <span class=\"token comment\">// Checking if it's really there first.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>yadda<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>yadda<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Basically saying \"trust me I know what I'm doing\"</span>\n  <span class=\"token comment\">// with the '!' non-null assertion operator.</span>\n  opts<span class=\"token punctuation\">.</span>yadda<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>noUncheckedIndexedAccess를 사용하면 경계 검사 반복문에서도 배열에 대한 인덱싱이 더 엄격하게 검사된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">screamLines</span><span class=\"token punctuation\">(</span>strs<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// This will have issues</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> strs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Object is possibly 'undefined'.</span></code></pre></div>\n<p>인덱스가 필요하지 않은 경우 <code class=\"language-text\">for-of</code> 루프 또는 <code class=\"language-text\">forEach</code> 호출을 사용하여 개별 요소를 반복할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">screamLines</span><span class=\"token punctuation\">(</span>strs<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// This works fine</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> str <span class=\"token keyword\">of</span> strs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// This works fine</span>\n  strs<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 플래그는 범위를 벗어난 오류를 포착하는 데 유용할 수 있지만 많은 코드에서 노이즈가 많을 수 있으므로 strict 플래그에 의해 자동으로 활성화 되지 않는다. 그러나 이 기능이 흥미롭다면 자유롭게 사용해보고 팀의 코드베이스에 적합한지 판단해야 한다.</p>\n<h2 id=\"baseurl이-없는-paths\"><code class=\"language-text\">baseUrl</code>이 없는 <code class=\"language-text\">paths</code></h2>\n<p>경로 매핑을 사용하는 것은 매우 일반적이다. 종종 <code class=\"language-text\">imports</code>를 더 좋게 하기 위해, 모노레포 연결 동작을 시뮬레이션 하기 위해 사용한다.</p>\n<p>불행하게도 경로 매핑을 사용하도록 경로를 지정하려면 <code class=\"language-text\">baseUrl</code>이라는 옵션도 지정해야 했다. 이 옵션을 사용하면 기본 지정자 경로도 <code class=\"language-text\">baseUrl</code>에 상대적으로 도달할 수 있다. 이로 인해 종종 자동-imports에서 잘못된 경로가 사용되었다.</p>\n<p>TS 4.1에선 <code class=\"language-text\">paths</code> 옵션을 <code class=\"language-text\">baseUrl</code> 없이 사용할 수 있다. 이렇게 하면 이러한 문제 중 일부를 방지할 수 있다.</p>\n<h2 id=\"checkjs는-allowjs를-함축한다\"><code class=\"language-text\">checkJs</code>는 <code class=\"language-text\">allowJs</code>를 함축한다</h2>\n<p>이전에는 체크된 JS 프로젝트를 시작하는 경우 <code class=\"language-text\">allowJs</code>와 <code class=\"language-text\">checkJs</code>를 모두 설정해야 했다. 이것은 약간 성가신 일이었기 때문에 <code class=\"language-text\">checkJs</code>는 이제 기본적으로 <code class=\"language-text\">allowJs</code>를 의미한다.</p>\n<h2 id=\"react-17-jsx-factories\">React 17 JSX Factories</h2>\n<p>TypeScript 4.1에서는 jsx 컴파일러 옵션을 위해 두 개의 새로운 옵션을 지원한다. 이를 통해 React 17에서 새롭게 도입된 <code class=\"language-text\">jsx</code>와 <code class=\"language-text\">jsxs</code> 팩토리 함수를 지원한다.</p>\n<ul>\n<li><code class=\"language-text\">react-jsx</code></li>\n<li><code class=\"language-text\">react-jsxdev</code></li>\n</ul>\n<p>이러한 옵션들은 각각 production 및 development 컴파일용으로 만들어졌다. 종종 하나의 옵션에서 다른 옵션을 확장할 수 있다. 예를 들어, <code class=\"language-text\">tsconfig.json</code>은 다음과 같이 구성될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// ./src/tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"module\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"esnext\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"target\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"es2015\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"jsx\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"react-jsx\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"strict\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./**/*\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>개발용 빌드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// ./src/tsconfig.dev.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"jsx\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"react-jsxdev\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"에디터에서-jsdoc의-see-태그-지원\">에디터에서 JSDoc의 <code class=\"language-text\">@see</code> 태그 지원</h2>\n<p>JSDoc 태그 <code class=\"language-text\">@see</code>는 이제 TypeScript와 JavaScript 에디터에서 더 나은 지원을 받는다. 이를 통해 태그 뒤에 점(.)이 있는 이름에서 go-to-definition과 같은 기능을 사용할 수 있다. 예를 들어, 다음 예제의 JSDoc 주석에서 <code class=\"language-text\">first</code> 또는 <code class=\"language-text\">C</code>에서 정의로 이동하는 것이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// @filename: first.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// @filename: main.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> first <span class=\"token keyword\">from</span> <span class=\"token string\">'./first'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * @see first.C\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">related</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"breaking-changes\">Breaking Changes</h2>\n<h3 id=\"libdts-변경-사항\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</h3>\n<p><code class=\"language-text\">lib.d.ts</code>의 변경된 API 세트에는 DOM 타입이 자동으로 생성되는 방식에 따라 일부 변화가 있을 수 있다. 한 가지 구체적인 변경 사항은 ES2016에서 제거되었기 때문에 <code class=\"language-text\">Reflect.enumerate</code>가 제거되었다.</p>\n<h3 id=\"abstract-멤버는-async로-마킹될-수-없다\"><code class=\"language-text\">abstract</code> 멤버는 <code class=\"language-text\">async</code>로 마킹될 수 없다</h3>\n<p><code class=\"language-text\">abstract</code> 멤버로 표시된 멤버에는 더 이상 <code class=\"language-text\">async</code>가 표시될 수 없다. 여기서 수정해야 할 부분은 <code class=\"language-text\">async</code> 키워드를 제거하는 것이다. 호출자는 반환되는 타입에만 관심이 있기 때문이다.</p>\n<h3 id=\"any--unknown-이-falsy-값-위치에서-전파됨\"><code class=\"language-text\">any</code> / <code class=\"language-text\">unknown</code> 이 falsy 값 위치에서 전파됨</h3>\n<p>이전에는 <code class=\"language-text\">foo &amp;&amp; somethingElse</code>와 같은 식에서 <code class=\"language-text\">foo</code>의 타입이 <code class=\"language-text\">any</code> 또는 <code class=\"language-text\">unknown</code>인 경우 전체 식의 타입은 <code class=\"language-text\">somethingElse</code>의 타입이 되었다.</p>\n<p>예를 들어, 이전에는 <code class=\"language-text\">x</code>의 타입이 <code class=\"language-text\">{ someProp: string }</code>이었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> foo<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> somethingElse<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> someProp<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">&amp;&amp;</span> somethingElse<span class=\"token punctuation\">;</span></code></pre></div>\n<p>그러나 TS 4.1에선 이 타입을 어떻게 결정할지 더 주의하기로 했다. <code class=\"language-text\">&amp;&amp;</code>의 왼쪽에 있는 타입에 대해 알려진 것이 없으므로 오른쪽 타입 대신 <code class=\"language-text\">any</code> 및 <code class=\"language-text\">unknown</code>을 외부로 전파한다.</p>\n<p>가장 일반적인 패턴은 특히 조건 함수에서 <code class=\"language-text\">boolean</code>과의 호환성을 확인할 때이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isThing</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">.</span>blah <span class=\"token operator\">===</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>종종 적절한 수정은 <code class=\"language-text\">foo &amp;&amp; someExpression</code>에서 <code class=\"language-text\">!!foo &amp;&amp; someExpression</code>으로 전환하는 것이다.</p>\n<h3 id=\"promise에서-resolve-의-매개변수는-더-이상-선택사항이-아니다\"><code class=\"language-text\">Promise</code>에서 <code class=\"language-text\">resolve</code> 의 매개변수는 더 이상 선택사항이 아니다.</h3>\n<p>다음과 같은 코드를 작성할 때</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>다음과 같은 오류가 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span>\n<span class=\"token comment\">// error TS2554: Expected 1 arguments, but got 0.</span>\n<span class=\"token comment\">//  An argument for 'value' was not provided.</span></code></pre></div>\n<p>이는 <code class=\"language-text\">resolve</code>에 더 이상 선택적 매개변수가 없기 때문에 기본적으로 값을 전달해야 한다. 이것은 <code class=\"language-text\">Promise</code>를 사용하여 적합한 버그를 포착하는 경우가 많다. 일반적인 수정은 올바른 인수를 전달하고 때로는 명시적인 타입 인수를 추가하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//     ^^^^^^^^</span>\n  <span class=\"token function\">doSomethingAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//      ^^^^^</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그러나 때때로 <code class=\"language-text\">resolve()</code>는 실제로 인수 없이 호출되어야 한다. 이러한 경우 <code class=\"language-text\">Promise</code>에 명시적 <code class=\"language-text\">void</code> 제네릭 형식 인수를 지정할 수 있다.(즉, <code class=\"language-text\">Promise&lt;void></code>로 작성). 이는 잠재적으로 <code class=\"language-text\">void</code>인 후행 매개변수가 선택 사항이 될 수 있는 TS 4.1의 새로운 기능을 활용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//     ^^^^^^</span>\n  <span class=\"token function\">doSomethingAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>TS 4.1은 이 break를 수정하는 데 도움이 되는 빠른 수정과 함께 제공된다.</p>\n<h3 id=\"조건부-스프레드는-선택적-속성을-생성한다\">조건부 스프레드는 선택적 속성을 생성한다</h3>\n<p>JS에서 <code class=\"language-text\">{...foo}</code>와 같은 객체 스프레드는 잘못된 값에 대해 작동하지 않는다. 따라서 <code class=\"language-text\">{...foo}</code>와 같은 코드에서 <code class=\"language-text\">foo</code>는 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">undefined</code> 인 경우 건너뛴다.</p>\n<p>많은 사용자가 이를 이용하여 '조건부' 속성을 spread 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  location<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  owner<span class=\"token operator\">:</span> Person<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">copyOwner</span><span class=\"token punctuation\">(</span>pet<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>pet <span class=\"token operator\">&amp;&amp;</span> pet<span class=\"token punctuation\">.</span>owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    otherStuff<span class=\"token operator\">:</span> <span class=\"token number\">123</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// We could also use optional chaining here:</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">copyOwner</span><span class=\"token punctuation\">(</span>pet<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>pet<span class=\"token operator\">?.</span>owner<span class=\"token punctuation\">,</span>\n    otherStuff<span class=\"token operator\">:</span> <span class=\"token number\">123</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기에서 만약 <code class=\"language-text\">pet</code>이 정의되면 <code class=\"language-text\">pet.owner</code>의 속성이 spread된다. 그렇지 않으면 속성이 반환된 객체로 spread되지 않는다.</p>\n<p><code class=\"language-text\">copyOwner</code>의 반환 타입은 이전에 각 스프레드를 기반으로 하는 통합 타입이었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{ x: number } | { x: number, name: string, age: number, location: string }</code></pre></div>\n<p>이는 연산이 발생하는 방식을 정확하게 모델링 했다. <code class=\"language-text\">pet</code>이 정의된 경우 <code class=\"language-text\">Person</code>의 모든 속성이 표시된다. 그렇지 않으면 결과에 정의되지 않는다. all or nothing한 방법이었다.</p>\n<p>그러나 단일 객체에 수백 개의 스프레드가 있고 각각의 스프레드가 잠재적으로 수백 또는 수천 개의 속성을 추가하는 극단적인 패턴을 보았다. 여러가지 이유로 이것은 매우 비싸고 일반적으로 많은 이점이 없는 것으로 밝혀졌다.</p>\n<p>TS 4.1에서 반환된 타입은 때때로 모든 선택적 속성을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token punctuation\">{</span>\n    x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    name<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    age<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    location<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>결과적으로 성능이 더 좋아지고 일반적으로 더 잘 표시된다.</p>\n<p>현재 이 동작이 완전히 일관되지는 않지만 향후 릴리스에서는 보다 깨끗하고 예측 가능한 결과를 생성할 것으로 기대한다.</p>\n<h3 id=\"일치하지-않는-매개변수는-더-이상-관련이-없다\">일치하지 않는 매개변수는 더 이상 관련이 없다</h3>\n<p>TS는 이전에 서로 일치하지 않는 매개변수를 <code class=\"language-text\">any</code> 타입에 대응하였다. TS 4.1의 변경 사항으로 언어는 이제 이 프로세스를 건너뛴다. 이는 일부 할당 가능성 사례가 이제 실패하지만 일부 과부하 해결 사례도 실패할 수 있음을 의미한다. 예를 들어, Node.js의 <code class=\"language-text\">util.promisify</code>에 대한 오버로드 해결은 TS 4.1에서 다른 오버로드를 선택할 수 있으며, 때때로 새롭거나 다른 오류 다운스트림을 유발할 수 있다.</p>\n<p>이에 대한 해결방안으로 타입 단언을 사용하여 오류를 억제하는 것이 가장 좋다.</p>","frontmatter":{"date":"23.02.14","description":"TypeScript 4.1 Release를 번역하면서 어떤 기능들이 전에 나왔는지 학습합니다.","heroImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAh0lEQVR42mOwD9z6n5qYga4GOgRhx2QbaOO35b+Vz+b/Ft6b/1v6bPpv6b3pv5XvZvIMtPXf8j8q68D/+LyD/1NLjvxPKTr8P7X4yP/o7ANgOQdyDAxO3vs/p+rY//TSI/8T8g/9zyg7+j825wDY5bi8TpyXvSDepcjLyBHjGLSNOpEyKNIhAOZkyEi64JPsAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png","srcSet":"/static/6952768edde771e3e65071afc7efe37d/a4d46/heroImage.png 175w,\n/static/6952768edde771e3e65071afc7efe37d/d8f52/heroImage.png 350w,\n/static/6952768edde771e3e65071afc7efe37d/18b2e/heroImage.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/6952768edde771e3e65071afc7efe37d/eac4f/heroImage.webp 175w,\n/static/6952768edde771e3e65071afc7efe37d/a4795/heroImage.webp 350w,\n/static/6952768edde771e3e65071afc7efe37d/377b6/heroImage.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":350}}},"heroImageAlt":"타입스크립트","tags":["TypeScript","번역"],"title":"TypeScript 4.1 번역"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%83%80%EC%9E%85\">템플릿 리터럴 타입</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%A4%ED%95%91%EB%90%9C-%ED%83%80%EC%9E%85%EC%9D%98-%ED%82%A4-%EC%9E%AC%EB%A7%A4%ED%95%91\">매핑된 타입의 키 재매핑</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%AC%EA%B7%80-%EC%A1%B0%EA%B1%B4%EB%B6%80-%ED%83%80%EC%9E%85\">재귀 조건부 타입</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%99%95%EC%9D%B8%EB%90%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%95%A1%EC%84%B8%EC%8A%A4--nouncheckedindexedaccess\">확인된 인덱스 액세스(<code class=\"language-text\">--noUncheckedIndexedAccess</code>)</a></p>\n</li>\n<li>\n<p><a href=\"#baseurl%EC%9D%B4-%EC%97%86%EB%8A%94-paths\"><code class=\"language-text\">baseUrl</code>이 없는 <code class=\"language-text\">paths</code></a></p>\n</li>\n<li>\n<p><a href=\"#checkjs%EB%8A%94-allowjs%EB%A5%BC-%ED%95%A8%EC%B6%95%ED%95%9C%EB%8B%A4\"><code class=\"language-text\">checkJs</code>는 <code class=\"language-text\">allowJs</code>를 함축한다</a></p>\n</li>\n<li>\n<p><a href=\"#react-17-jsx-factories\">React 17 JSX Factories</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-jsdoc%EC%9D%98-see-%ED%83%9C%EA%B7%B8-%EC%A7%80%EC%9B%90\">에디터에서 JSDoc의 <code class=\"language-text\">@see</code> 태그 지원</a></p>\n</li>\n<li>\n<p><a href=\"#breaking-changes\">Breaking Changes</a></p>\n<ul>\n<li><a href=\"#libdts-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD\"><code class=\"language-text\">lib.d.ts</code> 변경 사항</a></li>\n<li><a href=\"#abstract-%EB%A9%A4%EB%B2%84%EB%8A%94-async%EB%A1%9C-%EB%A7%88%ED%82%B9%EB%90%A0-%EC%88%98-%EC%97%86%EB%8B%A4\"><code class=\"language-text\">abstract</code> 멤버는 <code class=\"language-text\">async</code>로 마킹될 수 없다</a></li>\n<li><a href=\"#any--unknown-%EC%9D%B4-falsy-%EA%B0%92-%EC%9C%84%EC%B9%98%EC%97%90%EC%84%9C-%EC%A0%84%ED%8C%8C%EB%90%A8\"><code class=\"language-text\">any</code> / <code class=\"language-text\">unknown</code> 이 falsy 값 위치에서 전파됨</a></li>\n<li><a href=\"#promise%EC%97%90%EC%84%9C-resolve-%EC%9D%98-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%8A%94-%EB%8D%94-%EC%9D%B4%EC%83%81-%EC%84%A0%ED%83%9D%EC%82%AC%ED%95%AD%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4\"><code class=\"language-text\">Promise</code>에서 <code class=\"language-text\">resolve</code> 의 매개변수는 더 이상 선택사항이 아니다.</a></li>\n<li><a href=\"#%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C%EB%8A%94-%EC%84%A0%ED%83%9D%EC%A0%81-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4\">조건부 스프레드는 선택적 속성을 생성한다</a></li>\n<li><a href=\"#%EC%9D%BC%EC%B9%98%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%8A%94-%EB%8D%94-%EC%9D%B4%EC%83%81-%EA%B4%80%EB%A0%A8%EC%9D%B4-%EC%97%86%EB%8B%A4\">일치하지 않는 매개변수는 더 이상 관련이 없다</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"9d61cf3f-bc23-596b-9900-0f6e621e1fe5","frontmatter__slug":"/translate-ts-4-1","previous":"/translate-ts-4-2","previousTitle":"TypeScript 4.2 번역","next":"/translate-ts-4-0","nextTitle":"TypeScript 4.0 번역"}},"staticQueryHashes":["1485575810"],"slicesMap":{}}